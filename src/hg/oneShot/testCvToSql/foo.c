/* foo.c was originally generated by the autoSql program, which also 
 * generated foo.h and foo.sql.  This module links the database and
 * the RAM representation of objects. */

#include "common.h"
#include "linefile.h"
#include "dystring.h"
#include "jksql.h"
#include "foo.h"


void cellLineStaticLoad(char **row, struct cellLine *ret)
/* Load a row from cellLine table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->symbol = row[0];
ret->deprecated = row[1];
ret->shortLabel = row[2];
ret->longLabel = row[3];
ret->organism = row[4];
ret->tissue = row[5];
ret->vendorName = row[6];
ret->vendorId = row[7];
ret->orderUrl = row[8];
ret->karyotype = row[9];
ret->lineage = row[10];
ret->termId = row[11];
ret->termUrl = row[12];
ret->color = row[13];
ret->sex = row[14];
ret->tier = sqlUnsigned(row[15]);
ret->protocol = row[16];
ret->category = row[17];
ret->lab = row[18];
ret->childOf = row[19];
ret->lots = sqlUnsigned(row[20]);
ret->derivedFrom = row[21];
ret->age = row[22];
ret->strain = row[23];
}

struct cellLine *cellLineLoad(char **row)
/* Load a cellLine from row fetched with select * from cellLine
 * from database.  Dispose of this with cellLineFree(). */
{
struct cellLine *ret;

AllocVar(ret);
ret->symbol = cloneString(row[0]);
ret->deprecated = cloneString(row[1]);
ret->shortLabel = cloneString(row[2]);
ret->longLabel = cloneString(row[3]);
ret->organism = cloneString(row[4]);
ret->tissue = cloneString(row[5]);
ret->vendorName = cloneString(row[6]);
ret->vendorId = cloneString(row[7]);
ret->orderUrl = cloneString(row[8]);
ret->karyotype = cloneString(row[9]);
ret->lineage = cloneString(row[10]);
ret->termId = cloneString(row[11]);
ret->termUrl = cloneString(row[12]);
ret->color = cloneString(row[13]);
ret->sex = cloneString(row[14]);
ret->tier = sqlUnsigned(row[15]);
ret->protocol = cloneString(row[16]);
ret->category = cloneString(row[17]);
ret->lab = cloneString(row[18]);
ret->childOf = cloneString(row[19]);
ret->lots = sqlUnsigned(row[20]);
ret->derivedFrom = cloneString(row[21]);
ret->age = cloneString(row[22]);
ret->strain = cloneString(row[23]);
return ret;
}

struct cellLine *cellLineLoadAll(char *fileName) 
/* Load all cellLine from a whitespace-separated file.
 * Dispose of this with cellLineFreeList(). */
{
struct cellLine *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[24];

while (lineFileRow(lf, row))
    {
    el = cellLineLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct cellLine *cellLineLoadAllByChar(char *fileName, char chopper) 
/* Load all cellLine from a chopper separated file.
 * Dispose of this with cellLineFreeList(). */
{
struct cellLine *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[24];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = cellLineLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct cellLine *cellLineCommaIn(char **pS, struct cellLine *ret)
/* Create a cellLine out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new cellLine */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->symbol = sqlStringComma(&s);
ret->deprecated = sqlStringComma(&s);
ret->shortLabel = sqlStringComma(&s);
ret->longLabel = sqlStringComma(&s);
ret->organism = sqlStringComma(&s);
ret->tissue = sqlStringComma(&s);
ret->vendorName = sqlStringComma(&s);
ret->vendorId = sqlStringComma(&s);
ret->orderUrl = sqlStringComma(&s);
ret->karyotype = sqlStringComma(&s);
ret->lineage = sqlStringComma(&s);
ret->termId = sqlStringComma(&s);
ret->termUrl = sqlStringComma(&s);
ret->color = sqlStringComma(&s);
ret->sex = sqlStringComma(&s);
ret->tier = sqlUnsignedComma(&s);
ret->protocol = sqlStringComma(&s);
ret->category = sqlStringComma(&s);
ret->lab = sqlStringComma(&s);
ret->childOf = sqlStringComma(&s);
ret->lots = sqlUnsignedComma(&s);
ret->derivedFrom = sqlStringComma(&s);
ret->age = sqlStringComma(&s);
ret->strain = sqlStringComma(&s);
*pS = s;
return ret;
}

void cellLineFree(struct cellLine **pEl)
/* Free a single dynamically allocated cellLine such as created
 * with cellLineLoad(). */
{
struct cellLine *el;

if ((el = *pEl) == NULL) return;
freeMem(el->symbol);
freeMem(el->deprecated);
freeMem(el->shortLabel);
freeMem(el->longLabel);
freeMem(el->organism);
freeMem(el->tissue);
freeMem(el->vendorName);
freeMem(el->vendorId);
freeMem(el->orderUrl);
freeMem(el->karyotype);
freeMem(el->lineage);
freeMem(el->termId);
freeMem(el->termUrl);
freeMem(el->color);
freeMem(el->sex);
freeMem(el->protocol);
freeMem(el->category);
freeMem(el->lab);
freeMem(el->childOf);
freeMem(el->derivedFrom);
freeMem(el->age);
freeMem(el->strain);
freez(pEl);
}

void cellLineFreeList(struct cellLine **pList)
/* Free a list of dynamically allocated cellLine's */
{
struct cellLine *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    cellLineFree(&el);
    }
*pList = NULL;
}

void cellLineOutput(struct cellLine *el, FILE *f, char sep, char lastSep) 
/* Print out cellLine.  Separate fields with sep. Follow last field with lastSep. */
{
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->symbol);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->deprecated);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->shortLabel);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->longLabel);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->organism);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->tissue);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->vendorName);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->vendorId);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->orderUrl);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->karyotype);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->lineage);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->termId);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->termUrl);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->color);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->sex);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%u", el->tier);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->protocol);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->category);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->lab);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->childOf);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%u", el->lots);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->derivedFrom);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->age);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->strain);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void antibodyStaticLoad(char **row, struct antibody *ret)
/* Load a row from antibody table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->symbol = row[0];
ret->deprecated = row[1];
ret->shortLabel = row[2];
ret->longLabel = row[3];
ret->target = row[4];
ret->targetDescription = row[5];
ret->vendorName = row[6];
ret->vendorId = row[7];
ret->orderUrl = row[8];
ret->lab = row[9];
ret->targetId = row[10];
ret->targetUrl = row[11];
ret->validation = row[12];
ret->lots = row[13];
ret->displayName = row[14];
}

struct antibody *antibodyLoad(char **row)
/* Load a antibody from row fetched with select * from antibody
 * from database.  Dispose of this with antibodyFree(). */
{
struct antibody *ret;

AllocVar(ret);
ret->symbol = cloneString(row[0]);
ret->deprecated = cloneString(row[1]);
ret->shortLabel = cloneString(row[2]);
ret->longLabel = cloneString(row[3]);
ret->target = cloneString(row[4]);
ret->targetDescription = cloneString(row[5]);
ret->vendorName = cloneString(row[6]);
ret->vendorId = cloneString(row[7]);
ret->orderUrl = cloneString(row[8]);
ret->lab = cloneString(row[9]);
ret->targetId = cloneString(row[10]);
ret->targetUrl = cloneString(row[11]);
ret->validation = cloneString(row[12]);
ret->lots = cloneString(row[13]);
ret->displayName = cloneString(row[14]);
return ret;
}

struct antibody *antibodyLoadAll(char *fileName) 
/* Load all antibody from a whitespace-separated file.
 * Dispose of this with antibodyFreeList(). */
{
struct antibody *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[15];

while (lineFileRow(lf, row))
    {
    el = antibodyLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct antibody *antibodyLoadAllByChar(char *fileName, char chopper) 
/* Load all antibody from a chopper separated file.
 * Dispose of this with antibodyFreeList(). */
{
struct antibody *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[15];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = antibodyLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct antibody *antibodyCommaIn(char **pS, struct antibody *ret)
/* Create a antibody out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new antibody */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->symbol = sqlStringComma(&s);
ret->deprecated = sqlStringComma(&s);
ret->shortLabel = sqlStringComma(&s);
ret->longLabel = sqlStringComma(&s);
ret->target = sqlStringComma(&s);
ret->targetDescription = sqlStringComma(&s);
ret->vendorName = sqlStringComma(&s);
ret->vendorId = sqlStringComma(&s);
ret->orderUrl = sqlStringComma(&s);
ret->lab = sqlStringComma(&s);
ret->targetId = sqlStringComma(&s);
ret->targetUrl = sqlStringComma(&s);
ret->validation = sqlStringComma(&s);
ret->lots = sqlStringComma(&s);
ret->displayName = sqlStringComma(&s);
*pS = s;
return ret;
}

void antibodyFree(struct antibody **pEl)
/* Free a single dynamically allocated antibody such as created
 * with antibodyLoad(). */
{
struct antibody *el;

if ((el = *pEl) == NULL) return;
freeMem(el->symbol);
freeMem(el->deprecated);
freeMem(el->shortLabel);
freeMem(el->longLabel);
freeMem(el->target);
freeMem(el->targetDescription);
freeMem(el->vendorName);
freeMem(el->vendorId);
freeMem(el->orderUrl);
freeMem(el->lab);
freeMem(el->targetId);
freeMem(el->targetUrl);
freeMem(el->validation);
freeMem(el->lots);
freeMem(el->displayName);
freez(pEl);
}

void antibodyFreeList(struct antibody **pList)
/* Free a list of dynamically allocated antibody's */
{
struct antibody *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    antibodyFree(&el);
    }
*pList = NULL;
}

void antibodyOutput(struct antibody *el, FILE *f, char sep, char lastSep) 
/* Print out antibody.  Separate fields with sep. Follow last field with lastSep. */
{
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->symbol);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->deprecated);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->shortLabel);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->longLabel);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->target);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->targetDescription);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->vendorName);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->vendorId);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->orderUrl);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->lab);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->targetId);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->targetUrl);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->validation);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->lots);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->displayName);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void mapAlgorithmStaticLoad(char **row, struct mapAlgorithm *ret)
/* Load a row from mapAlgorithm table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->symbol = row[0];
ret->deprecated = row[1];
ret->shortLabel = row[2];
ret->longLabel = row[3];
}

struct mapAlgorithm *mapAlgorithmLoad(char **row)
/* Load a mapAlgorithm from row fetched with select * from mapAlgorithm
 * from database.  Dispose of this with mapAlgorithmFree(). */
{
struct mapAlgorithm *ret;

AllocVar(ret);
ret->symbol = cloneString(row[0]);
ret->deprecated = cloneString(row[1]);
ret->shortLabel = cloneString(row[2]);
ret->longLabel = cloneString(row[3]);
return ret;
}

struct mapAlgorithm *mapAlgorithmLoadAll(char *fileName) 
/* Load all mapAlgorithm from a whitespace-separated file.
 * Dispose of this with mapAlgorithmFreeList(). */
{
struct mapAlgorithm *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileRow(lf, row))
    {
    el = mapAlgorithmLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct mapAlgorithm *mapAlgorithmLoadAllByChar(char *fileName, char chopper) 
/* Load all mapAlgorithm from a chopper separated file.
 * Dispose of this with mapAlgorithmFreeList(). */
{
struct mapAlgorithm *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = mapAlgorithmLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct mapAlgorithm *mapAlgorithmCommaIn(char **pS, struct mapAlgorithm *ret)
/* Create a mapAlgorithm out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new mapAlgorithm */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->symbol = sqlStringComma(&s);
ret->deprecated = sqlStringComma(&s);
ret->shortLabel = sqlStringComma(&s);
ret->longLabel = sqlStringComma(&s);
*pS = s;
return ret;
}

void mapAlgorithmFree(struct mapAlgorithm **pEl)
/* Free a single dynamically allocated mapAlgorithm such as created
 * with mapAlgorithmLoad(). */
{
struct mapAlgorithm *el;

if ((el = *pEl) == NULL) return;
freeMem(el->symbol);
freeMem(el->deprecated);
freeMem(el->shortLabel);
freeMem(el->longLabel);
freez(pEl);
}

void mapAlgorithmFreeList(struct mapAlgorithm **pList)
/* Free a list of dynamically allocated mapAlgorithm's */
{
struct mapAlgorithm *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    mapAlgorithmFree(&el);
    }
*pList = NULL;
}

void mapAlgorithmOutput(struct mapAlgorithm *el, FILE *f, char sep, char lastSep) 
/* Print out mapAlgorithm.  Separate fields with sep. Follow last field with lastSep. */
{
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->symbol);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->deprecated);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->shortLabel);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->longLabel);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void readTypeStaticLoad(char **row, struct readType *ret)
/* Load a row from readType table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->symbol = row[0];
ret->deprecated = row[1];
ret->shortLabel = row[2];
ret->longLabel = row[3];
}

struct readType *readTypeLoad(char **row)
/* Load a readType from row fetched with select * from readType
 * from database.  Dispose of this with readTypeFree(). */
{
struct readType *ret;

AllocVar(ret);
ret->symbol = cloneString(row[0]);
ret->deprecated = cloneString(row[1]);
ret->shortLabel = cloneString(row[2]);
ret->longLabel = cloneString(row[3]);
return ret;
}

struct readType *readTypeLoadAll(char *fileName) 
/* Load all readType from a whitespace-separated file.
 * Dispose of this with readTypeFreeList(). */
{
struct readType *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileRow(lf, row))
    {
    el = readTypeLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct readType *readTypeLoadAllByChar(char *fileName, char chopper) 
/* Load all readType from a chopper separated file.
 * Dispose of this with readTypeFreeList(). */
{
struct readType *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = readTypeLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct readType *readTypeCommaIn(char **pS, struct readType *ret)
/* Create a readType out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new readType */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->symbol = sqlStringComma(&s);
ret->deprecated = sqlStringComma(&s);
ret->shortLabel = sqlStringComma(&s);
ret->longLabel = sqlStringComma(&s);
*pS = s;
return ret;
}

void readTypeFree(struct readType **pEl)
/* Free a single dynamically allocated readType such as created
 * with readTypeLoad(). */
{
struct readType *el;

if ((el = *pEl) == NULL) return;
freeMem(el->symbol);
freeMem(el->deprecated);
freeMem(el->shortLabel);
freeMem(el->longLabel);
freez(pEl);
}

void readTypeFreeList(struct readType **pList)
/* Free a list of dynamically allocated readType's */
{
struct readType *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    readTypeFree(&el);
    }
*pList = NULL;
}

void readTypeOutput(struct readType *el, FILE *f, char sep, char lastSep) 
/* Print out readType.  Separate fields with sep. Follow last field with lastSep. */
{
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->symbol);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->deprecated);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->shortLabel);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->longLabel);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void insertLengthStaticLoad(char **row, struct insertLength *ret)
/* Load a row from insertLength table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->symbol = row[0];
ret->deprecated = row[1];
ret->shortLabel = row[2];
ret->longLabel = row[3];
}

struct insertLength *insertLengthLoad(char **row)
/* Load a insertLength from row fetched with select * from insertLength
 * from database.  Dispose of this with insertLengthFree(). */
{
struct insertLength *ret;

AllocVar(ret);
ret->symbol = cloneString(row[0]);
ret->deprecated = cloneString(row[1]);
ret->shortLabel = cloneString(row[2]);
ret->longLabel = cloneString(row[3]);
return ret;
}

struct insertLength *insertLengthLoadAll(char *fileName) 
/* Load all insertLength from a whitespace-separated file.
 * Dispose of this with insertLengthFreeList(). */
{
struct insertLength *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileRow(lf, row))
    {
    el = insertLengthLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct insertLength *insertLengthLoadAllByChar(char *fileName, char chopper) 
/* Load all insertLength from a chopper separated file.
 * Dispose of this with insertLengthFreeList(). */
{
struct insertLength *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = insertLengthLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct insertLength *insertLengthCommaIn(char **pS, struct insertLength *ret)
/* Create a insertLength out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new insertLength */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->symbol = sqlStringComma(&s);
ret->deprecated = sqlStringComma(&s);
ret->shortLabel = sqlStringComma(&s);
ret->longLabel = sqlStringComma(&s);
*pS = s;
return ret;
}

void insertLengthFree(struct insertLength **pEl)
/* Free a single dynamically allocated insertLength such as created
 * with insertLengthLoad(). */
{
struct insertLength *el;

if ((el = *pEl) == NULL) return;
freeMem(el->symbol);
freeMem(el->deprecated);
freeMem(el->shortLabel);
freeMem(el->longLabel);
freez(pEl);
}

void insertLengthFreeList(struct insertLength **pList)
/* Free a list of dynamically allocated insertLength's */
{
struct insertLength *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    insertLengthFree(&el);
    }
*pList = NULL;
}

void insertLengthOutput(struct insertLength *el, FILE *f, char sep, char lastSep) 
/* Print out insertLength.  Separate fields with sep. Follow last field with lastSep. */
{
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->symbol);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->deprecated);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->shortLabel);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->longLabel);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void fragSizeStaticLoad(char **row, struct fragSize *ret)
/* Load a row from fragSize table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->symbol = row[0];
ret->deprecated = row[1];
ret->shortLabel = row[2];
ret->longLabel = row[3];
}

struct fragSize *fragSizeLoad(char **row)
/* Load a fragSize from row fetched with select * from fragSize
 * from database.  Dispose of this with fragSizeFree(). */
{
struct fragSize *ret;

AllocVar(ret);
ret->symbol = cloneString(row[0]);
ret->deprecated = cloneString(row[1]);
ret->shortLabel = cloneString(row[2]);
ret->longLabel = cloneString(row[3]);
return ret;
}

struct fragSize *fragSizeLoadAll(char *fileName) 
/* Load all fragSize from a whitespace-separated file.
 * Dispose of this with fragSizeFreeList(). */
{
struct fragSize *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileRow(lf, row))
    {
    el = fragSizeLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct fragSize *fragSizeLoadAllByChar(char *fileName, char chopper) 
/* Load all fragSize from a chopper separated file.
 * Dispose of this with fragSizeFreeList(). */
{
struct fragSize *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = fragSizeLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct fragSize *fragSizeCommaIn(char **pS, struct fragSize *ret)
/* Create a fragSize out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new fragSize */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->symbol = sqlStringComma(&s);
ret->deprecated = sqlStringComma(&s);
ret->shortLabel = sqlStringComma(&s);
ret->longLabel = sqlStringComma(&s);
*pS = s;
return ret;
}

void fragSizeFree(struct fragSize **pEl)
/* Free a single dynamically allocated fragSize such as created
 * with fragSizeLoad(). */
{
struct fragSize *el;

if ((el = *pEl) == NULL) return;
freeMem(el->symbol);
freeMem(el->deprecated);
freeMem(el->shortLabel);
freeMem(el->longLabel);
freez(pEl);
}

void fragSizeFreeList(struct fragSize **pList)
/* Free a list of dynamically allocated fragSize's */
{
struct fragSize *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    fragSizeFree(&el);
    }
*pList = NULL;
}

void fragSizeOutput(struct fragSize *el, FILE *f, char sep, char lastSep) 
/* Print out fragSize.  Separate fields with sep. Follow last field with lastSep. */
{
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->symbol);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->deprecated);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->shortLabel);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->longLabel);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void localizationStaticLoad(char **row, struct localization *ret)
/* Load a row from localization table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->symbol = row[0];
ret->deprecated = row[1];
ret->shortLabel = row[2];
ret->longLabel = row[3];
ret->termId = row[4];
ret->termUrl = row[5];
}

struct localization *localizationLoad(char **row)
/* Load a localization from row fetched with select * from localization
 * from database.  Dispose of this with localizationFree(). */
{
struct localization *ret;

AllocVar(ret);
ret->symbol = cloneString(row[0]);
ret->deprecated = cloneString(row[1]);
ret->shortLabel = cloneString(row[2]);
ret->longLabel = cloneString(row[3]);
ret->termId = cloneString(row[4]);
ret->termUrl = cloneString(row[5]);
return ret;
}

struct localization *localizationLoadAll(char *fileName) 
/* Load all localization from a whitespace-separated file.
 * Dispose of this with localizationFreeList(). */
{
struct localization *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[6];

while (lineFileRow(lf, row))
    {
    el = localizationLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct localization *localizationLoadAllByChar(char *fileName, char chopper) 
/* Load all localization from a chopper separated file.
 * Dispose of this with localizationFreeList(). */
{
struct localization *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[6];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = localizationLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct localization *localizationCommaIn(char **pS, struct localization *ret)
/* Create a localization out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new localization */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->symbol = sqlStringComma(&s);
ret->deprecated = sqlStringComma(&s);
ret->shortLabel = sqlStringComma(&s);
ret->longLabel = sqlStringComma(&s);
ret->termId = sqlStringComma(&s);
ret->termUrl = sqlStringComma(&s);
*pS = s;
return ret;
}

void localizationFree(struct localization **pEl)
/* Free a single dynamically allocated localization such as created
 * with localizationLoad(). */
{
struct localization *el;

if ((el = *pEl) == NULL) return;
freeMem(el->symbol);
freeMem(el->deprecated);
freeMem(el->shortLabel);
freeMem(el->longLabel);
freeMem(el->termId);
freeMem(el->termUrl);
freez(pEl);
}

void localizationFreeList(struct localization **pList)
/* Free a list of dynamically allocated localization's */
{
struct localization *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    localizationFree(&el);
    }
*pList = NULL;
}

void localizationOutput(struct localization *el, FILE *f, char sep, char lastSep) 
/* Print out localization.  Separate fields with sep. Follow last field with lastSep. */
{
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->symbol);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->deprecated);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->shortLabel);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->longLabel);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->termId);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->termUrl);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void rnaExtractStaticLoad(char **row, struct rnaExtract *ret)
/* Load a row from rnaExtract table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->symbol = row[0];
ret->deprecated = row[1];
ret->shortLabel = row[2];
ret->longLabel = row[3];
}

struct rnaExtract *rnaExtractLoad(char **row)
/* Load a rnaExtract from row fetched with select * from rnaExtract
 * from database.  Dispose of this with rnaExtractFree(). */
{
struct rnaExtract *ret;

AllocVar(ret);
ret->symbol = cloneString(row[0]);
ret->deprecated = cloneString(row[1]);
ret->shortLabel = cloneString(row[2]);
ret->longLabel = cloneString(row[3]);
return ret;
}

struct rnaExtract *rnaExtractLoadAll(char *fileName) 
/* Load all rnaExtract from a whitespace-separated file.
 * Dispose of this with rnaExtractFreeList(). */
{
struct rnaExtract *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileRow(lf, row))
    {
    el = rnaExtractLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct rnaExtract *rnaExtractLoadAllByChar(char *fileName, char chopper) 
/* Load all rnaExtract from a chopper separated file.
 * Dispose of this with rnaExtractFreeList(). */
{
struct rnaExtract *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = rnaExtractLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct rnaExtract *rnaExtractCommaIn(char **pS, struct rnaExtract *ret)
/* Create a rnaExtract out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new rnaExtract */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->symbol = sqlStringComma(&s);
ret->deprecated = sqlStringComma(&s);
ret->shortLabel = sqlStringComma(&s);
ret->longLabel = sqlStringComma(&s);
*pS = s;
return ret;
}

void rnaExtractFree(struct rnaExtract **pEl)
/* Free a single dynamically allocated rnaExtract such as created
 * with rnaExtractLoad(). */
{
struct rnaExtract *el;

if ((el = *pEl) == NULL) return;
freeMem(el->symbol);
freeMem(el->deprecated);
freeMem(el->shortLabel);
freeMem(el->longLabel);
freez(pEl);
}

void rnaExtractFreeList(struct rnaExtract **pList)
/* Free a list of dynamically allocated rnaExtract's */
{
struct rnaExtract *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    rnaExtractFree(&el);
    }
*pList = NULL;
}

void rnaExtractOutput(struct rnaExtract *el, FILE *f, char sep, char lastSep) 
/* Print out rnaExtract.  Separate fields with sep. Follow last field with lastSep. */
{
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->symbol);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->deprecated);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->shortLabel);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->longLabel);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void promoterStaticLoad(char **row, struct promoter *ret)
/* Load a row from promoter table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->symbol = row[0];
ret->deprecated = row[1];
ret->shortLabel = row[2];
ret->longLabel = row[3];
}

struct promoter *promoterLoad(char **row)
/* Load a promoter from row fetched with select * from promoter
 * from database.  Dispose of this with promoterFree(). */
{
struct promoter *ret;

AllocVar(ret);
ret->symbol = cloneString(row[0]);
ret->deprecated = cloneString(row[1]);
ret->shortLabel = cloneString(row[2]);
ret->longLabel = cloneString(row[3]);
return ret;
}

struct promoter *promoterLoadAll(char *fileName) 
/* Load all promoter from a whitespace-separated file.
 * Dispose of this with promoterFreeList(). */
{
struct promoter *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileRow(lf, row))
    {
    el = promoterLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct promoter *promoterLoadAllByChar(char *fileName, char chopper) 
/* Load all promoter from a chopper separated file.
 * Dispose of this with promoterFreeList(). */
{
struct promoter *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = promoterLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct promoter *promoterCommaIn(char **pS, struct promoter *ret)
/* Create a promoter out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new promoter */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->symbol = sqlStringComma(&s);
ret->deprecated = sqlStringComma(&s);
ret->shortLabel = sqlStringComma(&s);
ret->longLabel = sqlStringComma(&s);
*pS = s;
return ret;
}

void promoterFree(struct promoter **pEl)
/* Free a single dynamically allocated promoter such as created
 * with promoterLoad(). */
{
struct promoter *el;

if ((el = *pEl) == NULL) return;
freeMem(el->symbol);
freeMem(el->deprecated);
freeMem(el->shortLabel);
freeMem(el->longLabel);
freez(pEl);
}

void promoterFreeList(struct promoter **pList)
/* Free a list of dynamically allocated promoter's */
{
struct promoter *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    promoterFree(&el);
    }
*pList = NULL;
}

void promoterOutput(struct promoter *el, FILE *f, char sep, char lastSep) 
/* Print out promoter.  Separate fields with sep. Follow last field with lastSep. */
{
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->symbol);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->deprecated);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->shortLabel);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->longLabel);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void controlStaticLoad(char **row, struct control *ret)
/* Load a row from control table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->symbol = row[0];
ret->deprecated = row[1];
ret->shortLabel = row[2];
ret->longLabel = row[3];
}

struct control *controlLoad(char **row)
/* Load a control from row fetched with select * from control
 * from database.  Dispose of this with controlFree(). */
{
struct control *ret;

AllocVar(ret);
ret->symbol = cloneString(row[0]);
ret->deprecated = cloneString(row[1]);
ret->shortLabel = cloneString(row[2]);
ret->longLabel = cloneString(row[3]);
return ret;
}

struct control *controlLoadAll(char *fileName) 
/* Load all control from a whitespace-separated file.
 * Dispose of this with controlFreeList(). */
{
struct control *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileRow(lf, row))
    {
    el = controlLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct control *controlLoadAllByChar(char *fileName, char chopper) 
/* Load all control from a chopper separated file.
 * Dispose of this with controlFreeList(). */
{
struct control *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = controlLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct control *controlCommaIn(char **pS, struct control *ret)
/* Create a control out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new control */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->symbol = sqlStringComma(&s);
ret->deprecated = sqlStringComma(&s);
ret->shortLabel = sqlStringComma(&s);
ret->longLabel = sqlStringComma(&s);
*pS = s;
return ret;
}

void controlFree(struct control **pEl)
/* Free a single dynamically allocated control such as created
 * with controlLoad(). */
{
struct control *el;

if ((el = *pEl) == NULL) return;
freeMem(el->symbol);
freeMem(el->deprecated);
freeMem(el->shortLabel);
freeMem(el->longLabel);
freez(pEl);
}

void controlFreeList(struct control **pList)
/* Free a list of dynamically allocated control's */
{
struct control *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    controlFree(&el);
    }
*pList = NULL;
}

void controlOutput(struct control *el, FILE *f, char sep, char lastSep) 
/* Print out control.  Separate fields with sep. Follow last field with lastSep. */
{
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->symbol);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->deprecated);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->shortLabel);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->longLabel);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void treatmentStaticLoad(char **row, struct treatment *ret)
/* Load a row from treatment table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->symbol = row[0];
ret->deprecated = row[1];
ret->shortLabel = row[2];
ret->longLabel = row[3];
}

struct treatment *treatmentLoad(char **row)
/* Load a treatment from row fetched with select * from treatment
 * from database.  Dispose of this with treatmentFree(). */
{
struct treatment *ret;

AllocVar(ret);
ret->symbol = cloneString(row[0]);
ret->deprecated = cloneString(row[1]);
ret->shortLabel = cloneString(row[2]);
ret->longLabel = cloneString(row[3]);
return ret;
}

struct treatment *treatmentLoadAll(char *fileName) 
/* Load all treatment from a whitespace-separated file.
 * Dispose of this with treatmentFreeList(). */
{
struct treatment *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileRow(lf, row))
    {
    el = treatmentLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct treatment *treatmentLoadAllByChar(char *fileName, char chopper) 
/* Load all treatment from a chopper separated file.
 * Dispose of this with treatmentFreeList(). */
{
struct treatment *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = treatmentLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct treatment *treatmentCommaIn(char **pS, struct treatment *ret)
/* Create a treatment out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new treatment */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->symbol = sqlStringComma(&s);
ret->deprecated = sqlStringComma(&s);
ret->shortLabel = sqlStringComma(&s);
ret->longLabel = sqlStringComma(&s);
*pS = s;
return ret;
}

void treatmentFree(struct treatment **pEl)
/* Free a single dynamically allocated treatment such as created
 * with treatmentLoad(). */
{
struct treatment *el;

if ((el = *pEl) == NULL) return;
freeMem(el->symbol);
freeMem(el->deprecated);
freeMem(el->shortLabel);
freeMem(el->longLabel);
freez(pEl);
}

void treatmentFreeList(struct treatment **pList)
/* Free a list of dynamically allocated treatment's */
{
struct treatment *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    treatmentFree(&el);
    }
*pList = NULL;
}

void treatmentOutput(struct treatment *el, FILE *f, char sep, char lastSep) 
/* Print out treatment.  Separate fields with sep. Follow last field with lastSep. */
{
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->symbol);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->deprecated);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->shortLabel);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->longLabel);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void protocolStaticLoad(char **row, struct protocol *ret)
/* Load a row from protocol table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->symbol = row[0];
ret->deprecated = row[1];
ret->shortLabel = row[2];
ret->longLabel = row[3];
}

struct protocol *protocolLoad(char **row)
/* Load a protocol from row fetched with select * from protocol
 * from database.  Dispose of this with protocolFree(). */
{
struct protocol *ret;

AllocVar(ret);
ret->symbol = cloneString(row[0]);
ret->deprecated = cloneString(row[1]);
ret->shortLabel = cloneString(row[2]);
ret->longLabel = cloneString(row[3]);
return ret;
}

struct protocol *protocolLoadAll(char *fileName) 
/* Load all protocol from a whitespace-separated file.
 * Dispose of this with protocolFreeList(). */
{
struct protocol *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileRow(lf, row))
    {
    el = protocolLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct protocol *protocolLoadAllByChar(char *fileName, char chopper) 
/* Load all protocol from a chopper separated file.
 * Dispose of this with protocolFreeList(). */
{
struct protocol *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = protocolLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct protocol *protocolCommaIn(char **pS, struct protocol *ret)
/* Create a protocol out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new protocol */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->symbol = sqlStringComma(&s);
ret->deprecated = sqlStringComma(&s);
ret->shortLabel = sqlStringComma(&s);
ret->longLabel = sqlStringComma(&s);
*pS = s;
return ret;
}

void protocolFree(struct protocol **pEl)
/* Free a single dynamically allocated protocol such as created
 * with protocolLoad(). */
{
struct protocol *el;

if ((el = *pEl) == NULL) return;
freeMem(el->symbol);
freeMem(el->deprecated);
freeMem(el->shortLabel);
freeMem(el->longLabel);
freez(pEl);
}

void protocolFreeList(struct protocol **pList)
/* Free a list of dynamically allocated protocol's */
{
struct protocol *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    protocolFree(&el);
    }
*pList = NULL;
}

void protocolOutput(struct protocol *el, FILE *f, char sep, char lastSep) 
/* Print out protocol.  Separate fields with sep. Follow last field with lastSep. */
{
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->symbol);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->deprecated);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->shortLabel);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->longLabel);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void phaseStaticLoad(char **row, struct phase *ret)
/* Load a row from phase table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->symbol = row[0];
ret->deprecated = row[1];
ret->shortLabel = row[2];
ret->longLabel = row[3];
}

struct phase *phaseLoad(char **row)
/* Load a phase from row fetched with select * from phase
 * from database.  Dispose of this with phaseFree(). */
{
struct phase *ret;

AllocVar(ret);
ret->symbol = cloneString(row[0]);
ret->deprecated = cloneString(row[1]);
ret->shortLabel = cloneString(row[2]);
ret->longLabel = cloneString(row[3]);
return ret;
}

struct phase *phaseLoadAll(char *fileName) 
/* Load all phase from a whitespace-separated file.
 * Dispose of this with phaseFreeList(). */
{
struct phase *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileRow(lf, row))
    {
    el = phaseLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct phase *phaseLoadAllByChar(char *fileName, char chopper) 
/* Load all phase from a chopper separated file.
 * Dispose of this with phaseFreeList(). */
{
struct phase *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = phaseLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct phase *phaseCommaIn(char **pS, struct phase *ret)
/* Create a phase out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new phase */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->symbol = sqlStringComma(&s);
ret->deprecated = sqlStringComma(&s);
ret->shortLabel = sqlStringComma(&s);
ret->longLabel = sqlStringComma(&s);
*pS = s;
return ret;
}

void phaseFree(struct phase **pEl)
/* Free a single dynamically allocated phase such as created
 * with phaseLoad(). */
{
struct phase *el;

if ((el = *pEl) == NULL) return;
freeMem(el->symbol);
freeMem(el->deprecated);
freeMem(el->shortLabel);
freeMem(el->longLabel);
freez(pEl);
}

void phaseFreeList(struct phase **pList)
/* Free a list of dynamically allocated phase's */
{
struct phase *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    phaseFree(&el);
    }
*pList = NULL;
}

void phaseOutput(struct phase *el, FILE *f, char sep, char lastSep) 
/* Print out phase.  Separate fields with sep. Follow last field with lastSep. */
{
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->symbol);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->deprecated);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->shortLabel);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->longLabel);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void regionStaticLoad(char **row, struct region *ret)
/* Load a row from region table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->symbol = row[0];
ret->deprecated = row[1];
ret->shortLabel = row[2];
ret->longLabel = row[3];
}

struct region *regionLoad(char **row)
/* Load a region from row fetched with select * from region
 * from database.  Dispose of this with regionFree(). */
{
struct region *ret;

AllocVar(ret);
ret->symbol = cloneString(row[0]);
ret->deprecated = cloneString(row[1]);
ret->shortLabel = cloneString(row[2]);
ret->longLabel = cloneString(row[3]);
return ret;
}

struct region *regionLoadAll(char *fileName) 
/* Load all region from a whitespace-separated file.
 * Dispose of this with regionFreeList(). */
{
struct region *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileRow(lf, row))
    {
    el = regionLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct region *regionLoadAllByChar(char *fileName, char chopper) 
/* Load all region from a chopper separated file.
 * Dispose of this with regionFreeList(). */
{
struct region *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = regionLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct region *regionCommaIn(char **pS, struct region *ret)
/* Create a region out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new region */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->symbol = sqlStringComma(&s);
ret->deprecated = sqlStringComma(&s);
ret->shortLabel = sqlStringComma(&s);
ret->longLabel = sqlStringComma(&s);
*pS = s;
return ret;
}

void regionFree(struct region **pEl)
/* Free a single dynamically allocated region such as created
 * with regionLoad(). */
{
struct region *el;

if ((el = *pEl) == NULL) return;
freeMem(el->symbol);
freeMem(el->deprecated);
freeMem(el->shortLabel);
freeMem(el->longLabel);
freez(pEl);
}

void regionFreeList(struct region **pList)
/* Free a list of dynamically allocated region's */
{
struct region *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    regionFree(&el);
    }
*pList = NULL;
}

void regionOutput(struct region *el, FILE *f, char sep, char lastSep) 
/* Print out region.  Separate fields with sep. Follow last field with lastSep. */
{
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->symbol);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->deprecated);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->shortLabel);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->longLabel);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void restrictionEnzymeStaticLoad(char **row, struct restrictionEnzyme *ret)
/* Load a row from restrictionEnzyme table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->symbol = row[0];
ret->deprecated = row[1];
ret->shortLabel = row[2];
ret->longLabel = row[3];
}

struct restrictionEnzyme *restrictionEnzymeLoad(char **row)
/* Load a restrictionEnzyme from row fetched with select * from restrictionEnzyme
 * from database.  Dispose of this with restrictionEnzymeFree(). */
{
struct restrictionEnzyme *ret;

AllocVar(ret);
ret->symbol = cloneString(row[0]);
ret->deprecated = cloneString(row[1]);
ret->shortLabel = cloneString(row[2]);
ret->longLabel = cloneString(row[3]);
return ret;
}

struct restrictionEnzyme *restrictionEnzymeLoadAll(char *fileName) 
/* Load all restrictionEnzyme from a whitespace-separated file.
 * Dispose of this with restrictionEnzymeFreeList(). */
{
struct restrictionEnzyme *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileRow(lf, row))
    {
    el = restrictionEnzymeLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct restrictionEnzyme *restrictionEnzymeLoadAllByChar(char *fileName, char chopper) 
/* Load all restrictionEnzyme from a chopper separated file.
 * Dispose of this with restrictionEnzymeFreeList(). */
{
struct restrictionEnzyme *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = restrictionEnzymeLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct restrictionEnzyme *restrictionEnzymeCommaIn(char **pS, struct restrictionEnzyme *ret)
/* Create a restrictionEnzyme out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new restrictionEnzyme */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->symbol = sqlStringComma(&s);
ret->deprecated = sqlStringComma(&s);
ret->shortLabel = sqlStringComma(&s);
ret->longLabel = sqlStringComma(&s);
*pS = s;
return ret;
}

void restrictionEnzymeFree(struct restrictionEnzyme **pEl)
/* Free a single dynamically allocated restrictionEnzyme such as created
 * with restrictionEnzymeLoad(). */
{
struct restrictionEnzyme *el;

if ((el = *pEl) == NULL) return;
freeMem(el->symbol);
freeMem(el->deprecated);
freeMem(el->shortLabel);
freeMem(el->longLabel);
freez(pEl);
}

void restrictionEnzymeFreeList(struct restrictionEnzyme **pList)
/* Free a list of dynamically allocated restrictionEnzyme's */
{
struct restrictionEnzyme *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    restrictionEnzymeFree(&el);
    }
*pList = NULL;
}

void restrictionEnzymeOutput(struct restrictionEnzyme *el, FILE *f, char sep, char lastSep) 
/* Print out restrictionEnzyme.  Separate fields with sep. Follow last field with lastSep. */
{
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->symbol);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->deprecated);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->shortLabel);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->longLabel);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void viewStaticLoad(char **row, struct view *ret)
/* Load a row from view table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->symbol = row[0];
ret->deprecated = row[1];
ret->shortLabel = row[2];
ret->longLabel = row[3];
}

struct view *viewLoad(char **row)
/* Load a view from row fetched with select * from view
 * from database.  Dispose of this with viewFree(). */
{
struct view *ret;

AllocVar(ret);
ret->symbol = cloneString(row[0]);
ret->deprecated = cloneString(row[1]);
ret->shortLabel = cloneString(row[2]);
ret->longLabel = cloneString(row[3]);
return ret;
}

struct view *viewLoadAll(char *fileName) 
/* Load all view from a whitespace-separated file.
 * Dispose of this with viewFreeList(). */
{
struct view *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileRow(lf, row))
    {
    el = viewLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct view *viewLoadAllByChar(char *fileName, char chopper) 
/* Load all view from a chopper separated file.
 * Dispose of this with viewFreeList(). */
{
struct view *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = viewLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct view *viewCommaIn(char **pS, struct view *ret)
/* Create a view out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new view */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->symbol = sqlStringComma(&s);
ret->deprecated = sqlStringComma(&s);
ret->shortLabel = sqlStringComma(&s);
ret->longLabel = sqlStringComma(&s);
*pS = s;
return ret;
}

void viewFree(struct view **pEl)
/* Free a single dynamically allocated view such as created
 * with viewLoad(). */
{
struct view *el;

if ((el = *pEl) == NULL) return;
freeMem(el->symbol);
freeMem(el->deprecated);
freeMem(el->shortLabel);
freeMem(el->longLabel);
freez(pEl);
}

void viewFreeList(struct view **pList)
/* Free a list of dynamically allocated view's */
{
struct view *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    viewFree(&el);
    }
*pList = NULL;
}

void viewOutput(struct view *el, FILE *f, char sep, char lastSep) 
/* Print out view.  Separate fields with sep. Follow last field with lastSep. */
{
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->symbol);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->deprecated);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->shortLabel);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->longLabel);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void dataTypeStaticLoad(char **row, struct dataType *ret)
/* Load a row from dataType table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->symbol = row[0];
ret->deprecated = row[1];
ret->shortLabel = row[2];
ret->longLabel = row[3];
ret->dataGroup = row[4];
}

struct dataType *dataTypeLoad(char **row)
/* Load a dataType from row fetched with select * from dataType
 * from database.  Dispose of this with dataTypeFree(). */
{
struct dataType *ret;

AllocVar(ret);
ret->symbol = cloneString(row[0]);
ret->deprecated = cloneString(row[1]);
ret->shortLabel = cloneString(row[2]);
ret->longLabel = cloneString(row[3]);
ret->dataGroup = cloneString(row[4]);
return ret;
}

struct dataType *dataTypeLoadAll(char *fileName) 
/* Load all dataType from a whitespace-separated file.
 * Dispose of this with dataTypeFreeList(). */
{
struct dataType *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[5];

while (lineFileRow(lf, row))
    {
    el = dataTypeLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct dataType *dataTypeLoadAllByChar(char *fileName, char chopper) 
/* Load all dataType from a chopper separated file.
 * Dispose of this with dataTypeFreeList(). */
{
struct dataType *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[5];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = dataTypeLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct dataType *dataTypeCommaIn(char **pS, struct dataType *ret)
/* Create a dataType out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new dataType */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->symbol = sqlStringComma(&s);
ret->deprecated = sqlStringComma(&s);
ret->shortLabel = sqlStringComma(&s);
ret->longLabel = sqlStringComma(&s);
ret->dataGroup = sqlStringComma(&s);
*pS = s;
return ret;
}

void dataTypeFree(struct dataType **pEl)
/* Free a single dynamically allocated dataType such as created
 * with dataTypeLoad(). */
{
struct dataType *el;

if ((el = *pEl) == NULL) return;
freeMem(el->symbol);
freeMem(el->deprecated);
freeMem(el->shortLabel);
freeMem(el->longLabel);
freeMem(el->dataGroup);
freez(pEl);
}

void dataTypeFreeList(struct dataType **pList)
/* Free a list of dynamically allocated dataType's */
{
struct dataType *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    dataTypeFree(&el);
    }
*pList = NULL;
}

void dataTypeOutput(struct dataType *el, FILE *f, char sep, char lastSep) 
/* Print out dataType.  Separate fields with sep. Follow last field with lastSep. */
{
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->symbol);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->deprecated);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->shortLabel);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->longLabel);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->dataGroup);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void versionStaticLoad(char **row, struct version *ret)
/* Load a row from version table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->symbol = row[0];
ret->deprecated = row[1];
ret->shortLabel = row[2];
ret->longLabel = row[3];
}

struct version *versionLoad(char **row)
/* Load a version from row fetched with select * from version
 * from database.  Dispose of this with versionFree(). */
{
struct version *ret;

AllocVar(ret);
ret->symbol = cloneString(row[0]);
ret->deprecated = cloneString(row[1]);
ret->shortLabel = cloneString(row[2]);
ret->longLabel = cloneString(row[3]);
return ret;
}

struct version *versionLoadAll(char *fileName) 
/* Load all version from a whitespace-separated file.
 * Dispose of this with versionFreeList(). */
{
struct version *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileRow(lf, row))
    {
    el = versionLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct version *versionLoadAllByChar(char *fileName, char chopper) 
/* Load all version from a chopper separated file.
 * Dispose of this with versionFreeList(). */
{
struct version *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = versionLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct version *versionCommaIn(char **pS, struct version *ret)
/* Create a version out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new version */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->symbol = sqlStringComma(&s);
ret->deprecated = sqlStringComma(&s);
ret->shortLabel = sqlStringComma(&s);
ret->longLabel = sqlStringComma(&s);
*pS = s;
return ret;
}

void versionFree(struct version **pEl)
/* Free a single dynamically allocated version such as created
 * with versionLoad(). */
{
struct version *el;

if ((el = *pEl) == NULL) return;
freeMem(el->symbol);
freeMem(el->deprecated);
freeMem(el->shortLabel);
freeMem(el->longLabel);
freez(pEl);
}

void versionFreeList(struct version **pList)
/* Free a list of dynamically allocated version's */
{
struct version *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    versionFree(&el);
    }
*pList = NULL;
}

void versionOutput(struct version *el, FILE *f, char sep, char lastSep) 
/* Print out version.  Separate fields with sep. Follow last field with lastSep. */
{
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->symbol);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->deprecated);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->shortLabel);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->longLabel);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void strainStaticLoad(char **row, struct strain *ret)
/* Load a row from strain table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->symbol = row[0];
ret->deprecated = row[1];
ret->shortLabel = row[2];
ret->longLabel = row[3];
}

struct strain *strainLoad(char **row)
/* Load a strain from row fetched with select * from strain
 * from database.  Dispose of this with strainFree(). */
{
struct strain *ret;

AllocVar(ret);
ret->symbol = cloneString(row[0]);
ret->deprecated = cloneString(row[1]);
ret->shortLabel = cloneString(row[2]);
ret->longLabel = cloneString(row[3]);
return ret;
}

struct strain *strainLoadAll(char *fileName) 
/* Load all strain from a whitespace-separated file.
 * Dispose of this with strainFreeList(). */
{
struct strain *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileRow(lf, row))
    {
    el = strainLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct strain *strainLoadAllByChar(char *fileName, char chopper) 
/* Load all strain from a chopper separated file.
 * Dispose of this with strainFreeList(). */
{
struct strain *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = strainLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct strain *strainCommaIn(char **pS, struct strain *ret)
/* Create a strain out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new strain */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->symbol = sqlStringComma(&s);
ret->deprecated = sqlStringComma(&s);
ret->shortLabel = sqlStringComma(&s);
ret->longLabel = sqlStringComma(&s);
*pS = s;
return ret;
}

void strainFree(struct strain **pEl)
/* Free a single dynamically allocated strain such as created
 * with strainLoad(). */
{
struct strain *el;

if ((el = *pEl) == NULL) return;
freeMem(el->symbol);
freeMem(el->deprecated);
freeMem(el->shortLabel);
freeMem(el->longLabel);
freez(pEl);
}

void strainFreeList(struct strain **pList)
/* Free a list of dynamically allocated strain's */
{
struct strain *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    strainFree(&el);
    }
*pList = NULL;
}

void strainOutput(struct strain *el, FILE *f, char sep, char lastSep) 
/* Print out strain.  Separate fields with sep. Follow last field with lastSep. */
{
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->symbol);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->deprecated);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->shortLabel);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->longLabel);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void ageStaticLoad(char **row, struct age *ret)
/* Load a row from age table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->symbol = row[0];
ret->deprecated = row[1];
ret->shortLabel = row[2];
ret->longLabel = row[3];
ret->stage = row[4];
}

struct age *ageLoad(char **row)
/* Load a age from row fetched with select * from age
 * from database.  Dispose of this with ageFree(). */
{
struct age *ret;

AllocVar(ret);
ret->symbol = cloneString(row[0]);
ret->deprecated = cloneString(row[1]);
ret->shortLabel = cloneString(row[2]);
ret->longLabel = cloneString(row[3]);
ret->stage = cloneString(row[4]);
return ret;
}

struct age *ageLoadAll(char *fileName) 
/* Load all age from a whitespace-separated file.
 * Dispose of this with ageFreeList(). */
{
struct age *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[5];

while (lineFileRow(lf, row))
    {
    el = ageLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct age *ageLoadAllByChar(char *fileName, char chopper) 
/* Load all age from a chopper separated file.
 * Dispose of this with ageFreeList(). */
{
struct age *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[5];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = ageLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct age *ageCommaIn(char **pS, struct age *ret)
/* Create a age out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new age */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->symbol = sqlStringComma(&s);
ret->deprecated = sqlStringComma(&s);
ret->shortLabel = sqlStringComma(&s);
ret->longLabel = sqlStringComma(&s);
ret->stage = sqlStringComma(&s);
*pS = s;
return ret;
}

void ageFree(struct age **pEl)
/* Free a single dynamically allocated age such as created
 * with ageLoad(). */
{
struct age *el;

if ((el = *pEl) == NULL) return;
freeMem(el->symbol);
freeMem(el->deprecated);
freeMem(el->shortLabel);
freeMem(el->longLabel);
freeMem(el->stage);
freez(pEl);
}

void ageFreeList(struct age **pList)
/* Free a list of dynamically allocated age's */
{
struct age *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    ageFree(&el);
    }
*pList = NULL;
}

void ageOutput(struct age *el, FILE *f, char sep, char lastSep) 
/* Print out age.  Separate fields with sep. Follow last field with lastSep. */
{
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->symbol);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->deprecated);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->shortLabel);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->longLabel);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->stage);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void atticStaticLoad(char **row, struct attic *ret)
/* Load a row from attic table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->symbol = row[0];
ret->deprecated = row[1];
ret->shortLabel = row[2];
ret->longLabel = row[3];
}

struct attic *atticLoad(char **row)
/* Load a attic from row fetched with select * from attic
 * from database.  Dispose of this with atticFree(). */
{
struct attic *ret;

AllocVar(ret);
ret->symbol = cloneString(row[0]);
ret->deprecated = cloneString(row[1]);
ret->shortLabel = cloneString(row[2]);
ret->longLabel = cloneString(row[3]);
return ret;
}

struct attic *atticLoadAll(char *fileName) 
/* Load all attic from a whitespace-separated file.
 * Dispose of this with atticFreeList(). */
{
struct attic *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileRow(lf, row))
    {
    el = atticLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct attic *atticLoadAllByChar(char *fileName, char chopper) 
/* Load all attic from a chopper separated file.
 * Dispose of this with atticFreeList(). */
{
struct attic *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = atticLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct attic *atticCommaIn(char **pS, struct attic *ret)
/* Create a attic out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new attic */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->symbol = sqlStringComma(&s);
ret->deprecated = sqlStringComma(&s);
ret->shortLabel = sqlStringComma(&s);
ret->longLabel = sqlStringComma(&s);
*pS = s;
return ret;
}

void atticFree(struct attic **pEl)
/* Free a single dynamically allocated attic such as created
 * with atticLoad(). */
{
struct attic *el;

if ((el = *pEl) == NULL) return;
freeMem(el->symbol);
freeMem(el->deprecated);
freeMem(el->shortLabel);
freeMem(el->longLabel);
freez(pEl);
}

void atticFreeList(struct attic **pList)
/* Free a list of dynamically allocated attic's */
{
struct attic *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    atticFree(&el);
    }
*pList = NULL;
}

void atticOutput(struct attic *el, FILE *f, char sep, char lastSep) 
/* Print out attic.  Separate fields with sep. Follow last field with lastSep. */
{
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->symbol);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->deprecated);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->shortLabel);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->longLabel);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void categoryStaticLoad(char **row, struct category *ret)
/* Load a row from category table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->symbol = row[0];
ret->deprecated = row[1];
ret->shortLabel = row[2];
ret->longLabel = row[3];
}

struct category *categoryLoad(char **row)
/* Load a category from row fetched with select * from category
 * from database.  Dispose of this with categoryFree(). */
{
struct category *ret;

AllocVar(ret);
ret->symbol = cloneString(row[0]);
ret->deprecated = cloneString(row[1]);
ret->shortLabel = cloneString(row[2]);
ret->longLabel = cloneString(row[3]);
return ret;
}

struct category *categoryLoadAll(char *fileName) 
/* Load all category from a whitespace-separated file.
 * Dispose of this with categoryFreeList(). */
{
struct category *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileRow(lf, row))
    {
    el = categoryLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct category *categoryLoadAllByChar(char *fileName, char chopper) 
/* Load all category from a chopper separated file.
 * Dispose of this with categoryFreeList(). */
{
struct category *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = categoryLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct category *categoryCommaIn(char **pS, struct category *ret)
/* Create a category out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new category */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->symbol = sqlStringComma(&s);
ret->deprecated = sqlStringComma(&s);
ret->shortLabel = sqlStringComma(&s);
ret->longLabel = sqlStringComma(&s);
*pS = s;
return ret;
}

void categoryFree(struct category **pEl)
/* Free a single dynamically allocated category such as created
 * with categoryLoad(). */
{
struct category *el;

if ((el = *pEl) == NULL) return;
freeMem(el->symbol);
freeMem(el->deprecated);
freeMem(el->shortLabel);
freeMem(el->longLabel);
freez(pEl);
}

void categoryFreeList(struct category **pList)
/* Free a list of dynamically allocated category's */
{
struct category *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    categoryFree(&el);
    }
*pList = NULL;
}

void categoryOutput(struct category *el, FILE *f, char sep, char lastSep) 
/* Print out category.  Separate fields with sep. Follow last field with lastSep. */
{
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->symbol);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->deprecated);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->shortLabel);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->longLabel);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void sexStaticLoad(char **row, struct sex *ret)
/* Load a row from sex table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->symbol = row[0];
ret->deprecated = row[1];
ret->shortLabel = row[2];
ret->longLabel = row[3];
}

struct sex *sexLoad(char **row)
/* Load a sex from row fetched with select * from sex
 * from database.  Dispose of this with sexFree(). */
{
struct sex *ret;

AllocVar(ret);
ret->symbol = cloneString(row[0]);
ret->deprecated = cloneString(row[1]);
ret->shortLabel = cloneString(row[2]);
ret->longLabel = cloneString(row[3]);
return ret;
}

struct sex *sexLoadAll(char *fileName) 
/* Load all sex from a whitespace-separated file.
 * Dispose of this with sexFreeList(). */
{
struct sex *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileRow(lf, row))
    {
    el = sexLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct sex *sexLoadAllByChar(char *fileName, char chopper) 
/* Load all sex from a chopper separated file.
 * Dispose of this with sexFreeList(). */
{
struct sex *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = sexLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct sex *sexCommaIn(char **pS, struct sex *ret)
/* Create a sex out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new sex */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->symbol = sqlStringComma(&s);
ret->deprecated = sqlStringComma(&s);
ret->shortLabel = sqlStringComma(&s);
ret->longLabel = sqlStringComma(&s);
*pS = s;
return ret;
}

void sexFree(struct sex **pEl)
/* Free a single dynamically allocated sex such as created
 * with sexLoad(). */
{
struct sex *el;

if ((el = *pEl) == NULL) return;
freeMem(el->symbol);
freeMem(el->deprecated);
freeMem(el->shortLabel);
freeMem(el->longLabel);
freez(pEl);
}

void sexFreeList(struct sex **pList)
/* Free a list of dynamically allocated sex's */
{
struct sex *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    sexFree(&el);
    }
*pList = NULL;
}

void sexOutput(struct sex *el, FILE *f, char sep, char lastSep) 
/* Print out sex.  Separate fields with sep. Follow last field with lastSep. */
{
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->symbol);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->deprecated);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->shortLabel);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->longLabel);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void objStatusStaticLoad(char **row, struct objStatus *ret)
/* Load a row from objStatus table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->symbol = row[0];
ret->deprecated = row[1];
ret->shortLabel = row[2];
ret->longLabel = row[3];
}

struct objStatus *objStatusLoad(char **row)
/* Load a objStatus from row fetched with select * from objStatus
 * from database.  Dispose of this with objStatusFree(). */
{
struct objStatus *ret;

AllocVar(ret);
ret->symbol = cloneString(row[0]);
ret->deprecated = cloneString(row[1]);
ret->shortLabel = cloneString(row[2]);
ret->longLabel = cloneString(row[3]);
return ret;
}

struct objStatus *objStatusLoadAll(char *fileName) 
/* Load all objStatus from a whitespace-separated file.
 * Dispose of this with objStatusFreeList(). */
{
struct objStatus *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileRow(lf, row))
    {
    el = objStatusLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct objStatus *objStatusLoadAllByChar(char *fileName, char chopper) 
/* Load all objStatus from a chopper separated file.
 * Dispose of this with objStatusFreeList(). */
{
struct objStatus *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = objStatusLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct objStatus *objStatusCommaIn(char **pS, struct objStatus *ret)
/* Create a objStatus out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new objStatus */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->symbol = sqlStringComma(&s);
ret->deprecated = sqlStringComma(&s);
ret->shortLabel = sqlStringComma(&s);
ret->longLabel = sqlStringComma(&s);
*pS = s;
return ret;
}

void objStatusFree(struct objStatus **pEl)
/* Free a single dynamically allocated objStatus such as created
 * with objStatusLoad(). */
{
struct objStatus *el;

if ((el = *pEl) == NULL) return;
freeMem(el->symbol);
freeMem(el->deprecated);
freeMem(el->shortLabel);
freeMem(el->longLabel);
freez(pEl);
}

void objStatusFreeList(struct objStatus **pList)
/* Free a list of dynamically allocated objStatus's */
{
struct objStatus *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    objStatusFree(&el);
    }
*pList = NULL;
}

void objStatusOutput(struct objStatus *el, FILE *f, char sep, char lastSep) 
/* Print out objStatus.  Separate fields with sep. Follow last field with lastSep. */
{
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->symbol);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->deprecated);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->shortLabel);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->longLabel);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void organismStaticLoad(char **row, struct organism *ret)
/* Load a row from organism table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->symbol = row[0];
ret->deprecated = row[1];
ret->shortLabel = row[2];
ret->longLabel = row[3];
}

struct organism *organismLoad(char **row)
/* Load a organism from row fetched with select * from organism
 * from database.  Dispose of this with organismFree(). */
{
struct organism *ret;

AllocVar(ret);
ret->symbol = cloneString(row[0]);
ret->deprecated = cloneString(row[1]);
ret->shortLabel = cloneString(row[2]);
ret->longLabel = cloneString(row[3]);
return ret;
}

struct organism *organismLoadAll(char *fileName) 
/* Load all organism from a whitespace-separated file.
 * Dispose of this with organismFreeList(). */
{
struct organism *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileRow(lf, row))
    {
    el = organismLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct organism *organismLoadAllByChar(char *fileName, char chopper) 
/* Load all organism from a chopper separated file.
 * Dispose of this with organismFreeList(). */
{
struct organism *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = organismLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct organism *organismCommaIn(char **pS, struct organism *ret)
/* Create a organism out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new organism */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->symbol = sqlStringComma(&s);
ret->deprecated = sqlStringComma(&s);
ret->shortLabel = sqlStringComma(&s);
ret->longLabel = sqlStringComma(&s);
*pS = s;
return ret;
}

void organismFree(struct organism **pEl)
/* Free a single dynamically allocated organism such as created
 * with organismLoad(). */
{
struct organism *el;

if ((el = *pEl) == NULL) return;
freeMem(el->symbol);
freeMem(el->deprecated);
freeMem(el->shortLabel);
freeMem(el->longLabel);
freez(pEl);
}

void organismFreeList(struct organism **pList)
/* Free a list of dynamically allocated organism's */
{
struct organism *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    organismFree(&el);
    }
*pList = NULL;
}

void organismOutput(struct organism *el, FILE *f, char sep, char lastSep) 
/* Print out organism.  Separate fields with sep. Follow last field with lastSep. */
{
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->symbol);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->deprecated);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->shortLabel);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->longLabel);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void tissueSourceTypeStaticLoad(char **row, struct tissueSourceType *ret)
/* Load a row from tissueSourceType table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->symbol = row[0];
ret->deprecated = row[1];
ret->shortLabel = row[2];
ret->longLabel = row[3];
}

struct tissueSourceType *tissueSourceTypeLoad(char **row)
/* Load a tissueSourceType from row fetched with select * from tissueSourceType
 * from database.  Dispose of this with tissueSourceTypeFree(). */
{
struct tissueSourceType *ret;

AllocVar(ret);
ret->symbol = cloneString(row[0]);
ret->deprecated = cloneString(row[1]);
ret->shortLabel = cloneString(row[2]);
ret->longLabel = cloneString(row[3]);
return ret;
}

struct tissueSourceType *tissueSourceTypeLoadAll(char *fileName) 
/* Load all tissueSourceType from a whitespace-separated file.
 * Dispose of this with tissueSourceTypeFreeList(). */
{
struct tissueSourceType *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileRow(lf, row))
    {
    el = tissueSourceTypeLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct tissueSourceType *tissueSourceTypeLoadAllByChar(char *fileName, char chopper) 
/* Load all tissueSourceType from a chopper separated file.
 * Dispose of this with tissueSourceTypeFreeList(). */
{
struct tissueSourceType *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = tissueSourceTypeLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct tissueSourceType *tissueSourceTypeCommaIn(char **pS, struct tissueSourceType *ret)
/* Create a tissueSourceType out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new tissueSourceType */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->symbol = sqlStringComma(&s);
ret->deprecated = sqlStringComma(&s);
ret->shortLabel = sqlStringComma(&s);
ret->longLabel = sqlStringComma(&s);
*pS = s;
return ret;
}

void tissueSourceTypeFree(struct tissueSourceType **pEl)
/* Free a single dynamically allocated tissueSourceType such as created
 * with tissueSourceTypeLoad(). */
{
struct tissueSourceType *el;

if ((el = *pEl) == NULL) return;
freeMem(el->symbol);
freeMem(el->deprecated);
freeMem(el->shortLabel);
freeMem(el->longLabel);
freez(pEl);
}

void tissueSourceTypeFreeList(struct tissueSourceType **pList)
/* Free a list of dynamically allocated tissueSourceType's */
{
struct tissueSourceType *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    tissueSourceTypeFree(&el);
    }
*pList = NULL;
}

void tissueSourceTypeOutput(struct tissueSourceType *el, FILE *f, char sep, char lastSep) 
/* Print out tissueSourceType.  Separate fields with sep. Follow last field with lastSep. */
{
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->symbol);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->deprecated);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->shortLabel);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->longLabel);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void seqPlatformStaticLoad(char **row, struct seqPlatform *ret)
/* Load a row from seqPlatform table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->symbol = row[0];
ret->deprecated = row[1];
ret->shortLabel = row[2];
ret->longLabel = row[3];
ret->geoPlatformName = row[4];
}

struct seqPlatform *seqPlatformLoad(char **row)
/* Load a seqPlatform from row fetched with select * from seqPlatform
 * from database.  Dispose of this with seqPlatformFree(). */
{
struct seqPlatform *ret;

AllocVar(ret);
ret->symbol = cloneString(row[0]);
ret->deprecated = cloneString(row[1]);
ret->shortLabel = cloneString(row[2]);
ret->longLabel = cloneString(row[3]);
ret->geoPlatformName = cloneString(row[4]);
return ret;
}

struct seqPlatform *seqPlatformLoadAll(char *fileName) 
/* Load all seqPlatform from a whitespace-separated file.
 * Dispose of this with seqPlatformFreeList(). */
{
struct seqPlatform *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[5];

while (lineFileRow(lf, row))
    {
    el = seqPlatformLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct seqPlatform *seqPlatformLoadAllByChar(char *fileName, char chopper) 
/* Load all seqPlatform from a chopper separated file.
 * Dispose of this with seqPlatformFreeList(). */
{
struct seqPlatform *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[5];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = seqPlatformLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct seqPlatform *seqPlatformCommaIn(char **pS, struct seqPlatform *ret)
/* Create a seqPlatform out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new seqPlatform */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->symbol = sqlStringComma(&s);
ret->deprecated = sqlStringComma(&s);
ret->shortLabel = sqlStringComma(&s);
ret->longLabel = sqlStringComma(&s);
ret->geoPlatformName = sqlStringComma(&s);
*pS = s;
return ret;
}

void seqPlatformFree(struct seqPlatform **pEl)
/* Free a single dynamically allocated seqPlatform such as created
 * with seqPlatformLoad(). */
{
struct seqPlatform *el;

if ((el = *pEl) == NULL) return;
freeMem(el->symbol);
freeMem(el->deprecated);
freeMem(el->shortLabel);
freeMem(el->longLabel);
freeMem(el->geoPlatformName);
freez(pEl);
}

void seqPlatformFreeList(struct seqPlatform **pList)
/* Free a list of dynamically allocated seqPlatform's */
{
struct seqPlatform *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    seqPlatformFree(&el);
    }
*pList = NULL;
}

void seqPlatformOutput(struct seqPlatform *el, FILE *f, char sep, char lastSep) 
/* Print out seqPlatform.  Separate fields with sep. Follow last field with lastSep. */
{
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->symbol);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->deprecated);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->shortLabel);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->longLabel);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->geoPlatformName);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void platformStaticLoad(char **row, struct platform *ret)
/* Load a row from platform table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->symbol = row[0];
ret->deprecated = row[1];
ret->shortLabel = row[2];
ret->longLabel = row[3];
ret->geoPlatformName = row[4];
}

struct platform *platformLoad(char **row)
/* Load a platform from row fetched with select * from platform
 * from database.  Dispose of this with platformFree(). */
{
struct platform *ret;

AllocVar(ret);
ret->symbol = cloneString(row[0]);
ret->deprecated = cloneString(row[1]);
ret->shortLabel = cloneString(row[2]);
ret->longLabel = cloneString(row[3]);
ret->geoPlatformName = cloneString(row[4]);
return ret;
}

struct platform *platformLoadAll(char *fileName) 
/* Load all platform from a whitespace-separated file.
 * Dispose of this with platformFreeList(). */
{
struct platform *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[5];

while (lineFileRow(lf, row))
    {
    el = platformLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct platform *platformLoadAllByChar(char *fileName, char chopper) 
/* Load all platform from a chopper separated file.
 * Dispose of this with platformFreeList(). */
{
struct platform *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[5];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = platformLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct platform *platformCommaIn(char **pS, struct platform *ret)
/* Create a platform out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new platform */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->symbol = sqlStringComma(&s);
ret->deprecated = sqlStringComma(&s);
ret->shortLabel = sqlStringComma(&s);
ret->longLabel = sqlStringComma(&s);
ret->geoPlatformName = sqlStringComma(&s);
*pS = s;
return ret;
}

void platformFree(struct platform **pEl)
/* Free a single dynamically allocated platform such as created
 * with platformLoad(). */
{
struct platform *el;

if ((el = *pEl) == NULL) return;
freeMem(el->symbol);
freeMem(el->deprecated);
freeMem(el->shortLabel);
freeMem(el->longLabel);
freeMem(el->geoPlatformName);
freez(pEl);
}

void platformFreeList(struct platform **pList)
/* Free a list of dynamically allocated platform's */
{
struct platform *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    platformFree(&el);
    }
*pList = NULL;
}

void platformOutput(struct platform *el, FILE *f, char sep, char lastSep) 
/* Print out platform.  Separate fields with sep. Follow last field with lastSep. */
{
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->symbol);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->deprecated);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->shortLabel);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->longLabel);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->geoPlatformName);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void labStaticLoad(char **row, struct lab *ret)
/* Load a row from lab table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->symbol = row[0];
ret->deprecated = row[1];
ret->shortLabel = row[2];
ret->longLabel = row[3];
ret->labInst = row[4];
ret->labPi = row[5];
ret->labPiFull = row[6];
ret->grantPi = row[7];
ret->organism = row[8];
}

struct lab *labLoad(char **row)
/* Load a lab from row fetched with select * from lab
 * from database.  Dispose of this with labFree(). */
{
struct lab *ret;

AllocVar(ret);
ret->symbol = cloneString(row[0]);
ret->deprecated = cloneString(row[1]);
ret->shortLabel = cloneString(row[2]);
ret->longLabel = cloneString(row[3]);
ret->labInst = cloneString(row[4]);
ret->labPi = cloneString(row[5]);
ret->labPiFull = cloneString(row[6]);
ret->grantPi = cloneString(row[7]);
ret->organism = cloneString(row[8]);
return ret;
}

struct lab *labLoadAll(char *fileName) 
/* Load all lab from a whitespace-separated file.
 * Dispose of this with labFreeList(). */
{
struct lab *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[9];

while (lineFileRow(lf, row))
    {
    el = labLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct lab *labLoadAllByChar(char *fileName, char chopper) 
/* Load all lab from a chopper separated file.
 * Dispose of this with labFreeList(). */
{
struct lab *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[9];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = labLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct lab *labCommaIn(char **pS, struct lab *ret)
/* Create a lab out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new lab */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->symbol = sqlStringComma(&s);
ret->deprecated = sqlStringComma(&s);
ret->shortLabel = sqlStringComma(&s);
ret->longLabel = sqlStringComma(&s);
ret->labInst = sqlStringComma(&s);
ret->labPi = sqlStringComma(&s);
ret->labPiFull = sqlStringComma(&s);
ret->grantPi = sqlStringComma(&s);
ret->organism = sqlStringComma(&s);
*pS = s;
return ret;
}

void labFree(struct lab **pEl)
/* Free a single dynamically allocated lab such as created
 * with labLoad(). */
{
struct lab *el;

if ((el = *pEl) == NULL) return;
freeMem(el->symbol);
freeMem(el->deprecated);
freeMem(el->shortLabel);
freeMem(el->longLabel);
freeMem(el->labInst);
freeMem(el->labPi);
freeMem(el->labPiFull);
freeMem(el->grantPi);
freeMem(el->organism);
freez(pEl);
}

void labFreeList(struct lab **pList)
/* Free a list of dynamically allocated lab's */
{
struct lab *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    labFree(&el);
    }
*pList = NULL;
}

void labOutput(struct lab *el, FILE *f, char sep, char lastSep) 
/* Print out lab.  Separate fields with sep. Follow last field with lastSep. */
{
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->symbol);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->deprecated);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->shortLabel);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->longLabel);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->labInst);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->labPi);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->labPiFull);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->grantPi);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->organism);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void encodeGrantStaticLoad(char **row, struct encodeGrant *ret)
/* Load a row from encodeGrant table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->symbol = row[0];
ret->deprecated = row[1];
ret->shortLabel = row[2];
ret->longLabel = row[3];
ret->grantInst = row[4];
ret->projectName = row[5];
}

struct encodeGrant *encodeGrantLoad(char **row)
/* Load a encodeGrant from row fetched with select * from encodeGrant
 * from database.  Dispose of this with encodeGrantFree(). */
{
struct encodeGrant *ret;

AllocVar(ret);
ret->symbol = cloneString(row[0]);
ret->deprecated = cloneString(row[1]);
ret->shortLabel = cloneString(row[2]);
ret->longLabel = cloneString(row[3]);
ret->grantInst = cloneString(row[4]);
ret->projectName = cloneString(row[5]);
return ret;
}

struct encodeGrant *encodeGrantLoadAll(char *fileName) 
/* Load all encodeGrant from a whitespace-separated file.
 * Dispose of this with encodeGrantFreeList(). */
{
struct encodeGrant *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[6];

while (lineFileRow(lf, row))
    {
    el = encodeGrantLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct encodeGrant *encodeGrantLoadAllByChar(char *fileName, char chopper) 
/* Load all encodeGrant from a chopper separated file.
 * Dispose of this with encodeGrantFreeList(). */
{
struct encodeGrant *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[6];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = encodeGrantLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct encodeGrant *encodeGrantCommaIn(char **pS, struct encodeGrant *ret)
/* Create a encodeGrant out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new encodeGrant */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->symbol = sqlStringComma(&s);
ret->deprecated = sqlStringComma(&s);
ret->shortLabel = sqlStringComma(&s);
ret->longLabel = sqlStringComma(&s);
ret->grantInst = sqlStringComma(&s);
ret->projectName = sqlStringComma(&s);
*pS = s;
return ret;
}

void encodeGrantFree(struct encodeGrant **pEl)
/* Free a single dynamically allocated encodeGrant such as created
 * with encodeGrantLoad(). */
{
struct encodeGrant *el;

if ((el = *pEl) == NULL) return;
freeMem(el->symbol);
freeMem(el->deprecated);
freeMem(el->shortLabel);
freeMem(el->longLabel);
freeMem(el->grantInst);
freeMem(el->projectName);
freez(pEl);
}

void encodeGrantFreeList(struct encodeGrant **pList)
/* Free a list of dynamically allocated encodeGrant's */
{
struct encodeGrant *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    encodeGrantFree(&el);
    }
*pList = NULL;
}

void encodeGrantOutput(struct encodeGrant *el, FILE *f, char sep, char lastSep) 
/* Print out encodeGrant.  Separate fields with sep. Follow last field with lastSep. */
{
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->symbol);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->deprecated);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->shortLabel);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->longLabel);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->grantInst);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->projectName);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void typeOfTermStaticLoad(char **row, struct typeOfTerm *ret)
/* Load a row from typeOfTerm table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->symbol = row[0];
ret->deprecated = row[1];
ret->shortLabel = row[2];
ret->longLabel = row[3];
ret->searchable = row[4];
ret->cvDefined = row[5];
ret->validate = row[6];
ret->hidden = row[7];
ret->priority = sqlUnsigned(row[8]);
}

struct typeOfTerm *typeOfTermLoad(char **row)
/* Load a typeOfTerm from row fetched with select * from typeOfTerm
 * from database.  Dispose of this with typeOfTermFree(). */
{
struct typeOfTerm *ret;

AllocVar(ret);
ret->symbol = cloneString(row[0]);
ret->deprecated = cloneString(row[1]);
ret->shortLabel = cloneString(row[2]);
ret->longLabel = cloneString(row[3]);
ret->searchable = cloneString(row[4]);
ret->cvDefined = cloneString(row[5]);
ret->validate = cloneString(row[6]);
ret->hidden = cloneString(row[7]);
ret->priority = sqlUnsigned(row[8]);
return ret;
}

struct typeOfTerm *typeOfTermLoadAll(char *fileName) 
/* Load all typeOfTerm from a whitespace-separated file.
 * Dispose of this with typeOfTermFreeList(). */
{
struct typeOfTerm *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[9];

while (lineFileRow(lf, row))
    {
    el = typeOfTermLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct typeOfTerm *typeOfTermLoadAllByChar(char *fileName, char chopper) 
/* Load all typeOfTerm from a chopper separated file.
 * Dispose of this with typeOfTermFreeList(). */
{
struct typeOfTerm *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[9];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = typeOfTermLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct typeOfTerm *typeOfTermCommaIn(char **pS, struct typeOfTerm *ret)
/* Create a typeOfTerm out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new typeOfTerm */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->symbol = sqlStringComma(&s);
ret->deprecated = sqlStringComma(&s);
ret->shortLabel = sqlStringComma(&s);
ret->longLabel = sqlStringComma(&s);
ret->searchable = sqlStringComma(&s);
ret->cvDefined = sqlStringComma(&s);
ret->validate = sqlStringComma(&s);
ret->hidden = sqlStringComma(&s);
ret->priority = sqlUnsignedComma(&s);
*pS = s;
return ret;
}

void typeOfTermFree(struct typeOfTerm **pEl)
/* Free a single dynamically allocated typeOfTerm such as created
 * with typeOfTermLoad(). */
{
struct typeOfTerm *el;

if ((el = *pEl) == NULL) return;
freeMem(el->symbol);
freeMem(el->deprecated);
freeMem(el->shortLabel);
freeMem(el->longLabel);
freeMem(el->searchable);
freeMem(el->cvDefined);
freeMem(el->validate);
freeMem(el->hidden);
freez(pEl);
}

void typeOfTermFreeList(struct typeOfTerm **pList)
/* Free a list of dynamically allocated typeOfTerm's */
{
struct typeOfTerm *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    typeOfTermFree(&el);
    }
*pList = NULL;
}

void typeOfTermOutput(struct typeOfTerm *el, FILE *f, char sep, char lastSep) 
/* Print out typeOfTerm.  Separate fields with sep. Follow last field with lastSep. */
{
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->symbol);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->deprecated);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->shortLabel);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->longLabel);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->searchable);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->cvDefined);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->validate);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->hidden);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%u", el->priority);
fputc(lastSep,f);
}

/* -------------------------------- End autoSql Generated Code -------------------------------- */

