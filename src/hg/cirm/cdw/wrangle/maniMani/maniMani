#!/usr/bin/env python2.7
# addToStepTables
# Chris Eisenhart 09/03/2015 
# ceisenha@ucsc.edu/ceisenhart@soe.ucsc.edu
"""
This program is for the CIRM project. The program runs on two manifest.txt files that 
represent adjacent files in a pipeline (for example manifestFastq.txt and manifestKallisto.txt).
The program will generate SQL insert statements for the cdwStepIn, cdwStepRun and cdwStepOut tables
from these two manifest files.  The user must provide a 'linking column' which is a column that
maps the two manifest files together.  
"""

from __future__ import print_function
import  sys, operator, fileinput, collections, string, os.path
import  re, argparse, subprocess, MySQLdb
sys.path.append(os.path.join(os.path.dirname(__file__), 'pyLib'))
import common

someGlobal = 10000
stepCount = 0

def parseArgs(args): 
    """
    Parse the arguments into an opened file for reading (inputFile), and 
    an open file for writing (outputFile). 
    """
    parser = argparse.ArgumentParser(description = __doc__)
    parser.add_argument ("startManifest",
    help = " The starting manifest, should contain upstream files",
    type = argparse.FileType('r'))
    parser.add_argument ("endManifest",
    help = " The ending manifest, should contain downstream (by a single step) files.",
    type = argparse.FileType('r'))
    parser.add_argument ("insertCommands",
    help = " The output file where the SQL insert commands will be if printed.",
    type = argparse.FileType('w'))
    parser.add_argument ("--startMetaColumn", 
    help = " The meta column that links the manifest files, default is 3. This option is not currently supported. ",
    type = int, 
    action = 'store')
    parser.add_argument ("--endMetaColumn", 
    help = " The meta column that links the manifest files, default is 3. This option is not currently supported. ",
    type = int, 
    action = 'store')
    parser.add_argument ("--database",
    help = " The database that should be used, default is cdw_chris. ",
    action = "store")
    parser.add_argument ("--stepDef",
    help = " The stepDef value for the cdwStepRun inserts, default is 2 (Kallisto output).  ",
    type = int,
    action = "store")
    parser.add_argument ("--stepVersion",
    help = " The stepVersion value for the cdwStepRun inserts, default is 'unknown'. ",
    action = "store")
    parser.add_argument ("--realRun",
    help = " Actually perform the inserts! Note the stepRunId values will increment. ", 
    action = "store_true")
    parser.add_argument ("--verbose",
    help = " Show runtime messages.",
    action = "store_true")
    
    parser.set_defaults(verbose = False)
    parser.set_defaults(realRun = False)
    parser.set_defaults(database = "cdw_chris")
    parser.set_defaults(stepDef = 2)
    parser.set_defaults(stepVersion = "unknown")
    parser.set_defaults(startMetaColumn = 3)
    parser.set_defaults(endMetaColumn = 3)
    if (len(sys.argv) == 1): 
        parser.print_help()
        exit(1)
    options = parser.parse_args() #Options is a structure that holds the command line arguments information
    return options

# Some global variables if they are needed...

def readManiToDict(file, keyColumn, separator):
    """
    """
    result = dict()
    firstLine = True
    for line in file:
        if firstLine:
            firstLine = False
            continue
        splitLine = line[:-1].split(separator)
        count = 0
        list = []
        for item in splitLine: 
            list.append(item)
        if result.get(splitLine[keyColumn]):
            result[splitLine[keyColumn]].append(list)
        else: result.setdefault(splitLine[keyColumn],[list])
    return result 

def insertoToStepRunAndStepIn(startManifest, db, startToEndDict, stepDef, stepVersion, realRun, output, stupidTempValueForTesting, verbose):
    """
    """
    for key, value in startManifest.iteritems():
        idCur = db.cursor()
        # Insert the step into cdwStepRun.
        if (realRun): idCur.execute("insert into cdwStepRun (stepDef, stepVersion) values (%i, '%s')"%(stepDef, stepVersion))
        stepCmd = ("insert into cdwStepRun (stepDef, stepVersion) values (%i, '%s')"%(stepDef,stepVersion))
        output.write(stepCmd + "\n")
        if (verbose): print (stepCmd)
        stupidTempValueForTesting += 1
        inId = db.insert_id() # The id of the step that was inserted. 
        if inId==0: inId = stupidTempValueForTesting  
        if (realRun): startToEndDict.setdefault(key, inId) # Insert into the hash table, this will be used for the cdwStepOut inserts. 
        else: startToEndDict.setdefault(key, stupidTempValueForTesting)
        # Iterate over all rows (input files) that have this meta tag. 
        for row in value: 
            startId = 0 # This will hold the fileId. 
            cur = db.cursor()
            # Row[0] is a unique field (submission fileID) that is used to get the fileId
            cur.execute("select id from cdwFile where submitFileName = \"%s\""%(row[0]))
            for line in cur.fetchall():
                startId = line[0]  
            com2 = "insert into cdwStepIn (stepRunId, name, ix, fileId) values (%i,'%s',0,'%s')"%(inId, row[3], startId)
            if (realRun): cur.execute(com2) 
            output.write(com2+"\n")
            if (verbose): print (com2) 

def insertToStepOut(endManifest, db, startToEndDict, realRun, output, verbose):
    """
    """
    for key, value in endManifest.iteritems():
        for row in value: 
            endId = 0 # This will store the fileId. 
            cur = db.cursor()
            # Row[0] is a unique field (submission fileID) that is used to get the fileId
            cur.execute("select id from cdwFile where submitFileName = \"%s\""%(row[0]))
            for line in cur.fetchall():
                endId = line[0]
            com2 = "insert into cdwStepOut (stepRunId, name, ix, fileId) values (%i,'%s',0,'%s')"%(startToEndDict[key],row[2],endId)
            if (realRun): cur.execute(com2)
            output.write(com2+"\n")
            if (verbose): print (com2)

def main(args):
    """
    """
    options = parseArgs(args)

    options.insertCommands.write(" ".join(sys.argv)+"\n")

    # Set up the connection to the database. 
    hst, usr, pw = common.getSQLLoginInfo()
    db = MySQLdb.connect(host= hst,user = usr, passwd = pw, db = options.database)

    # Read in the manifest files.
    startManiDict = readManiToDict(options.startManifest, options.startMetaColumn, "\t")    
    endManiDict = readManiToDict(options.endManifest, options.endMetaColumn, "\t")
    startToEndDict = dict()
    
    # Generate the insert commands.
    insertoToStepRunAndStepIn(startManiDict, db, startToEndDict, options.stepDef, options.stepVersion, options.realRun, options.insertCommands, 25, options.verbose)
    insertToStepOut(endManiDict, db, startToEndDict, options.realRun, options.insertCommands, options.verbose)

if __name__ == "__main__" :
    sys.exit(main(sys.argv))

