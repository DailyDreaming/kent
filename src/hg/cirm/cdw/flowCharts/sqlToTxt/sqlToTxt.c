/* sqlToTxt - A program that runs through SQL tables and generates history flow chart information. */
#include "common.h"
#include "linefile.h"
#include "hash.h"
#include "options.h"
#include "jksql.h"

void usage()
/* Explain usage and exit. */
{
errAbort(
  "sqlToTxt - A program that runs through SQL tables and generates history flow chart information\n"
  "usage:\n"
  "   sqlToTxt XXX\n"
  "options:\n"
  "   -xxx=XXX\n"
  );
}

/* Command line validation table. */
static struct optionSpec options[] = {
   {NULL, 0},
};

int gKey = 0;
int gX = 200; 
int gY = 200; 

struct jsonLink
    {
    struct jsonLink *next; 
    char *text;
    int start;
    int end; 
    };

struct jsonNode
    {
    struct jsonNode *next;
    char *text; 
    int key; 
    bool diamond;
    int xloc; 
    int yloc; 
    };
    
struct jsonNode *newJsonNode(char *text, int key, bool diamond, int xloc, int yloc)
{
struct jsonNode *newNode; 
AllocVar(newNode); 
newNode->text=cloneString(text); 
newNode->key=key; 
newNode->diamond=diamond; 
newNode->xloc=xloc; 
newNode->yloc=yloc;
return newNode; 
}

struct jsonLink *newJsonLink(char *text, int start, int end)
{
struct jsonLink *newLink; 
AllocVar(newLink); 
newLink->text=cloneString(text); 
newLink->start=start; 
newLink->end=end;
return newLink; 
}

char **cdwValidQuery(char *fileId)
{
/* Look for id and fileId in cdwValidFile */ 
struct sqlConnection *conn = sqlConnect("cdw"); 
char query[1024]; 
sqlSafef(query, 1024, "select id,fileId,licensePlate from cdwValidFile where fileId=\'%s\'",fileId); 
struct sqlResult *result = sqlGetResult(conn,query); 
char **row, **output;//, *id=NULL, *fileId=NULL;
AllocArray(output, 3); 
while ((row = sqlNextRow(result)) != NULL)
    {
    output[0] = cloneString(row[0]);
    output[1] = cloneString(row[1]); 
    output[2] = cloneString(row[2]); 
    }
sqlDisconnect(&conn);
return output;
}

char **checkIn(char *id)
/* cdwStepIn  sql table, get the */ 
{
struct sqlConnection *conn = sqlConnect("cdw");
char **row, query[1024], **output;
AllocArray(output, 2);
sqlSafef(query, 1024, "select stepRunId,name from cdwStepIn where fileId=\'%s\'", id); // look for a link to the next node (an intermediate node)
struct sqlResult *result = sqlGetResult(conn,query); 
while ((row = sqlNextRow(result)) != NULL)
    {
    output[0] = cloneString(row[0]);
    output[1] = cloneString(row[1]); 
    }
sqlDisconnect(&conn);
return output; 
}

char **checkRun(char *stepRunId)
/* Look for name in cdwStepRun */ 
{
struct sqlConnection *conn = sqlConnect("cdw");
char **row, query[1024], **output; 
AllocArray(output, 2);
sqlSafef(query, 1024, "select stepDef, stepVersion from cdwStepRun where id=\'%s\'", stepRunId); // The intermediate node
struct sqlResult *result = sqlGetResult(conn,query); 
while ((row = sqlNextRow(result)) != NULL)
    {
    output[0] = cloneString(row[0]);
    output[1] = cloneString(row[1]); 
    }
sqlDisconnect(&conn);
return output; 
}

char **checkDef(char *stepDef)
/* Look for name in cdwStepDef */ 
{
struct sqlConnection *conn = sqlConnect("cdw");
char **row, query[1024], **output; 
AllocArray(output, 2);
sqlSafef(query, 1024, "select name,description from cdwStepDef where id=\'%s\'", stepDef); 
struct sqlResult *result = sqlGetResult(conn,query); 
while ((row = sqlNextRow(result)) != NULL)
    {
    output[0] = cloneString(row[0]);
    output[1] = cloneString(row[1]); 
    }
sqlDisconnect(&conn);
return output; 
}
struct sqlResult *checkOut(char *stepRunId)
{
/* Look for name and fileId in cdwStepOut */ 
struct sqlConnection *conn = sqlConnect("cdw");
char query[1024], **output; //, *name=NULL, *fileId=NULL;
AllocVar(output); 
sqlSafef(query, 1024, "select name,fileId from cdwStepOut where stepRunId=\'%s\'", stepRunId); // Links to the last node
struct sqlResult *result = sqlGetResult(conn,query); 
return result; 
}

char *checkValidFile(char *fileId)
{
/* Look for licensePlate in cdwValidFile */ 
/* This was all likely generated by Jim's autoSQL, its also likely his library functions are cleaner,
 * and more compact. Switch over as soon as you find them */ 
struct sqlConnection *conn = sqlConnect("cdw");
char **row, query[1024], *licensePlate; 
AllocVar(licensePlate); 
sqlSafef(query, 1024, "select licensePlate from cdwValidFile where fileID=\'%s\'",fileId);// look for a valid node 
struct sqlResult *result = sqlGetResult(conn,query); 
while ((row = sqlNextRow(result)) != NULL)
    {
    licensePlate = cloneString(row[0]); 
    }
sqlDisconnect(&conn);
return licensePlate; 
}



void printToJson(FILE *f, struct jsonNode *nodeList, struct jsonLink *linkList)
{
/* Print a list of jsonNodes and jsonLinks to go.js format. Will likely get things working here then jump ship to a more
 * free option */ 
struct jsonNode *iterN;
fprintf(f,"{ \"class\":\"go.GraphLinksModel\",\"linkFromPortIdProperty\":\"fromPort\",\"linkToPortIdProperty\": \"toPort\",\"nodeDataArray\":[\n");
for (iterN = nodeList; iterN->next !=NULL; iterN = iterN->next)
    {
    fprintf(f,"{\"text\":\"%s\",\"key\":\"%i\",\"loc\":\"%i %i\"}",iterN->text, iterN->key, iterN->xloc, iterN->yloc);
    if (iterN->next->next !=NULL) fprintf(f,",");
    fprintf(f,"\n"); 
    }
fprintf(f,"],\n\"linkDataArray\":[\n"); 
struct jsonLink *iterL; 
for (iterL = linkList; iterL->next !=NULL; iterL = iterL->next)
    {
    fprintf(f,"{\"from\":%i,\"to\":%i,\"fromPort\":\"B\", \"toPort\":\"T\", \"visible\":true, \"text\":\"%s\"}",iterL->start, iterL->end, iterL->text);
    if (iterL->next->next != NULL) fprintf(f,",");
    fprintf(f,"\n"); 
    }
fprintf(f,"]}\n"); 
}


void rLookForNodes(char *startQuery, FILE *outputFile, struct jsonNode *nodeList, struct jsonLink *linkList)
{
char **vQ = cdwValidQuery(startQuery);
//Check the cdwStepIn table, grab the stepRunId and name. 
struct jsonNode *startNode = newJsonNode("in depth testing", gKey, false, gX, gY);// vQ[2]
slAddHead(&nodeList, startNode);
++gKey;

char **cI = checkIn(vQ[1]);
struct jsonLink *firstLink = newJsonLink(cI[1], gKey-1, gKey);
slAddHead(&linkList, firstLink);

//From cdwStepIn we take the stepRunId and map it to cdwStepRun. We take stepDef and stepVersion.  
char **cR = checkRun(cI[0]); 

// StepDef from cdwStepRun maps to cdwStepDef.  Grab name and description from cdwStepDef. 
char **cD = checkDef(cR[0]);
struct jsonNode *middleNode = newJsonNode(cD[2], gKey, false, gX, gY);
slAddHead(&nodeList, middleNode);
++gKey;
// There are often multiple output files, hence the embedded code rather than a function. 
struct sqlConnection *conn = sqlConnect("cdw");
char query[1024], **row;
sqlSafef(query, 1024, "select name,fileId from cdwStepOut where stepRunId=\'%s\'", cI[0]);
struct sqlResult *result = sqlGetResult(conn,query); 
while ((row = sqlNextRow(result)) != NULL)
    {
    //char **round2 = cdwValidQuery(row[1]);
    struct jsonLink *secondLink = newJsonLink("testing", gKey-1, gKey);
    slAddHead(&linkList, secondLink);
    struct jsonNode *endNode = newJsonNode("testing", gKey, false, gX, gY);
    slAddHead(&nodeList, endNode);
    ++gKey;
    char **possibleNext = checkIn(row[1]); 
    // Recurse if the output is in the set of possible inputs
    if (possibleNext==NULL) rLookForNodes(row[1], outputFile, nodeList, linkList);  
    }
printToJson(outputFile, nodeList, linkList);
}

void sqlToTxt(char *startQuery, char *outputFile)
/* sqlToTxt - A program that runs through SQL tables and generates history flow chart information. */
{
/*
struct jsonNode *nodeList; 
struct jsonLink *linkList; 
char *newFileId=NULL;
int nodeKey = 0, yloc = 0; 
char *id=NULL, *fileId=NULL, *licensePlateQuery=startQuery;
FILE *f = mustOpen(outputFile,"w"); 
*/
/* I see two options, recursion and a while loop. The while loop could be some thing along the lines of 
 *	    while (checkValid(someglobal)!NULL)
 *		update some global
 * The recurssion is less easily explained. 
*/
// Old comments below
struct jsonNode *nodeList = NULL; 
AllocVar(nodeList);
struct jsonLink *linkList = NULL;  
AllocVar(linkList);
//int nodeKey = 0, yLoc = 0, xLoc = 0; 
FILE *f = mustOpen(outputFile,"w"); 
rLookForNodes(startQuery, f, nodeList, linkList); 

// New gameplan. Recursion.  A recursive function that traverses the loop (generating 3 nodes and 2 links
// minimum) one time. Right before recursion check if the new output/input files (depending on direction) 
// are in the validFiles table. If they are recurse, otherwise stop. 


}

int main(int argc, char *argv[])
/* Process command line. */
{
optionInit(&argc, argv, options);
if (argc != 3)
    usage();
sqlToTxt(argv[1], argv[2]);
return 0;
}
