/* pscReps - analyse repeats and generate list of best alignments
 * from a genome wide, sorted by mRNA .psc alignment file.
 */
#include "common.h"
#include "linefile.h"
#include "hash.h"
#include "../pscSort/as_psc.h"

void usage()
/* Print usage instructions and exit. */
{
errAbort(
    "pscReps - analyse repeats and generate genome wide best\n"
    "alignments from a sorted set of local alignments\n"
    "usage:\n"
    "    pscReps in.psc out.psc out.psr\n"
    "where in.psc is an alignment file generated by psCluster and\n"
    "sorted by pscSort, out.psc is the best alignment output\n"
    "and out.psr contains repeat info\n");
}

int calcMilliScore(struct psc *psc)
/* Figure out percentage score. */
{
int milliScore = psc->score * 1000 /(psc->qEnd - psc->qStart);
return milliScore;
}


boolean closeToTop(struct psc *psc, int *scoreTrack)
/* Returns TRUE if psc is near the top scorer for at least 20 bases. */
{
int milliScore = calcMilliScore(psc);
int threshold = round(milliScore * 1.01);
int i, blockIx;
int start, size, end;
int topCount = 0;

for (blockIx = 0; blockIx < psc->blockCount; ++blockIx)
    {
    start = psc->qBlockStarts[blockIx];
    size = psc->blockSizes[blockIx];
    end = start+size;
    for (i=start; i<end; ++i)
	{
	if (scoreTrack[i] <= threshold)
	    {
	    if (++topCount >= 20)
		return TRUE;
	    }
	}
    }
return FALSE;
}

void doOneAcc(char *acc, struct psc *pscList, FILE *bestFile, FILE *repFile)
/* Process alignments of one piece of mRNA. */
{
struct psc *psc;
int qSize;
int *repTrack;
int *scoreTrack;
int milliScore;
int pscIx;
int goodAliCount = 0;
int bestAliCount = 0;

int scoreThreshold = 850;

if (pscList == NULL)
    return;
qSize = pscList->qSize;
AllocArray(repTrack, qSize+1);
AllocArray(scoreTrack, qSize);

for (psc = pscList; psc != NULL; psc = psc->next)
    {
    int blockIx;
    milliScore = calcMilliScore(psc);
    if (milliScore >= scoreThreshold)
	{
	++goodAliCount;
	for (blockIx = 0; blockIx < psc->blockCount; ++blockIx)
	    {
	    int start = psc->qBlockStarts[blockIx];
	    int size = psc->blockSizes[blockIx];
	    int end = start+size;
	    int i;
	    for (i=start; i<end; ++i)
		{
		repTrack[i] += 1;
		if (milliScore > scoreTrack[i])
		    scoreTrack[i] = milliScore;
		}
	    }
	}
    }
/* Print out any alignments that are within 2% of top score. */
for (psc = pscList; psc != NULL; psc = psc->next)
    {
    if (calcMilliScore(psc) >= scoreThreshold && closeToTop(psc, scoreTrack))
	{
	pscTabOut(psc, bestFile);
	++bestAliCount;
	}
    }


/* Print out run-length-encoded repeat info.  */
    {
    int runVal = repTrack[0];
    int curVal;
    int runSize = 1;
    int runStart = 0;
    int packetCount = 0;
    int *packetSize;
    int *packetVal;
    int i;

    AllocArray(packetSize, qSize);
    AllocArray(packetVal, qSize);

    repTrack[qSize] = -1;	/* Sentinal value to simplify RLC loop. */
    fprintf(repFile, "%s\t%d\t%d\t", acc, bestAliCount, goodAliCount);

    for (i=1; i<=qSize; ++i)
	{
	if ((curVal = repTrack[i]) != runVal)
	    {
	    packetSize[packetCount] = runSize;
	    packetVal[packetCount] = runVal;
	    ++packetCount;
	    runSize = 1;
	    runVal = curVal;
	    }
	else
	    {
	    ++runSize;
	    }
	}
    fprintf(repFile, "%d\t", packetCount);
    for (i=0; i<packetCount; ++i)
	fprintf(repFile, "%d,", packetSize[i]);
    fprintf(repFile, "\t");
    for (i=0; i<packetCount; ++i)
	fprintf(repFile, "%d,", packetVal[i]);
    fprintf(repFile, "\n");

    freeMem(packetSize);
    freeMem(packetVal);
    }

freeMem(repTrack);
freeMem(scoreTrack);
}

void pscReps(char *inName, char *bestAliName, char *repName)
/* Analyse inName and put best alignments for eacmRNA in estAliName.
 * Put repeat info in repName. */
{
struct lineFile *in = lineFileOpen(inName, TRUE);
FILE *bestFile = mustOpen(bestAliName, "w");
FILE *repFile = mustOpen(repName, "w");
int lineSize;
char *line;
char *words[16];
int wordCount;
boolean gotZzz = FALSE;
struct psc *pscList = NULL, *psc;
char lastAcc[256];
int aliCount = 0;

printf("Processing %s to %s and %s\n", inName, bestAliName, repName);
strcpy(lastAcc, "");
while (lineFileNext(in, &line, &lineSize))
    {
    if ((++aliCount & 0x1ffff) == 0)
        {
	printf(".");
	fflush(stdout);
	}
    wordCount = chopTabs(line, words);
    if (wordCount == 1 && sameWord(words[0], "ZZZ"))
	{
	gotZzz = TRUE;
	break;
	}
    if (wordCount != 13)
	errAbort("Bad line %d of %s\n", in->lineIx, in->fileName);
    psc = pscLoad(words);
    if (!sameString(lastAcc, psc->qAcc))
	{
	doOneAcc(lastAcc, pscList, bestFile, repFile);
	pscFreeList(&pscList);
	strcpy(lastAcc, psc->qAcc);
	}
    slAddHead(&pscList, psc);
    }
doOneAcc(lastAcc, pscList, bestFile, repFile);
pscFreeList(&pscList);
if (!gotZzz)
    warn("%s appears to be truncated\n", inName);
fprintf(bestFile, "ZZZ\n");
lineFileClose(&in);
fclose(bestFile);
fclose(repFile);
printf("Processed %d alignments\n", aliCount);
}

int main(int argc, char *argv[])
/* Process command line. */
{
if (argc != 4)
    usage();
pscReps(argv[1], argv[2], argv[3]);
return 0;
}
