# for emacs: -*- mode: sh; -*-

# This file describes how we made the browser database on
# NCBI build 38 (December 2013 freeze) aka:
#	GRCh38 - Genome Reference Consortium Human Reference 38
#	Assembly Accession: GCA_000001405.2

#############################################################################
## Download sequence - DONE - 2013-12-24
    mkdir /hive/data/genomes/hg38
    mkdir /hive/data/genomes/hg38/genbank
    cd /hive/data/genomes/hg38/genbank
    time rsync -a -P rsync://ftp.ncbi.nlm.nih.gov/genbank/genomes/Eukaryotes/vertebrates_mammals/Homo_sapiens/GRCh38/ ./
# sent 19643 bytes  received 4914689807 bytes  4490369.53 bytes/sec
# total size is 4914019581  speedup is 1.00

# real    18m14.497s

#############################################################################
## convert to UCSC names - DONE - 2013-12-24
#  with this release, NCBI has adopted a naming convention that is similar
#  to UCSC.  The delivered sequence with these names can be found in:
#  /hive/data/genomes/hg38/genbank/seqs_for_alignment_pipelines/
#
#  The following scripts reproduce this naming scheme from the separate
#  files in the release
#
    mkdir /hive/data/genomes/hg38/ucsc
    cat << '_EOF_' > ucscCompositeAgp.pl
#!/bin/env perl

use strict;
use warnings;

my %accToChr;

open (FH, "<../genbank/Primary_Assembly/assembled_chromosomes/chr2acc") or
        die "can not read Primary_Assembly/assembled_chromosomes/chr2acc";
while (my $line = <FH>) {
    next if ($line =~ m/^#/);
    chomp $line;
    my ($chrN, $acc) = split('\s+', $line);
    $accToChr{$acc} = $chrN;
}
close (FH);

foreach my $acc (keys %accToChr) {
    my $chrN =  $accToChr{$acc};
    print "$acc $accToChr{$acc}\n";
    open (FH, "zcat ../genbank/Primary_Assembly/assembled_chromosomes/AGP/chr${chrN}.comp.agp.gz|") or die "can not read chr${chrN}.comp.agp.gz";
    open (UC, ">chr${chrN}.agp") or die "can not write to chr${chrN}.agp";
    while (my $line = <FH>) {
        if ($line =~ m/^#/) {
            print UC $line;
        } else {
            $line =~ s/^$acc/chr${chrN}/;
            print UC $line;
        }
    }
    close (FH);
    close (UC);
    open (FH, "zcat ../genbank/Primary_Assembly/assembled_chromosomes/FASTA/chr${chrN}.fa.gz|") or die "can not read chr${chrN}.fa.gz";
    open (UC, ">chr${chrN}.fa") or die "can not write to chr${chrN}.fa";
    while (my $line = <FH>) {
        if ($line =~ m/^>/) {
            printf UC ">chr${chrN}\n";
        } else {
            print UC $line;
        }
    }
    close (FH);
    close (UC);
}
'_EOF_'
    # << happy emacs
    chmod +x ucscCompositeAgp.pl

    cat << '_EOF_' > unlocalized.pl
#!/bin/env perl

use strict;
use warnings;

my %accToChr;
my %chrNames;

open (FH, "<../genbank/Primary_Assembly/unlocalized_scaffolds/unlocalized.chr2scaf") or
        die "can not read Primary_Assembly/unlocalized_scaffolds/unlocalized.chr2scaf";
while (my $line = <FH>) {
    next if ($line =~ m/^#/);
    chomp $line;
    my ($chrN, $acc) = split('\s+', $line);
    $acc =~ s/\./v/;
    $accToChr{$acc} = $chrN;
    $chrNames{$chrN} += 1;
}
close (FH);

foreach my $chrN (keys %chrNames) {
    my $agpFile =  "../genbank/Primary_Assembly/unlocalized_scaffolds/AGP/chr$chrN.unlocalized.scaf.agp.gz";
    my $fastaFile =  "../genbank/Primary_Assembly/unlocalized_scaffolds/FASTA/chr$chrN.unlocalized.scaf.fa.gz";
    open (FH, "zcat $agpFile|") or die "can not read $agpFile";
    open (UC, ">chr${chrN}_random.agp") or die "can not write to chr${chrN}_random.agp";
    while (my $line = <FH>) {
        if ($line =~ m/^#/) {
            print UC $line;
        } else {
            chomp $line;
            my (@a) = split('\t', $line);
            my $acc = $a[0];
            $acc =~ s/\./v/;
            die "ERROR: chrN $chrN not correct for $acc"
                if ($accToChr{$acc} ne $chrN);
            my $ucscName = "chr${chrN}_${acc}_random";
            printf UC "%s", $ucscName;
            for (my $i = 1; $i < scalar(@a); ++$i) {
                printf UC "\t%s", $a[$i];
            }
            printf UC "\n";
        }
    }
    close (FH);
    close (UC);
    printf "chr%s\n", $chrN;
    open (FH, "zcat $fastaFile|") or die "can not read $fastaFile";
    open (UC, ">chr${chrN}_random.fa") or die "can not write to chr${chrN}_random.fa";
    while (my $line = <FH>) {
        if ($line =~ m/^>/) {
            chomp $line;
            my $acc = $line;
            $acc =~ s/.*gb\|//;
            $acc =~ s/. Homo.*//;
            $acc =~ s/\./v/;
            die "ERROR: chrN $chrN not correct for $acc"
                if ($accToChr{$acc} ne $chrN);
            my $ucscName = "chr${chrN}_${acc}_random";
            printf UC ">$ucscName\n";
        } else {
            print UC $line;
        }
    }
    close (FH);
    close (UC);
}
'_EOF_'
    # << happy emacs
    chmod +x unlocalized.pl

    cat << '_EOF_' > unplaced.pl
#!/bin/env perl

use strict;
use warnings;

my $agpFile =  "../genbank/Primary_Assembly/unplaced_scaffolds/AGP/unplaced.scaf.agp.gz";
my $fastaFile =  "../genbank/Primary_Assembly/unplaced_scaffolds/FASTA/unplaced.scaf.fa.gz";
open (FH, "zcat $agpFile|") or die "can not read $agpFile";
open (UC, ">chrUn.agp") or die "can not write to chrUn.agp";
while (my $line = <FH>) {
    if ($line =~ m/^#/) {
        print UC $line;
    } else {
        $line =~ s/\./v/;
        printf UC "chrUn_%s", $line;
    }
}
close (FH);
close (UC);

open (FH, "zcat $fastaFile|") or die "can not read $fastaFile";
open (UC, ">chrUn.fa") or die "can not write to chrUn.fa";
while (my $line = <FH>) {
    if ($line =~ m/^>/) {
        chomp $line;
        $line =~ s/.*gb\|//;
        $line =~ s/. Homo.*//;
        $line =~ s/\./v/;
        printf UC ">chrUn_$line\n";
    } else {
        print UC $line;
    }
}
close (FH);
close (UC);
'_EOF_'
    # << happy emacs
    chmod +x unplaced.pl

    cat << '_EOF_' > altSequence.pl
#!/usr/bin/env perl

use strict;
use warnings;
use File::Basename;

open (AG, ">chrAlt.agp") or die "can not write to chrAlt.agp";
open (FA, ">chrAlt.fa") or die "can not write to chrAlt.fa";
open (FH, "find ../genbank/ALT* -type f | grep alt_scaffold_placement.txt|") or die "can not find alt_scaffold_placement.txt files";
while (my $file = <FH>) {
  chomp $file;
  my $dirName = dirname($file);
  my $agpFile = "$dirName/AGP/alt.scaf.agp.gz";
  my $fastaFile = "$dirName/FASTA/alt.scaf.fa.gz";
  # key is genbank acc name, value is UCSC chr name
  my %nameDelta;
#  printf STDERR "# %s\n", $file;
  open (AL, "<$file") or die "can not read $file";
  while (my $line = <AL>) {
     next if ($line =~ m/^#/);
     chomp $line;
     my ($alt_asm_name, $prim_asm_name, $alt_scaf_name, $alt_scaf_acc,
          $parent_type, $parent_name, $parent_acc, $region_name, $ori,
           $alt_scaf_start, $alt_scaf_stop, $parent_start, $parent_stop,
            $alt_start_tail, $alt_stop_tail) = split('\t', $line);
     my $ucscAcc = $alt_scaf_acc;
     $ucscAcc =~ s/\./v/;
     my $ucscName = sprintf("chr%s_%s_alt", $parent_name, $ucscAcc);
     printf "%s %s\n", $alt_scaf_acc, $ucscName;
     if (exists ($nameDelta{$alt_scaf_acc})) {
         die "duplicate name incorrect ? $alt_scaf_acc $nameDelta{$alt_scaf_acc} ne $ucscName" if ($nameDelta{$alt_scaf_acc} ne $ucscName);
     } else {
         $nameDelta{$alt_scaf_acc} = $ucscName;
     }
  }
  close (AL);
  open (AL, "zcat $agpFile|") or die "can not read $agpFile";
  while (my $line = <AL>) {
     if ($line =~ m/^#/) {
       print AG "$line";
     } else {
       my ($acc, $rest) = split('\t', $line, 2);
       die "can not find ucsc name for $acc" if (!exists($nameDelta{$acc}));
       printf AG "%s\t%s", $nameDelta{$acc}, $rest;
     }
  }
  close (AL);
  open (AL, "zcat $fastaFile|") or die "can not read $fastaFile";
  while (my $line = <AL>) {
     chomp $line;
     if ($line =~ m/^>/) {
       $line =~ s/.*gb.//;
       $line =~ s/. Homo.*//;
       die "can not find ucsc name for $line" if (!exists($nameDelta{$line}));
       printf FA ">%s\n", $nameDelta{$line};
     } else {
       printf FA "%s\n", $line;
     }
  }
  close (AL);
}
close (FH);
close (AG);
close (FA);
'_EOF_'
    # << happy emacs
    chmod +x altSequence.pl

    ./ucscCompositeAgp.pl
    ./unlocalized.pl
    ./unplaced.pl
    ./altSequence.pl

    # temporarily verify the fasta and AGP are complete and compatible
    faToTwoBit chr*.fa hg38.test.2bit
    cat chr*.agp > hg38.agp
    checkAgpAndFa hg38.agp hg38.test.2bit 2>&1 | tail -1
# All AGP and FASTA entries agree - both files are valid

    rm -f hg38.agp hg38.test.2bit

    # comparing faCounts of this 2bit file and the sequences delivered
    # in genbank/seqs_for_alignment_pipelines/
    # result in the exact same sequence

#############################################################################
## initial db build - DONE - 2013-12-24 - Hiram

    cd /hive/data/genomes/hg38
    cat << '_EOF_' > hg38.config.ra
# Config parameters for makeGenomeDb.pl:
db hg38
scientificName Homo sapiens
commonName Human
assemblyDate Dec. 2013
assemblyLabel GRCh38 Genome Reference Consortium Human Reference 38 (GCA_000001405.2)
assemblyShortLabel GRCh38
orderKey 13
mitoAcc none
fastaFiles /hive/data/genomes/hg38/ucsc/chr*.fa
agpFiles /hive/data/genomes/hg38/ucsc/chr*.agp
# qualFiles /dev/null
dbDbSpeciesDir human
photoCreditURL http://www.cbse.ucsc.edu/
photoCreditName Graphic courtesy of CBSE
ncbiGenomeId 51
ncbiAssemblyId 883148
ncbiAssemblyName GRCh38
ncbiBioProject 31257
genBankAccessionID GCA_000001305.2
taxId   9606
'_EOF_'
    # << happy emacs

    # step wise to first verify AGP and Fasta files
    time makeGenomeDb.pl -stop=agp hg38.config.ra > agp.log 2>&1

    # looking good, continue:
    time makeGenomeDb.pl -continue=db hg38.config.ra > db.log 2>&1

    # add the files produced by the trackDb build to the source tree

#############################################################################
## RepeatMasker with CrossMatch - WORKING - 2013-12-24 - Hiram
    mkdir /hive/data/genomes/hg38/bed/repeatMaskerCM
    cd /hive/data/genomes/hg38/bed/repeatMaskerCM
    time doRepeatMasker.pl -stop=mask -bigClusterHub=ku \
       -workhorse=hgwdev -dbHost=hgwdev -buildDir=`pwd` hg38 > mask.log 2>&1

#############################################################################
## RepeatMasker with RM Blastn - WORKING - 2013-12-24 - Hiram
    mkdir /hive/data/genomes/hg38/bed/repeatMaskerCM
    cd /hive/data/genomes/hg38/bed/repeatMaskerCM
    time doRepeatMasker.pl -stop=mask -useRMBlastn -bigClusterHub=ku \
       -workhorse=hgwdev -dbHost=hgwdev -buildDir=`pwd` hg38 > mask.log 2>&1

#############################################################################
## RepeatMasker with HMMER - WORKING - 2013-12-24 - Hiram
    mkdir /hive/data/genomes/hg38/bed/repeatMaskerCM
    cd /hive/data/genomes/hg38/bed/repeatMaskerCM
    time doRepeatMasker.pl -stop=mask -useHMMER -bigClusterHub=ku \
       -workhorse=hgwdev -dbHost=hgwdev -buildDir=`pwd` hg38 > mask.log 2>&1

#############################################################################
## running TRF simple repeats - DONE - 2013-12-24 - Hiram
    # this procedure ran into much trouble on this release.  The new
    # repeat sequences in the centromeres caused trf to run indefinitely.
    # I tried different sizes of chunks, working down to 20 Mbase chunks.
    # Even still, some jobs would not complete.  Those broke down even
    # more, eventually to the smallest bit of 30 Kbase that needed to
    # run all the way down to 3,000 based chunks with 1,000 base overlaps.

    # this did not work:
    screen # use screen to manage this day-long job
    mkdir /hive/data/genomes/hg38/bed/simpleRepeat
    cd /hive/data/genomes/hg38/bed/simpleRepeat
    time doSimpleRepeat.pl -bigClusterHub=ku -workhorse=hgwdev \
	-smallClusterHub=ku -buildDir=`pwd` hg38 > do.log 2>&1

    # Instead, something like this:
    mkdir /hive/data/genomes/hg38/bed/simpleRepeat.2013-12-27/splitGap
    cd /hive/data/genomes/hg38/bed/simpleRepeat.2013-12-27/splitGap
    mkdir -p noGap

    twoBitToFa ../../../hg38.unmasked.2bit stdout \
       | faSplit -lift=noGap.lift gap stdin 5000000 noGap/hg38_
    # make sure nothing has gone missing:
    faCount noGap/*.fa > faCount.txt
    tail -1 faCount.txt
# total 3068387174 898285419 623727342 626335137 900967885  19071391 30979734
    # compared to the full sequence, same numbers for ACGT:
    twoBitToFa ../../../hg38.unmasked.2bit stdout | faCount stdin
# total 3209286105 898285419 623727342 626335137 900967885 159970322 30979743
    faToTwoBit noGap/*.fa hg38.nogap.2bit
    twoBitInfo hg38.nogap.2bit stdout | sort -k2,2nr > hg38.nogap.sizes


    mkdir /hive/data/genomes/hg38/bed/simpleRepeat.2013-12-27/run20M
    cd /hive/data/genomes/hg38/bed/simpleRepeat.2013-12-27/run20M
    rm -rf /hive/data/genomes/hg38/TrfPart20M
    /cluster/bin/scripts/simplePartition.pl \
/hive/data/genomes/hg38/bed/simpleRepeat.2013-12-27/splitGap/hg38.nogap.2bit \
   20000000 /hive/data/genomes/hg38/TrfPart20M
   rm -f /hive/data/genomes/hg38/bed/simpleRepeat.2013-12-27/TrfPart20M
   ln -s /hive/data/genomes/hg38/TrfPart20M \
      /hive/data/genomes/hg38/bed/simpleRepeat.2013-12-27/TrfPart20M
   ssh ku
   cd /hive/data/genomes/hg38/bed/simpleRepeat.2013-12-27/run20M
   gensub2 /hive/data/genomes/hg38/TrfPart20M/partitions.lst single gsub jobList
   para create jobList
   para push
   # 20 jobs would not complete:
# Completed: 143 of 163 jobs
# Jobs currently running: 20
# CPU time in finished jobs:      76994s    1283.24m    21.39h    0.89d  0.002 y
# IO & Wait Time:                  1095s      18.24m     0.30h    0.01d  0.000 y
# Time in running jobs:         1807279s   30121.32m   502.02h   20.92d  0.057 y
# Average job time:                 546s       9.10m     0.15h    0.01d
# Longest running job:            90422s    1507.03m    25.12h    1.05d
# Longest finished job:           43348s     722.47m    12.04h    0.50d
# Submission to last job:         43363s     722.72m    12.05h    0.50d
   # determine which are the last jobs as individual bits:
   para status | grep -v done | awk '{print $(NF-1),$NF}' | grep TrfRun \
     > not.done.list
   awk '{print $NF}' not.done.list | sed -e 's/.bed//' | while read F
do
   cat $F
done > seq.specs.not.done

   mkdir /hive/data/genomes/hg38/bed/simpleRepeat.2013-12-27/run20M/lastJobs
   cd /hive/data/genomes/hg38/bed/simpleRepeat.2013-12-27/run20M/lastJobs
   mkdir fasta
   for seqSpec in `cat ../seq.specs.not.done`
do
  fName=`echo $seqSpec | sed -e 's/.*://'`
  echo $fName
  twoBitToFa $seqSpec fasta/$fName.fa
done
  ls -1S `pwd`/fasta > part.list
  cat << '_EOF_' > template
#LOOP
./runTrf {check in line+ $(path1)}  {check out line bed/$(root1).bed}
#ENDLOOP
'_EOF_'
  # << happy emacs

  cat << '_EOF_' > runTrf
#!/bin/bash
set -beEu -o pipefail
export path1=$1
export inputFN=`basename $1`
export outpath=$2
export outputFN=`basename $2`
mkdir -p /dev/shm/$outputFN
cp -p $path1 /dev/shm/$outputFN
cd /dev/shm/$outputFN
/cluster/bin/x86_64/trfBig -trf=/cluster/bin/x86_64/trf \
      $inputFN /dev/null -bedAt=$outputFN -tempDir=/dev/shm
cd /hive/data/genomes/hg38/bed/simpleRepeat.2013-12-27/run20M/lastJobs
rm -f $outpath
cp -p /dev/shm/$outputFN/$outputFN $outpath
rm -fr /dev/shm/$outputFN/*
rmdir --ignore-fail-on-non-empty /dev/shm/$outputFN
'_EOF_'
  # << happy emacs
  chmod +x runTrf

  gensub2 part.list single template jobList
  para create jobList
  para push
  # not all of these jobs will finish either:
# Completed: 85 of 106 jobs
# Jobs currently running: 21
# CPU time in finished jobs:      58076s     967.93m    16.13h    0.67d  0.002 y
# IO & Wait Time:                   828s      13.81m     0.23h    0.01d  0.000 y
# Time in running jobs:         1988997s   33149.95m   552.50h   23.02d  0.063 y
# Average job time:                 693s      11.55m     0.19h    0.01d
# Longest running job:            94730s    1578.83m    26.31h    1.10d
# Longest finished job:           34216s     570.27m     9.50h    0.40d
# Submission to last job:         34342s     572.37m     9.54h    0.40d

  # can use what we have here:
  liftUp result.bed ../../splitGap/noGap.lift error bed/*.bed
  # find jobs not done
  para status | grep -v done | awk '{print $(NF-1),$NF}' | grep TrfRun \
     > not.done.list
  # splitting up those last jobs:
  mkdir /hive/data/genomes/hg38/bed/simpleRepeat.2013-12-27/run20M/splitBits
  cd /hive/data/genomes/hg38/bed/simpleRepeat.2013-12-27/run20M/splitBits
  mkdir noGap
  awk '{print $2}' ../lastJobs/not.done.list | while read F
do
  cp -p $F ./noGap/
done

  # split into 1,000,000 chunks with 10,000 overlap:
  mkdir -p 1M_10K

for F in noGap/*.fa
do
  B=`basename $F | sed -e 's/.fa//'`
  echo "faSplit -lift=$B.lift -extra=10000 size $F 1000000 1M_10K/$B_"
  faSplit -lift=$B.lift -extra=10000 size $F 1000000 1M_10K/${B}_
done

  ls -1S `pwd`/1M_10K/*.fa > part.list
  cat << '_EOF_' > runTrf
#!/bin/bash
set -beEu -o pipefail
export path1=$1
export inputFN=`basename $1`
export outpath=$2
export outputFN=`basename $2`
mkdir -p /dev/shm/$outputFN
cp -p $path1 /dev/shm/$outputFN
cd /dev/shm/$outputFN
/cluster/bin/x86_64/trfBig -trf=/cluster/bin/x86_64/trf \
      $inputFN /dev/null -bedAt=$outputFN -tempDir=/dev/shm
cd /hive/data/genomes/hg38/bed/simpleRepeat.2013-12-27/run20M/splitBits
rm -f $outpath
cp -p /dev/shm/$outputFN/$outputFN $outpath
rm -fr /dev/shm/$outputFN/*
rmdir --ignore-fail-on-non-empty /dev/shm/$outputFN
'_EOF_'
  # << happy emacs

  cat << '_EOF_' > template
#LOOP
./runTrf {check in line+ $(path1)}  {check out line bed/$(root1).bed}
#ENDLOOP
'_EOF_'
  # << happy emacs

  gensub2 part.list single template jobList
  para create jobList
  para push
  # not all of these jobs will complete either:
# Completed: 53 of 96 jobs
# CPU time in finished jobs:     212403s    3540.05m    59.00h    2.46d  0.007 y
# IO & Wait Time:                  1851s      30.85m     0.51h    0.02d  0.000 y
# Average job time:                4043s      67.38m     1.12h    0.05d
# Longest finished job:           68726s    1145.43m    19.09h    0.80d
# Submission to last job:         68890s    1148.17m    19.14h    0.80d
  # use what results we have here:
  cat *.lift  | liftUp parts.bed stdin error bed/*.bed
  liftUp -type=.bed stdout ../../splitGap/noGap.lift error parts.bed \
    | sort -u | sort -k1,1 -k2,2n > hg38.result.bed

  para status | grep -v -w done | awk '{print $(NF-1)}' > will.not.finish.txt

  # split those last bits:
  mkdir /hive/data/genomes/hg38/bed/simpleRepeat.2013-12-27/run20M/splitSplitBits
  cd /hive/data/genomes/hg38/bed/simpleRepeat.2013-12-27/run20M/splitSplitBits
  mkdir splitBits
  cat ../splitBits/will.not.finish.txt | while read F
do
  cp -p $F splitBits
done

  #  100K chunks with 10K overlap
  mkdir -p 100K_10K

for F in splitBits/*.fa
do
  B=`basename $F | sed -e 's/.fa//'`
  echo "faSplit -lift=$B.lift -extra=10000 size $F 1000000 1M_10K/$B_"
  faSplit -lift=$B.lift -extra=10000 size $F 100000 100K_10K/${B}_
done

############################################################################
 # WINDOWMASKER - DONE - 2013-12-24 - Hiram
    mkdir /hive/data/genomes/hg38/bed/windowMasker
    cd /hive/data/genomes/hg38/bed/windowMasker
    time nice -n +19 doWindowMasker.pl -buildDir=`pwd` -workhorse=hgwdev \
	-dbHost=hgwdev hg38 > do.log 2>&1 &

############################################################################
# Verify all gaps are marked - DONE - 2013-12-24 - Hiram
    mkdir /hive/data/genomes/hg38/bed/gap
    cd /hive/data/genomes/hg38/bed/gap
    time nice -n +19 findMotif -motif=gattaca -verbose=4 \
	-strand=+ ../../hg38.unmasked.2bit > findMotif.txt 2>&1
    #	real    0m28.634s
    grep "^#GAP " findMotif.txt | sed -e "s/^#GAP //" > allGaps.bed
    featureBits hg38 -not gap -bed=notGap.bed
    #	3049335806 bases of 3049335806 (100.000%) in intersection
    time featureBits hg38 allGaps.bed notGap.bed -bed=new.gaps.bed
    #   20023 bases of 3049335806 (0.001%) in intersection
    # real    0m20.427s
    # this indicates that 20,023 bases are not marked as N's
    # with this element size profile:
    awk '{print $3-$2}' new.gaps.bed | ave stdin
# Q1 1.000000
# median 1.000000
# Q3 100.000000
# average 44.894619
# min 1.000000
# max 1000.000000
# count 446
# total 20023.000000
# standard deviation 81.743447

    # the four largest ones:
# chr2         32916625        32917625        chr2.7
# chr2         32867130        32868130        chr2.6
# chr20        36314371        36314719        chr20.36
# chr12       123443533       123443733        chr12.10

#########################################################################
# cytoBandIdeo - (DONE - 2013-12-26 - Hiram)
    mkdir /hive/data/genomes/hg38/bed/cytoBand
    cd /hive/data/genomes/hg38/bed/cytoBand
    makeCytoBandIdeo.csh hg38

##########################################################################
# hg19 <-> hg38 difference tracks (WORKING - 2013-12-28 - Hiram)
    mkdir /hive/data/genomes/hg19/bed/liftOverHg38
    cd /hive/data/genomes/hg19/bed/liftOverHg38

    #	not needed, but interesting, collect all the fragment
    #	definitions from the gold tables:
    hgsql -N -e "select frag,fragStart,fragEnd,strand from gold;" hg19 \
        | sort > hg19.gold.frags.tab

    hgsql -N -e "select frag,fragStart,fragEnd,strand from gold;" hg38 \
        | sort > hg38.gold.frags.tab

    # construct common and difference listings
    comm -12 hg19.gold.frags.tab hg38.gold.frags.tab \
	> identical.hg19.hg38.frags.tab
    comm -23 hg19.gold.frags.tab hg38.gold.frags.tab \
	> unique.hg19Only.frags.tab
    comm -13 hg19.gold.frags.tab hg38.gold.frags.tab \
	> unique.hg38Only.frags.tab

    # better yet, get full information about each fragment
    hgsql -N -e "select chrom,chromStart,chromEnd,ix,type,frag,fragStart,fragEnd,strand from gold;" hg19 \
        | sort -k6 > hg19.gold.tab

    hgsql -N -e "select chrom,chromStart,chromEnd,ix,type,frag,fragStart,fragEnd,strand from gold;" hg38 \
        | sort -k6 > hg38.gold.tab

    # construct a single key for each fragment for joining.
    # the key is frag,fragStart,fragEnd,strand
    awk '{printf "%s,%d,%d,%s\t%s\t%s\t%s\t%d\t%d\t%d\t%s\n",
	$6,$7,$8,$9,$6,$9,$1,$2,$3,$4,$5}' hg19.gold.tab | sort \
	> hg19.fragKey.tab
    awk '{printf "%s,%d,%d,%s\t%s\t%s\t%s\t%d\t%d\t%d\t%s\n",
	$6,$7,$8,$9,$6,$9,$1,$2,$3,$4,$5}' hg38.gold.tab | sort \
	> hg38.fragKey.tab

    # now, by joining those keys, we can get exact identicals, and
    # the only-in listings as bed files to load as tracks:
    join hg19.fragKey.tab hg38.fragKey.tab \
	| awk '{printf "%s\t%d\t%d\t%s\t1000\t%s\t%d\t%d\t0,0,128\n", $4,$5,$6,$2,$3,$5,$6}' \
        | sort -k1,1 -k2,2n > hg19.hg38.identical.bed

    join hg19.fragKey.tab hg38.fragKey.tab \
	| awk '{printf "%s\t%d\t%d\t%s\t1000\t%s\t%d\t%d\t0,0,128\n", $11,$12,$13,$9,$10,$12,$13}' \
        | sort -k1,1 -k2,2n > hg38.hg19.identical.bed

    join -v 1 hg19.fragKey.tab hg38.fragKey.tab \
	| awk '{printf "%s\t%d\t%d\t%s\t0\t%s\n", $4,$5,$6,$2,$3}' \
        | sort -k1,1 -k2,2n > hg19.only.bed

    join -v 2 hg19.fragKey.tab hg38.fragKey.tab \
	| awk '{printf "%s\t%d\t%d\t%s\t0\t%s\n", $4,$5,$6,$2,$3}' \
        | sort -k1,1 -k2,2n > hg38.only.bed

    hgLoadBed hg19 hg38ContigDiff hg19.only.bed
    hgLoadBed hg38 hg19ContigDiff hg38.only.bed

    wc -l hg??.only.bed
    #  6097 hg19.only.bed
    #  23632 hg38.only.bed

    # this leaves the outstanding question of "why" they might be in
    #	the only-in listings.  Some contigs may be different versions,
    #   sometimes different sections of the same contig are used,
    #	and contigs are dropped from hg19 to hg38, or new contigs added
    #	to hg38 to fill in gaps from hg19
    # Let's see if we can measure some of this:
    awk '{print $4}' hg19.only.bed | sort -u > hg19.only.ids.list
    awk '{print $4}' hg38.only.bed | sort -u > hg38.only.ids.list

    # Looks like 5405 idential contigs with different parts used:
    comm -12 hg19.only.ids.list hg38.only.ids.list > differentPortions.list
    wc -l differentPortions.list
    # 5405

    # and perhaps 63 = 5468-5405 of different versions of same contig:
    sed -e "s/\.[0-9]*$//" hg19.only.ids.list | sort -u \
	> hg19.noVersions.ids.list
    sed -e "s/\.[0-9]*$//" hg38.only.ids.list | sort -u \
	> hg38.noVersions.ids.list
    comm -12 hg19.noVersions.ids.list hg38.noVersions.ids.list | wc -l
    #	5468
    sed -e "s/\.[0-9]*$//" differentPortions.list | sort -u \
	> differentPortions.noVersions.list
    comm -12 hg19.noVersions.ids.list hg38.noVersions.ids.list | sort -u \
	> noVersions.common.list
    # indeed, 63 contigs of different versions:
    comm -23 noVersions.common.list differentPortions.noVersions.list \
	| sort -u > differentVersions.list
    wc -l differentVersions.list
    #	63

    # dividing up these items:
    cat << '_EOF_' > identifyPortions.pl
#!/usr/bin/env perl

use strict;
use warnings;

my %differentVersions;
my %differentPortions;

open (FH, "<differentVersions.list" ) or
	die "can not read differentVersions.list";
while (my $line = <FH>) {
    chomp $line;
    $differentVersions{$line} = 1;
}
close (FH);

open (FH, "differentPortions.list" ) or
	die "can not read differentPortions.list";
while (my $line = <FH>) {
    chomp $line;
    $differentPortions{$line} = 1;
}
close (FH);

my %hg19Done;
open (DP, ">hg19.differentPortions.bed") or die "can not write to hg19.differentPortions.bed";
open (DV, ">hg19.differentVersions.bed") or die "can not write to hg19.differentVersions.bed";
open (FH, "<hg19.only.bed" ) or die "can not read hg19.only.bed";
while (my $line = <FH>) {
    chomp $line;
    my ($chr, $start, $end, $acc, $score, $strand) = split('\s+', $line);
    # assume done while $acc is still complete
    $hg19Done{$acc} = 1;
    if (exists($differentPortions{$acc})) {
	printf DP "%s\n", $line;
    } else {
	my $trimAcc = $acc;
	$trimAcc =~ s/\.[0-9]+$//;
	if (exists($differentVersions{$trimAcc})) {
	    printf DV "%s\n", $line;
	} else {
            # this one does not match
	    $hg19Done{$acc} = 0;
	}
    }
}
close (FH);
close (DV);
close (DP);
open (DR, ">hg19.dropped.bed") or die "can not write to hg19.dropped.bed";
open (FH, "<hg19.only.bed" ) or die "can not read hg19.only.bed";
while (my $line = <FH>) {
    chomp $line;
    my ($chr, $start, $end, $acc, $score, $strand) = split('\s+', $line);
    if (0 == $hg19Done{$acc}) {
	printf DR "%s\n", $line;
    }
}
close (FH);
close (DR);

my %hg38Done;
open (DP, ">hg38.differentPortions.bed") or die "can not write to hg38.differentPortions.bed";
open (DV, ">hg38.differentVersions.bed") or die "can not write to hg38.differentVersions.bed";
open (FH, "<hg38.only.bed" ) or die "can not read hg38.only.bed";
while (my $line = <FH>) {
    chomp $line;
    my ($chr, $start, $end, $acc, $score, $strand) = split('\s+', $line);
    # assume done while $acc is still complete
    $hg38Done{$acc} = 1;
    if (exists($differentPortions{$acc})) {
	printf DP "%s\n", $line;
    } else {
	my $trimAcc = $acc;
	$trimAcc =~ s/\.[0-9]+$//;
	if (exists($differentVersions{$trimAcc})) {
	    printf DV "%s\n", $line;
	} else {
            # this one does not match
	    $hg38Done{$acc} = 0;
	}
    }
}
close (FH);
close (DV);
close (DP);
open (DR, ">hg38.newTo19.bed") or die "can not write to hg38.newTo19.bed";
open (FH, "<hg38.only.bed" ) or die "can not read hg38.only.bed";
while (my $line = <FH>) {
    chomp $line;
    my ($chr, $start, $end, $acc, $score, $strand) = split('\s+', $line);
    if (0 == $hg38Done{$acc}) {
	printf DR "%s\n", $line;
    }
}
close (FH);
close (DR);
'_EOF_'
    # << happy emacs
    chmod +x identifyPortions.pl
    ./identifyPortions.pl
    # make sure nothing was lost
    sort hg19.differentVersions.bed hg19.differentPortions.bed \
	hg19.dropped.bed  | sum
    #	43711   233
    sort hg19.only.bed | sum
    #	43711   233
    sort hg38.differentVersions.bed hg38.differentPortions.bed \
	hg38.newTo19.bed | sum
    #	00502   911
    sort hg38.only.bed | sum
    #	00502   911

    sort -k1,1 -k2,2n hg38.differentVersions.bed hg38.differentPortions.bed \
	hg38.newTo19.bed > hg38.itemRgb.bed
    sort -k1,1 -k2,2n hg19.differentVersions.bed hg19.differentPortions.bed \
	hg19.dropped.bed > hg19.itemRgb.bed

    hgLoadBed hg19 hg19ContigDiff hg19.itemRgb.bed
    # if you wanted to load the identicals in this track too:
    sort -k1,1 -k2,2n hg38.hg19.identical.bed hg38.itemRgb.bed \
       | hgLoadBed hg38 hg38ContigDiff stdin
    # but we don't, we deliver only the differences
    hgLoadBed hg38 hg38ContigDiff hg38.itemRgb.bed

#########################################################################
# construct ooc file to be used in blat operations
#                      DONE - 2012-12-30 - Hiram
# can be done on unmasked sequence the same result as masked:
    cd /hive/data/genomes/hg38
    time blat hg38.unmasked.2bit /dev/null /dev/null \
       -tileSize=11 -makeOoc=jkStuff/hg38.11.ooc -repMatch=1024

    # just to see what is going on, since all gaps here are almost all
    #	exactly 100 bases, they aren't really "non-bridged", not really.
    gapToLift -minGap=100 -bedFile=jkStuff/nonBridgedGaps.bed hg38 \
	jkStuff/hg38.nonBridged.lft

##############################################################################
# cpgIslands - (DONE - 2013-12-31 - Hiram)
    # run on the Hmmer + trfMask sequence
    mkdir /hive/data/genomes/hg38/bed/cpgIslands
    cd /hive/data/genomes/hg38/bed/cpgIslands
    time doCpgIslands.pl hg38 > do.log 2>&1 &
    # real    5m22.460s

    cat fb.hg38.cpgIslandExt.txt
    #   23635946 bases of 3049335806 (0.775%) in intersection

#########################################################################
# construct liftOver to hg19 (DONE - 2013-12-31 - Hiram)
    # it turns out it doesn't matter if the query or target 2bit files
    # are masked.  This procedure can be done on completely unmasked sequences
    # for both, same result masked or not masked
    screen -S hg38	# manage this longish running job in a screen
    mkdir /hive/data/genomes/hg38/bed/blat.hg19.2013-12-31
    cd /hive/data/genomes/hg38/bed/blat.hg19.2013-06-10
    # this was run in manual steps as experiments were done about the masking
    # check it with -debug first to see if it is going to work:
    doSameSpeciesLiftOver.pl -stop=net -buildDir=`pwd` -bigClusterHub=ku \
      -dbHost=hgwdev -workhorse=hgwdev -debug \
        -ooc=/hive/data/genomes/hg38/jkStuff/hg38.11.ooc hg38 hg19
    # the debug step doesn't actually construct enough files to run the
    # steps manually.  The chaining has an extra procedure that is performed
    # while not in 'debug' mode
    # the run.blat was operated manually, then chaining:
    time doSameSpeciesLiftOver.pl -continue=chain -stop=net -buildDir=`pwd` \
      -bigClusterHub=ku \
        -dbHost=hgwdev -workhorse=hgwdev \
           -ooc=/hive/data/genomes/hg38/jkStuff/hg38.11.ooc \
             hg38 hg19 > chain.log 2>&1
    # real    22m31.635s
    # loading is only a few seconds:
    doSameSpeciesLiftOver.pl -continue=load -buildDir=`pwd` \
     -bigClusterHub=ku \
       -dbHost=hgwdev -workhorse=hgwdev \
          -ooc=/hive/data/genomes/hg38/jkStuff/hg38.11.ooc \
             hg38 hg19 > load.log 2>&1

    # verify this file exists:
    #	/gbdb/hg38/liftOver/hg38ToHg19.over.chain.gz
    # and try out the conversion on genome-test from hg38 to hg19
    # same file should exist for downloads:
    #  /usr/local/apache/htdocs-hgdownload/goldenPath/hg38/liftOver/hg38ToHg19.over.chain.gz

############################################################################
# marking the PAR regions:
    # hg19 had:
+-------+------------+-----------+------+
| chrom | chromStart | chromEnd  | name |
+-------+------------+-----------+------+
| chrX  |      60000 |   2699520 | PAR1 |
| chrX  |  154931043 | 155260560 | PAR2 |
| chrY  |      10000 |   2649520 | PAR1 |
| chrY  |   59034049 |  59363566 | PAR2 |
+-------+------------+-----------+------+

    # examining the files in
# /hive/data/genomes/hg38/genbank/Primary_Assembly/pseudoautosomal_region
    # perhaps like this on chrY chrX;
chrY  10000   2781479  length: 2771479 this one appears to be broken by gaps

# PAR2 section:
chrY  56887902 57217415 length: 329513
CM000686.2  56887903 57217415  24 F GL000190.2 1 329513  +
CM000686.2  56887903 56906486 356 O AJ271735.1 69145   87728   +

chrX  155701382       156030895  length: 329513
    # in the chrX AGP file, part of this contig:
CM000685.2  144475607  156030895 18 F GL000172.2  1 11555289   +

    # as seen in the chrY AGP file these two contigs:
CM000686.2    10001  1949345 2       F       GL000176.2      1       1939345 +
CM000686.2   1949346 2132994 3       N       183649  contig  no      na
CM000686.2   2132995 2781479 4       F       GL000180.2      1       648485  +

zcat ../../genbank/Primary_Assembly/assembled_chromosomes/AGP/chrY.comp.agp.gz\
  | grep -v "^#" | awk '$5 != "N"' \
    | awk '{printf "%s_%d_%d\t%s\t%d\t%d\n", $6,$7,$8,$1,$2,$3}' \
    | sort > chrY.comp.agp.txt
zcat ../../genbank/Primary_Assembly/assembled_chromosomes/AGP/chrX.comp.agp.gz\
  | grep -v "^#" | awk '$5 != "N"' \
    | awk '{printf "%s_%d_%d\t%s\t%d\t%d\n", $6,$7,$8,$1,$2,$3}' \
    | sort > chrX.comp.agp.txt
   join -t'^I' chrY.comp.agp.txt chrX.comp.agp.txt | head

CM000685.2  10001   44821   CM000686.2      10001   44821
...
CM000685.2  2677320 2677868 CM000686.2      2677320 2677868

CM000685.2 155719967  155720351       CM000686.2      56906487        56906871
...
CM000685.2 155964490  156030895       CM000686.2      57151010        57217415

############################################################################
## altLocations track (DONE - 2014-01-02 - Hiram)
    # indicate corresponding locations between haplotypes and reference
    mkdir /hive/data/genomes/hg38/bed/altLocations
    cd /hive/data/genomes/hg38/bed/altLocations

    find ../../genbank/ALT_* -type f | grep alt_scaffold_placement.txt \
  | while read F
do
  grep -v "^#" ${F} | sed -e 's/\./v/;' | awk -F'\t' '{printf "chr%s\t%d\t%d\tchr%s_%s_alt\n", $6,$12-1,$13,$6, $4}'
done | sort -k1,1 -k2,2n > chrToAlt.bed

    # note silent hidden <tab> character in the join -t argument
    # explicit as written here

find ../../genbank/ALT_* -type f | grep alt_scaffold_placement.txt \
  | while read F
do
  grep -v "^#" ${F} | sed -e 's/\./v/;' | awk -F'\t' '{printf "chr%s_%s_alt\tchr%s:%d-%d\n", $6,$4,$6,$12,$13}'
done | sort > altToChr.tab
sort ../../chrom.sizes | join -t'^I' - altToChr.tab \
   | awk '{printf "%s\t0\t%d\t%s\n", $1,$2,$3}' > altToChr.bed


   hgLoadBed hg38 altLocations chrToAlt.bed altToChr.bed
   featureBits -countGaps hg38 altLocations
   # 170113652 bases of 3209286105 (5.301%) in intersection

############################################################################
