#!/usr/bin/perl
#
# gbDbLoadStep [options] database ...
#
# Load databases on the current server.
#
# Options:
#   -workdir=work/$host/dbload
#   -allowLargeDeletes - override check for deleting large number of
#    entries.
#   -verbose
#   -keep
#   -initialLoad
#   -buildFullMgc=db  - build the full CDS MGC track for this database, maybe
#    repeated.
#   -buildAllMgc=db  - build all MGC tracks for this database, maybe
#    repeated.
#   -noPerChrom=db  - don't build per-chromsome tables for this database,
#    maybe repeated.
#
#
use strict;
use warnings;
use File::Basename;
use FindBin;
use lib "$FindBin::Bin/../lib";
use gbCommon;

my $workDir;
my @databases;
my %buildFullMgc;
my %buildAllMgc;
my $verboseArg;

# load MGC tables (note uses several globals)
sub loadMgc() {
    # find newest MGC build (in data/download/mgc/2003.04.09), looking
    # for md5 file.
    my $mgcGlob = "data/processed/mgc/*/mgc.md5";
    my @mgcCompleteFiles  = sort(glob($mgcGlob));
    if ($#mgcCompleteFiles < 0) {
        gbError("load of MGC track(s) requested, but no MGC files found: $mgcGlob");
    }
    # pick newest and get dir
    my $mgcDir = dirname($mgcCompleteFiles[$#mgcCompleteFiles]);

    # load database for db which were requests; all overrides full
    foreach my $db (@databases) {
        my @mgcArgs = ("-workdir=$workDir/$db/mgc");
        if (defined($verboseArg)) {
            push(@mgcArgs, $verboseArg);
        }
        if (defined($buildAllMgc{$db})) {
            runProg("mgcDbLoad " . join(" ", @mgcArgs)
                    . " -allMgcTables $db $mgcDir/mgcStatus.tab.gz");
        } elsif (defined($buildFullMgc{$db})) {
            runProg("mgcDbLoad " . join(" ", @mgcArgs)
                    . "$db $mgcDir/mgcFullStatus.tab.gz");
        }
    }
}

# Entry
my $hostName = `hostname`;
chomp($hostName);
my $keep = 0;
my $haveMgc = 0;
my %noPerChrom;
my $initialLoad = 0;
my $allowLargeDeletes = 0;
while (($#ARGV >= 0) && ($ARGV[0] =~ /^-.*/)) {
    my $opt = $ARGV[0];
    shift @ARGV;
    if ($opt =~ /^-workdir($|=)/) {
        $workDir = parseOptEq($opt);
    } elsif ($opt eq "-verbose") {
        $verboseArg = "-verbose";
        $gbCommon::verbose = 1;
    } elsif ($opt =~ /^-verbose=/) {
        $verboseArg = "-verbose=" . parseOptEq($opt);
        $gbCommon::verbose = 1;
    } elsif ($opt eq "-initialLoad") {
        $initialLoad = 1;
    } elsif ($opt =~ /^-noPerChrom=/) {
        my $db = parseOptEq($opt);
        $noPerChrom{$db} = 1;
    } elsif ($opt =~ /^-buildFullMgc=/) {
        my $mgcDb = parseOptEq($opt);
        $buildFullMgc{$mgcDb} = 1;
        $haveMgc = 1;
    } elsif ($opt =~ /^-buildAllMgc=/) {
        my $mgcDb = parseOptEq($opt);
        $buildAllMgc{$mgcDb} = 1;
        $haveMgc = 1;
    } elsif ($opt eq "-allowLargeDeletes") {
        $allowLargeDeletes = 1;
    } elsif ($opt eq "-keep") {
        $keep = 1;
    } else {
        gbError("invalid option \"$opt\"");
    }
}
if ($#ARGV < 0) {
    gbError("wrong # args: gbDbLoadStep [options] database ..");
}
@databases = @ARGV;

my @args;
if (!defined($workDir)) {
    $workDir = "work/$hostName/dbload";
}
push(@args, "-workdir=$workDir");
if ($initialLoad) {
    push(@args, "-initialLoad");
}
if (defined($verboseArg)) {
    push(@args, $verboseArg);
}

beginTask("dbload/$hostName", "dbload");

# load the database
foreach my $db (@databases) {
    my @dbArgs = @args;
    if (defined($noPerChrom{$db})) {
        push(@dbArgs, "-noPerChrom");
    }
    if ($allowLargeDeletes) {
        push(@dbArgs, "-allowLargeDeletes");
    }
    runProg("gbLoadRna " . join(" ", @dbArgs) . " $db");
}

# process MGC build requests
if ($haveMgc) {
    loadMgc();
}

if (!$keep) {
    runProg("rm -rf $workDir");
}
endTask();

