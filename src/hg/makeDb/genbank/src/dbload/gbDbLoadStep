#!/usr/bin/perl
#
# gbDbLoadStep [options] database ...
#
# Load databases on the current server.
#
# Options:
#   -workdir=work/$host/dbload
#   -allowLargeDeletes - override check for deleting large number of
#    entries.
#   -verbose
#   -keep
#   -initialLoad
#
#   -drop - drop tables before load.  This removes all of genbank and
#    refseq data, not just what is being loaded.
#
use strict;
use warnings;
use File::Basename;
use FindBin;
use lib "$FindBin::Bin/../lib";
use gbCommon;

my $workDir;
my @databases;
my %buildFullMgc;
my %buildAllMgc;
my $verboseArg;

# get the MGC table conf value, or undef if no MGC table load.
sub getMgcConf($) {
    my($db) = @_;
    my $host = callProg("uname -n");
    chomp($host);
    
    # try to find a 
    my $conf = getConf("$db.mgcTable.$host");
    if (!defined($conf)) {
        $conf = getConf("$db.mgcTable.default");
    }
    if (defined($conf )) {
        if ($conf eq "no") {
            $conf = undef;
        } elsif (!(($conf eq "full") || ($conf eq "all"))) {
            gbError("invalid value for $db.mgcTable \"$conf\", expected full, all, or no");
        }
    }
return $conf;
}

# load MGC tables (note uses several globals)
sub loadMgc($$) {
    my($db, $conf) = @_;
    # find newest MGC build (in data/download/mgc/2003.04.09), looking
    # for md5 file.
    my $mgcGlob = "data/processed/mgc/*/mgc.md5";
    my @mgcCompleteFiles  = sort(glob($mgcGlob));
    if ($#mgcCompleteFiles < 0) {
        gbError("load of MGC track(s) requested, but no MGC files found: $mgcGlob");
    }
    # pick newest and get dir
    my $mgcDir = dirname($mgcCompleteFiles[$#mgcCompleteFiles]);

    # load db which were requests; all overrides full
    my @mgcArgs = ("-workdir=$workDir/$db/mgc");
    if (defined($verboseArg)) {
        push(@mgcArgs, $verboseArg);
    }
    if ($conf eq "all") {
        runProg("mgcDbLoad " . join(" ", @mgcArgs)
                    . " -allMgcTables $db $mgcDir/mgcStatus.tab.gz");
    } elsif ($conf eq "full") {
        runProg("mgcDbLoad " . join(" ", @mgcArgs)
                . "$db $mgcDir/mgcFullStatus.tab.gz");
    }
}

# drop genbank tables
sub dropTables($) {
    my($db) = @_;
    if ($gbCommon::verbose) {
        prMsg("droping tables fro $db");
    }
    runProg("gbLoadRna -drop $db");    
}

# Entry
my $hostName = `hostname`;
chomp($hostName);
my $drop = 0;
my $keep = 0;
my $haveMgc = 0;
my $initialLoad = 0;
my $allowLargeDeletes = 0;
while (($#ARGV >= 0) && ($ARGV[0] =~ /^-.*/)) {
    my $opt = $ARGV[0];
    shift @ARGV;
    if ($opt =~ /^-workdir($|=)/) {
        $workDir = parseOptEq($opt);
    } elsif ($opt eq "-drop") {
        $drop = 1;
    } elsif ($opt eq "-verbose") {
        $verboseArg = "-verbose";
        $gbCommon::verbose = 1;
    } elsif ($opt =~ /^-verbose=/) {
        $verboseArg = "-verbose=" . parseOptEq($opt);
        $gbCommon::verbose = 1;
    } elsif ($opt eq "-initialLoad") {
        $initialLoad = 1;
    } elsif ($opt =~ /^-buildFullMgc($|=)/) {
        my $mgcDb = parseOptEq($opt);
        $buildFullMgc{$mgcDb} = 1;
        $haveMgc = 1;
    } elsif ($opt =~ /^-buildAllMgc($|=)/) {
        my $mgcDb = parseOptEq($opt);
        $buildAllMgc{$mgcDb} = 1;
        $haveMgc = 1;
    } elsif ($opt eq "-allowLargeDeletes") {
        $allowLargeDeletes = 1;
    } elsif ($opt eq "-keep") {
        $keep = 1;
    } else {
        gbError("invalid option \"$opt\"");
    }
}
if ($#ARGV < 0) {
    gbError("wrong # args: gbDbLoadStep [options] database ..");
}
@databases = @ARGV;

my @args;
if (!defined($workDir)) {
    $workDir = "work/$hostName/dbload";
}
push(@args, "-workdir=$workDir");
if ($initialLoad) {
    push(@args, "-initialLoad");
}
if (defined($verboseArg)) {
    push(@args, $verboseArg);
}

beginTask("dbload/$hostName", "dbload");

# load the database
foreach my $db (@databases) {
    if ($drop) {
        dropTables($db);
    }
    
    my @dbArgs = @args;
    if ($allowLargeDeletes) {
        push(@dbArgs, "-allowLargeDeletes");
    }
    runProg("gbLoadRna " . join(" ", @dbArgs) . " $db");
}

# process MGC build requests
foreach my $db (@databases) {
    my $conf = getMgcConf($db);
    if (defined($db)) {
        loadMgc($db, $conf);
    }
}

if (!$keep) {
    runProg("rm -rf $workDir");
}
endTask();

