#!/usr/bin/perl
#
# gbAlignStep [options] database genomeGlob liftFile ...
#
# Options:
#   -initial - Default the parameters for the initial alignment of a genome:
#      -workdir=work/initial.$db/align
#      -clusterdir=/iscratch/genbank
#    Doesn't create a semaphone file and will log to 
#       var/build/logs/2003.05.23-21:51:12.$db.initalign.log
#
#   -workdir=work/align - work directory where alignment is built.
#    This directory must have at least two levels (for use with rsync) for
#    example: rest/work2/work1.  Specifying a different parent directory
#    (work2) for doing alignments without risking of collision with the
#    automatic alignments.  The two levels of directories allows rsync to
#    delete older files under the parent directory when the lowest-level
#    directory includes the alignment date.  Maybe a longer or fully qualified
#    path.
#
#   -clusterdir=dir - The directory where the files will exist on the
#    cluster. They will be rsynced to this location on the iserver.  The
#    lowest two levels of the workdir are included, resulting, e.g.:
#    /dir/work/align.  Specifying this does the iserver rsync.
#
#   -parahost=kk - name of parasol host, must have rsh access.
#
#   -omit-iserver=host - Specify an iserver to omit from the default list.
#    use if an iserver is down and remapped.
#
#   -iserver=host - explictly specify an iserver to use.  Maybe repeated.
#    If none are specified, the default list is used.
#
#   -continue=subtask - continue processing of a failed alignment run
#    of this script.   Values for subtask are:
#        - copy - continue with coping to the iserver, this skips
#          extracting the sequences to align.
#        - finish - finish processing the alignments.
#    Continue the blat portion by using parasol directly.
#    
#
#   -keep - Keep work directory.
#
#   -verbose=n - Set verbose level.
#
#   -srcDb=name - Restrict the source database to either "genbank" or "refseq".
#
#   -type=name - Restrict the type of sequence processeed to either "mrna"
#    or "est".
#
# Alignment step, runs:
#  - gbAlignSetup - Extract sequences to align, create jobs files.
#  - gbAlignIServerCopy - Copy fasta files to iservers with rsync 
#  - gbAlignRun - rsh to kk adn run para make until jobs complete
#    checking results.
#  - gbAlignFinish - Process PSL files and install in data directory
#
use strict;
use warnings;
use File::Basename;
use FindBin;
use lib "$FindBin::Bin/../lib";
use gbCommon;

# Entry
my $workDir;
my $verbArg = "";
my $paraHost;
my $keep = 0;
my $clusterDir;
my @omitIServers;
my @iservers;
my @srcDbs;
my @types;
my $initialBuild = 0;
my $continueTask;
while (($#ARGV >= 0) && ($ARGV[0] =~/^-.*/)) {
    my $opt = $ARGV[0];
    shift @ARGV;
    if ($opt =~ /^-workdir($|=)/) {
        $workDir = parseOptEq($opt);
    } elsif ($opt eq "-initial") {
        $initialBuild = 1;
    } elsif ($opt =~ /^-clusterdir($|=)/) {
        $clusterDir = parseOptEq($opt);
    } elsif ($opt =~ /^-omit-iserver($|=)/) {
        push(@omitIServers, parseOptEq($opt));
    } elsif ($opt =~ /^-iserver($|=)/) {
        push(@iservers, parseOptEq($opt));
    } elsif ($opt =~ /^-continue($|=)/) {
        $continueTask = parseOptEq($opt);
    } elsif ($opt eq "-verbose") {
        $gbCommon::verbose = 1;
        $verbArg = "-verbose";
    } elsif ($opt =~ /^-verbose=/) {
        $gbCommon::verbose = parseOptEq($opt);
        $verbArg = "-verbose=$gbCommon::verbose";
    } elsif ($opt eq "-keep") {
        $keep = 1;
    } elsif ($opt =~ /^-parahost($|=)/) {
        $paraHost = parseOptEq($opt);
    } elsif ($opt =~ /^-srcDb($|=)/) {
        # value check in gbAlignSetup
        my $srcDb = parseOptEq($opt);
        push(@srcDbs, $srcDb);
    } elsif ($opt =~ /^-type($|=)/) {
        # value check in gbAlignSetup
        my $type = parseOptEq($opt);
        push(@types, $type);
    } else {
        gbError("invalid option \"$opt\"");
    }
}

if (($#ARGV < 1) || (($#ARGV+1) % 3) != 0) {
    gbError("wrong # args: gbAlignStep [options] database genomeGlob liftFile ...");
}
my @setupArgs;
my @finishArgs;
my @databases;
while ($#ARGV >= 0) {
    my $db = $ARGV[0];
    push(@databases, $db);
    shift @ARGV;
    my $genomeGlob = $ARGV[0];
    shift @ARGV;
    my $liftFile = $ARGV[0];
    shift @ARGV;
    # setup, must protect glob from shell expansion
    push(@setupArgs, $db);
    push(@setupArgs, "'" . $genomeGlob . "'");
    push(@setupArgs, $liftFile);
    # finish
    push(@finishArgs, $db);
    push(@finishArgs, $liftFile);
}

# defaults for initial alignment
my $initialDb;
if ($initialBuild) {
    if ($#databases != 0) {
        gbError("only one database maybe specified with -initial");
    }
    $initialDb = $databases[0];
    if (!defined($workDir)) {
        $workDir = "work/initial.$initialDb/align";
    }
    if (!defined($clusterDir)) {
        $clusterDir = "/iscratch/genbank";
    }
}

# default other parameters
if (!defined($workDir)) {
    $workDir = "work/align";
}
if (dirname($workDir) eq ".") {
    gbError("work directory must have at least two level, got: $workDir");
}
my $workDirArg = "-workdir=$workDir";

if (!defined($paraHost)) {
    $paraHost = "kk";
}

# convert continue task to a list of task to execute
my @tasks;
if (!defined($continueTask)) {
    @tasks = ("setup", "copy", "run", "finish");
} elsif ($continueTask eq "copy") {
    @tasks = ("copy", "run", "finish");
} elsif ($continueTask eq "run") {
    @tasks = ("run", "finish");
} elsif ($continueTask eq "finish") {
    @tasks = ("finish");
} else {
    gbError("invalid value for -continue, expected one of \"copy\", \"run\", or \"finish\"");
}

my $alignNone = "$workDir/align.none";  # indicates nothing to align
my $alignJobs = "$workDir/align.jobs";
my $alignDone = "$workDir/align.done";

# begin
if ($initialBuild) {
    beginTaskNoLock("build", "$initialDb.initalign");
} else {
    beginTask("build", "align");
}

# setup
if (inList("setup", @tasks)) {
    my $cmd = "gbAlignSetup $workDirArg $verbArg";
    if (defined($clusterDir)) {
        $cmd .= " -clusterdir=$clusterDir";
    }
    foreach my $srcDb (@srcDbs) {
        $cmd .= " -srcDb=$srcDb";
    }
    foreach my $type (@types) {
        $cmd .= " -type=$type";
    }
    $cmd .= " " . join(" ", @setupArgs);
    runProg($cmd);

    if (-e $alignNone) {
        prMsg("nothing to align");
    }
}

# Must either have a jobs or none file
if (! (-e $alignNone || -e $alignJobs)) {
    gbError("no $alignJobs or $alignNone file found");
}

# copy
if (inList("copy", @tasks) && !-e $alignNone) {
    # copy to iserver if needed
    if (defined($clusterDir)) {
        my $cmd = "gbAlignIServerCopy $verbArg";
        foreach my $iserver (@iservers) {
            $cmd .= " -iserver=$iserver";
        }
        foreach my $omit (@omitIServers) {
            $cmd .= " -omit-iserver=$omit";
        }
        $cmd .= " " . $workDir . " $clusterDir";
        runProg($cmd);
    }
}

# run alignment
if (inList("run", @tasks) && !-e $alignNone) {
    runProg("gbAlignRun $workDirArg -parahost=$paraHost $verbArg");
}

# If -continue=finish is specified, force the create of a jobs.done file
if (defined($continueTask) && ($continueTask eq "finish")) {
    # finishing by hand, create align.done file.
    open(DONE, ">$alignDone") || die("can't create $alignDone");
    close(DONE);
}

if (inList("finish", @tasks) && !-e $alignNone) {
    # finish, installing alignments
    runProg("gbAlignFinish $workDirArg $verbArg " . join(" ", @finishArgs));
}
if (!$keep) {
    runProg("rm -rf $workDir");
    my $workParent = dirname($workDir);
    rmdir($workParent);  # don't complain if can't remove
}
endTask();
