#!/usr/bin/perl
#
# gbAlignStep [options] database ...
#
# Options:
#   -initial - Default the parameters for the initial alignment of a genome:
#      -workdir=work/initial.$db/align
#    Doesn't create a semaphone file and will log to 
#       var/build/logs/2003.05.23-21:51:12.$db.initalign.log
#
#   -workdir=work/align - work directory where alignment is built.
#    This directory must have at least two levels (for use with rsync) for
#    example: rest/work2/work1.  Specifying a different parent directory
#    (work2) for doing alignments without risking of collision with the
#    automatic alignments.  The two levels of directories allows rsync to
#    delete older files under the parent directory when the lowest-level
#    directory includes the alignment date.  Maybe a longer or fully qualified
#    path.
#
#   -clusterRootDir=dir - The directory where the files will exist on the
#    cluster. They will be rsynced to this location on the iserver.  The
#    lowest two levels of the workdir are included, resulting, e.g.:
#    /dir/work/align.  Overrides cluster.rootDir conf item.
#
#   -paraHub=kk - name of parasol host, must have ssh access.
#
#   -iserver=host - explictly specify an iservers to use.  Maybe repeated.
#    If none are specified, the servers are obtained from the cluster.iserver
#    Specify "no" when using global file system.
#
#   -continue=subtask - continue processing of a failed alignment run
#    of this script.   Values for subtask are:
#        - copy - continue with coping to the iserver, this skips
#          extracting the sequences to align.
#        - run - continue with parasol blat run.
#        - finish - finish processing the alignments.
#    Continue the blat portion by using parasol directly.
#    
#   -keep - Keep work directory; this is set if -initial is specified
#
#   -verbose=n - Set verbose level.
#
#   -srcDb=name - Restrict the source database to either "genbank" or "refseq".
#
#   -type=name - Restrict the type of sequence processeed to either "mrna"
#    or "est".
#
# Obtains other parameters from etc/genbank.conf.
#
# Alignment step, runs:
#  - gbAlignSetup - Extract sequences to align, create jobs files.
#  - gbAlignIServerCopy - Copy fasta files to iservers with rsync 
#  - gbAlignRun - rsh to kk adn run para make until jobs complete
#    checking results.
#  - gbAlignFinish - Process PSL files and install in data directory
#
# $Id: gbAlignStep,v 1.9 2003/07/29 04:44:49 markd Exp $
#
use strict;
use warnings;
use File::Basename;
use FindBin;
use lib "$FindBin::Bin/../lib";
use gbCommon;

# Entry
my $workDir;
my $verbArg = "";
my $paraHub;
my $keep = 0;
my $clusterRootDir;
my $clusterWorkDir;
my $localWorkDir;
my @iservers;
my @srcDbs;
my @types;
my $initialBuild = 0;
my $continueTask;
while (($#ARGV >= 0) && ($ARGV[0] =~/^-.*/)) {
    my $opt = $ARGV[0];
    shift @ARGV;
    if ($opt =~ /^-workdir($|=)/) {
        $workDir = parseOptEq($opt);
    } elsif ($opt eq "-initial") {
        $initialBuild = 1;
    } elsif ($opt =~ /^-clusterRootDir($|=)/) {
        $clusterRootDir = parseOptEq($opt);
    } elsif ($opt =~ /^-iserver($|=)/) {
        push(@iservers, parseOptEq($opt));
    } elsif ($opt =~ /^-continue($|=)/) {
        $continueTask = parseOptEq($opt);
    } elsif ($opt eq "-verbose") {
        $gbCommon::verbose = 1;
        $verbArg = "-verbose";
    } elsif ($opt =~ /^-verbose=/) {
        $gbCommon::verbose = parseOptEq($opt);
        $verbArg = "-verbose=$gbCommon::verbose";
    } elsif ($opt eq "-keep") {
        $keep = 1;
    } elsif ($opt =~ /^-paraHub($|=)/) {
        $paraHub = parseOptEq($opt);
    } elsif ($opt =~ /^-srcDb($|=)/) {
        # value check in gbAlignSetup
        my $srcDb = parseOptEq($opt);
        push(@srcDbs, $srcDb);
    } elsif ($opt =~ /^-type($|=)/) {
        # value check in gbAlignSetup
        my $type = parseOptEq($opt);
        push(@types, $type);
    } else {
        gbError("invalid option \"$opt\"");
    }
}

if ($#ARGV < 0) {
    gbError("wrong # args: gbAlignStep [options] database ...");
}
my @databases;
while ($#ARGV >= 0) {
    push(@databases, $ARGV[0]);
    shift @ARGV;
}

# defaults for initial alignment
my $initialDb;
if ($initialBuild) {
    if ($#databases != 0) {
        gbError("only one database maybe specified with -initial");
    }
    $initialDb = $databases[0];
    if (!defined($workDir)) {
        $workDir = "work/initial.$initialDb/align";
    }
    if (!defined($clusterRootDir)) {
        $clusterRootDir = "/iscratch/genbank";
    }
}

# need to know if we are using the iservers
my @iserverList = @iservers;
if ($#iserverList < 0) {
    @iserverList = splitSpaceList(getConfNo("cluster.iservers"));
}
my $usingIservers = !(($#iserverList < 0) || ($iserverList[0] eq "no"));

# figure out workDir.  If no iservers are used, we write directly
# to cluster dir.
if (!defined($workDir)) {
    $workDir = "work/align";
}
if ($usingIservers) {
    if (dirname($workDir) eq ".") {
        gbError("work directory must have at least two level, got: $workDir");
    }
    if (!defined($clusterRootDir)) {
        $clusterRootDir = "/iscratch/genbank";
    }
    # use last two directories in workDir on cluster
    $clusterWorkDir = $clusterRootDir . "/" . basename(dirname($workDir)) . "/"
        . basename($workDir);
    $localWorkDir = $workDir;
} else {
    if (!defined($clusterRootDir)) {
        $clusterRootDir = "/iscratch/genbank";
    }
    $clusterWorkDir = "$clusterRootDir/$workDir";
    $localWorkDir = $clusterWorkDir;
}
my $workDirArg = "-workdir=$localWorkDir";
my $iserverArg = "";
foreach my $iserver (@iservers) {
    $iserverArg .= " -iserver=$iserver";
}


# convert continue task to a list of task to execute
my @tasks;
if (!defined($continueTask)) {
    @tasks = ("setup", "copy", "run", "finish");
} elsif ($continueTask eq "copy") {
    @tasks = ("copy", "run", "finish");
} elsif ($continueTask eq "run") {
    @tasks = ("run", "finish");
} elsif ($continueTask eq "finish") {
    @tasks = ("finish");
} else {
    gbError("invalid value for -continue, expected one of \"copy\", \"run\", or \"finish\"");
}

my $alignNone = "$localWorkDir/align.none";  # indicates nothing to align
my $alignJobs = "$localWorkDir/align.jobs";
my $alignDone = "$localWorkDir/align.done";

# If TMPDIR is not set, set it to a local directory. /var/tmp doesn't
# usually have enough space, so we use a tmp dir in the gbRoot
if (!defined($main::ENV{TMPDIR})) {
    $main::ENV{TMPDIR} = "tmp";
    makeDir("tmp");
}

# begin
if ($initialBuild) {
    beginTaskNoLock("build", "$initialDb.initalign");
} else {
    beginTask("build", "align");
}

# setup
if (inList("setup", @tasks)) {
    my $cmd = "gbAlignSetup $workDirArg $verbArg";
    if (defined($clusterRootDir)) {
        $cmd .= " -clusterWorkDir=$clusterWorkDir";
    }
    foreach my $srcDb (@srcDbs) {
        $cmd .= " -srcDb=$srcDb";
    }
    foreach my $type (@types) {
        $cmd .= " -type=$type";
    }
    
    foreach my $db (@databases) {
        $cmd .= " $db";
    }
    runProg($cmd);

    if (-e $alignNone) {
        prMsg("nothing to align");
    }
}

# Must either have a jobs or none file
if (! (-e $alignNone || -e $alignJobs)) {
    gbError("no $alignJobs or $alignNone file found");
}

# copy if using iservers
if ($usingIservers && inList("copy", @tasks) && !-e $alignNone) {
    # copy to iserver if needed
    if (defined($clusterRootDir)) {
        my $cmd = "gbAlignIServerCopy $verbArg $iserverArg";
        if (defined($clusterRootDir)) {
            $cmd .= " -clusterRootDir=$clusterRootDir";
        }
        $cmd .= " " . $workDir;
        runProg($cmd);
    }
}

# run alignment
if (inList("run", @tasks) && !-e $alignNone) {
    my $cmd = "gbAlignRun $workDirArg $verbArg";
    if (defined($paraHub)) {
        $cmd .= " -paraHub=$paraHub";
    }
    runProg($cmd);
}

# If -continue=finish is specified, force the create of a jobs.done file
if (defined($continueTask) && ($continueTask eq "finish")) {
    # finishing by hand, create align.done file.
    open(DONE, ">$alignDone") || die("can't create $alignDone");
    close(DONE) || die("close failed");
}

if (inList("finish", @tasks) && !-e $alignNone) {
    # finish, lift and installing alignments
    my $cmd = "gbAlignFinish $workDirArg $verbArg";
    foreach my $db (@databases) {
        $cmd .= " $db";
    }
    runProg($cmd);
}
if (!$keep && !$initialBuild) {
    runProg("rm -rf $localWorkDir");
    my $workParent = dirname($localWorkDir);
    rmdir($workParent);  # don't complain if can't remove
}
if ($initialBuild) {
    print STDERR "*** Note: -initial doesn't remove working directory:\n";
    print STDERR "***       $localWorkDir\n";
}
endTask();
