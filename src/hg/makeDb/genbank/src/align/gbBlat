#!/usr/bin/env tclsh
#
# Run blat, polyInfo and pslIntronsOnly.
#
# gbBlat [options] database genomeFile rnaFa out.psl
#
# Options:
#  -keep - keep temporary files.
#  -verbose - verbose debugging
#  -overwrite - overwrite existing output (for debugging)
#  -seqs seqsfile - file contains lists of sequencs to align for
#   Mondo 2bit files (lots of small sequences).  Each line contains
#   either the the sequence id, or {seqId seqSize seqStart seqEnd}.
# Arguments:
#  - database - hg13, etc; used to determine ooc file to use.
#
#  - genomeFile - Can be in one of the following formats:
#      - whole file, this can be a fasta, nib, or two-bit file. All
#        sequences in the file are aligned:
#          dirs/chr1.nib
#          dirs/smallOrg.2bit
#      - nib subrange, the range will be aligned and lifted back to chrom
#        coordinates:
#           dirs/chr1.nib:100000-200000
#      - 2bit single sequence
#           dirs/hg17.2bit:chr1
#      - a two-bit file, along with a list of sequences or subsequences
#        supplied in the -seqs argument.
#
#  - rnaFa - the RNA/EST query fasta file.  The name of this file
#    must be in the form type.orgCat.* (mrna.native, est.aa.xeno, etc).  This
#    is used to determine various parameter settings.  File should be named
#    in the form:
#       ..../refseq.136.0/hg16/full/mrna.xeno.0.fa
#    so refseq.ver or genbank.ver can be used to determine srcDb.
#    
#  - out.psl - PSL output file  The other output filenames are derived
#    by removing the .psl from the name.  If no sequences align, an
#    empty psl is still created to server as a job-completed marker.
#
# PSL files are written to a local tmp directory and then copies to the output
# directory to minimize NFS trafic.  If no sequences align, an empty psl file
# is still produced.  This script is very careful to exit non-zero if an error
# occurs.
#
# written in Tcl because bash version was getting hideously hard and wanted
# a language with named fuction parameters, like fortran.
#
# $Id: gbBlat,v 1.56 2005/05/22 17:30:27 braney Exp $
#

# Tools are normally taken from /cluster/bin, however we allow them to be
# overridden by puting them under gbRoot/bin/i386.  Use path to this script to
# find bin dir. Can't use MACHTYPE as it is i686-pc-linux-gnu on the cluster.
set gbBin [file dir [info script]]/i386
set stdBin /cluster/bin/i386
set env(PATH) "$gbBin:$stdBin:$env(PATH)"

# FXIME: tmp workaround for libmysqlclient.so.* not being on cluster
set env(LD_LIBRARY_PATH) [file dir [file dir [info script]]]/lib/i386

# use to record last command executed so that a shorter, more useful error
# message can be generated on child process error
set lastExec {}

##
# Choose OOC based on genome.  Will return empty string if no ooc should be used, but one
# should still be defined.
proc getOoc {database} {
    switch -glob -- $database {
        hg*       {return /scratch/hg/h/11.ooc}
        mm*       {return /scratch/hg/h/mouse11.ooc}
        rn*       {return /scratch/hg/h/rat11.ooc}
        panTro*   {return /cluster/bluearc/hg/h/chimp11.ooc}
        monDom*   {return /iscratch/i/monDom1/11.ooc}
        galGal*   {return /iscratch/i/galGal2/11.ooc}
        ce*       {return /iscratch/i/worms/Celegans2/11.ooc}
        cb*       {return /iscratch/i/worms/Cbriggsae/11.ooc}
        caeRei*   {return /iscratch/i/worms/caeRei0/11.ooc}
        caeRem*   {return /iscratch/i/caeRem1/11.ooc}
        danRer*   {return /iscratch/i/danRer1/11.ooc}
        canFam*   {return /iscratch/i/canFam1/11.ooc}
        oryCun*   {return ""}
        tetNig*   {return /iscratch/i/tetNig1/11.ooc}
        anoGam*   {return /iscratch/i/anoGam1/11.ooc}
        apiMel*   {return /iscratch/i/apiMel2/11.ooc}
        dm*       {return /iscratch/i/dm1/11.ooc}
        dp*       {return /iscratch/i/dp3/11.ooc}
        droYak*   {return /iscratch/i/droYak1/11.ooc}
        droAna*   {return /iscratch/i/droAna1/11.ooc}
        droMoj*   {return /iscratch/i/droMoj1/11.ooc}
        droVir*   {return /iscratch/i/droVir1/11.ooc}
        droEre*   {return /iscratch/i/droEre1/11.ooc}
        droSim*   {return /iscratch/i/droSim1/11.ooc}
        bosTau*   {return /iscratch/i/bosTau1/11.ooc}
        rheMac*   {return /iscratch/i/rheMac1/11.ooc}
        xenTro*   {return /iscratch/i/xenTro1/11.ooc}
        fr*       {return ""}
        sacCer*   {return ""}
        ci*       {return ""}
	strPur*   {return /panasas/store/strPur1/11.ooc}
        borEut*   {return /iscratch/i/borEut1/11.ooc}
        default   {
            error "no blat OOC defined for $database, edit gbBlat function getOoc to add"
        }
    }
}

# lassign list varname ?varname..?
proc lassign {vals args} {
    set i 0
    foreach var $args {
        if {$var != ""} {
            set val [lindex $vals $i]
            uplevel 1 [list set $var $val]
        }
        incr i
    }
    return [lrange $vals $i end]
}

##
# exec a command with verbose output if requested stderr passed through
proc doExec {args} {
    global verbose lastExec

    if {$verbose} {
        puts stderr [join $args]
    }
    set lastExec $args
    eval exec $args 2>@stderr
}

##
# exec, recording last command, return stdout
proc callProg {args} {
    global lastExec
    set lastExec $args
    return [eval exec $args]
}

##
# writes a message and abort without a stack trace
proc abort {msg} {
    puts stderr "Error: $msg"
    exit 1
}

##
# pop a command line argument
proc cmdlinePop {} {
    global argv
    set opt [lindex $argv 0]
    set argv [lreplace $argv 0 0]
    return $opt
}

##
# pop a command line option argument
proc cmdlinePopVal {opt} {
    global argv
    if {[llength $argv] == 0} {
        abort "$opt requires an argument"
    }
    return [cmdlinePop]
}

##
# Parse input cDNA file name for use in selecting parameters.
# return {srcDb orgCat cdnaType}
proc parseCDnaFaPath {rnaFa} {
    set rnaBase [file tail [file root $rnaFa]]

    # get srcDb by looking at the directory names:
    #  .../align/genbank.133.0/hg15test/full/mrna.native.0.fa
    set srcDbDir [file tail [file dirname [file dirname [file dirname $rnaFa]]]]
    switch -glob $srcDbDir {
        genbank.* {
            set srcDb genbank
        }
        refseq.* {
            set srcDb refseq
        }
        default {
            abort "can't determine srcDb from $rnaFa"
        }
    }
    
    # get cdnaType and orgCat from filename, ESTs are split by accPrefix as well
    set parts [split $rnaBase .]
    if {[llength $parts] < 3} {
        abort "can't parse mrna file name to get parameters: $rnaFa"
    }
    set cdnaType [lindex $parts 0]
    switch -- $cdnaType {
        mrna {
            set orgCat [lindex $parts 1]
        }
        est {
            set orgCat [lindex $parts 2]
        }
        default {
            abort "invalid type \"$cdnaType\" in mrna file name: $rnaFa"
        }
    }
    if {!(($orgCat == "native") || ($orgCat == "xeno"))} {
        abort "invalid organism category \"$orgCat\" in mrna file name: $rnaBase"
    }
    return [list $srcDb $orgCat $cdnaType]
}


# figure out BLAT parameters bases on type of alignment
proc determineBlatParams {database srcDb orgCat cdnaType} {
    set ooc [getOoc $database]
    if {$ooc != ""} {
        set oocOpt -ooc=$ooc
    } else {
        set oocOpt ""
    }

    #- repeat-masking only used on xeno
    switch $orgCat {
        native {
            switch $cdnaType {
                mrna {set blatParams "-q=rna -fine $oocOpt"}
                est  {set blatParams "$oocOpt"}
            }
        }
        xeno {
            switch $cdnaType {
                mrna {set blatParams "-q=rnax -t=dnax -mask=lower"}
                est  {set blatParams "-q=dnax -t=dnax -mask=lower"}
            }
        }
    }

    # other genome-specific parameters; done here so it can override blatParams
    switch -glob $database {
        panTro* {
            # until we have more orgCats, use special blatParams for human refseqs in chimp
            if {($srcDb == "refseq") && ($orgCat == "xeno")} {
                # override dBefaults above
                set blatParams "-q=rna -fine -mask=lower"
            }
        }
        sacCer* {
            # limit intron size to 5K
            set blatParams "${blatParams} -maxIntron=5000"
        }
        ce* {
            # limit intron size to 100K
            set blatParams "${blatParams} -maxIntron=100000"
        }
        ci* {
            # limit intron size to 20K
            set blatParams "${blatParams} -maxIntron=20000"
        }
    }
    return $blatParams
}

##
# Determine type of genome input
# return {genomeType genomeFmt}
proc getGeneomeInputType {genomeFile} {
    switch -glob -- [file tail $genomeFile] {
        *.nib {
            return {full nib}
        }
        *.nib:*-* {
            return {subseq nib}
        }
        *.2bit {
            return {full 2bit}
        }
        *.2bit:*-* {
            return {subseq 2bit}
        }
        *.2bit:- {
            return {seq 2bit}
        }
        *.fa {
            return {full fa}
        }
        default {
            abort "count not determine format of genome file: $genomeFile"
        }
    }
}

##
# parse the subrange spec out of the genome file
# return {seq seqSize subStart subEnd}
proc parseSubRangeSpec {genomeFile genomeType genomeFmt} {
    # parse the nib/2bit spec into various components and get size
    #    /scratch/hg/gs.18/build35/bothMaskedNibs/chr22.nib:1000000-2000000
    #    /scratch/hg/gs.18/build35/hg16.2bit:chr22:1000000-2000000
    # parse into chr start end
    if {$genomeFmt == "nib"} {
        if {![regexp {^(.+/([^/]+)\.nib):([0-9]+)-([0-9]+)$}  $genomeFile {} nibFile genomeSeq genomeSubStart genomeSubEnd]} {
            abort "parse of subseq failed: $gemomeFile"
        }
        set genomeSize [callProg nibSize $nibFile | cut -f 3]
    } else {
        if {![regexp {^.+/[^/]+\.2bit:(.+):([0-9]+)-([0-9]+)$} $genomeFile {} genomeSeq genomeSubStart genomeSubEnd]} {
            abort "parse of subseq failed: $gemomeFile"
        }
        set genomeSize [callProg twoBitInfo $genomeFile stdout | cut -f 2]
    }
    return [list $genomeSeq $genomeSize $genomeSubStart $genomeSubEnd]
}

##
# convert a list of subinfo record into a tmp lift file
# subinfo is {seq seqSize subStart subEnd}
proc makeLift {subInfos} {
    global tmpDir
    set liftFile $tmpDir/subseq.lft
    set fh [open $liftFile w]
    foreach subInfo $subInfos {
        lassign $subInfo subSeq seqSize subStart subEnd
        set subName $subSeq:$subStart-$subEnd
        set subSize [expr $subEnd-$subStart]
        puts $fh [join [list $subStart $subName $subSize $subSeq $seqSize] \t]
    }
    close $fh
    return $liftFile
}

##
# copy or lift a file.  It is copied to it's output location with a .tmp
# extension and then renamed to it's final name
proc liftOrCp {type inFile outFile liftFile} {
    if {$liftFile == ""} {
        doExec cp $inFile $outFile.tmp
    } else {
        # FIXME wanted to specify "error", however blat doesn't include
        # subrange if it covers the whole sequence
        doExec liftUp -nohead -nosort -type=.$type $outFile.tmp $liftFile carry $inFile
    }
    file rename -force $outFile.tmp $outFile
}

##
# align and process results
proc alignToGenome {genomeFile rnaFa blatParams orgCat cdnaType outFiles {subInfos {}}} {
    global tmpBase
    lassign $outFiles outPsl outOi outIntronPsl

    # initial tmp output on local FS
    set localPsl $tmpBase.psl
    set localOi $tmpBase.oi
    set localIntronPsl $tmpBase.intronPsl
    file delete $localPsl $localOi $localIntronPsl
    
    # lift file if needed
    if {[llength $subInfos] == 0} {
        set liftFile {}
    } else {
        set liftFile [makeLift $subInfos]
    }

    # align
    eval doExec blat -noHead $blatParams [list $genomeFile $rnaFa] $localPsl

    # orientation info info and ESTs w/intron selection is only done for
    # native and if the output file length is greater than zero
    if {([file size $localPsl] > 0) && ($orgCat == "native")} {
        # get orientation info
        doExec polyInfo $localPsl $genomeFile $rnaFa $localOi
        liftOrCp bed $localOi $outOi $liftFile

        # if these are native ESTs, select ones that have introns, saving only
        # if some actually exist.
        if {$cdnaType == "est"} {
            doExec pslIntronsOnly $localPsl $genomeFile $localIntronPsl
            if {[file size $localIntronPsl] > 0} {
                liftOrCp psl $localIntronPsl $outIntronPsl $liftFile
            }
        }
    }

    # psl is installed last to indicate completion, even if empty
    liftOrCp psl $localPsl $outPsl $liftFile
}

##
# generate alignments in normal manner, without seqs file
proc genAlignments {database srcDb orgCat cdnaType genomeFile rnaFa outFiles subInfo} {
    set blatParams [determineBlatParams $database $srcDb $orgCat $cdnaType]
    alignToGenome $genomeFile $rnaFa $blatParams $orgCat $cdnaType $outFiles [list $subInfo]
}

##
# parse a line of of the mondo seqsFile
proc parseSeqsFileLine {line seqsFile} {
    set row [split $line]
    if {[llength $row] == 1} {
        set seqSpec [lindex $row 0] 
        set subInfo {}
    } elseif {[llength $row] == 4} {
        set seqSpec [lindex $row 0]:[lindex $row 2]-[lindex $row 3]
        set subInfo $row
    } else {
        error "invalid line in $seqsFile: $line"
    }
    return [list $seqSpec $subInfo]
}

##
# load mondo seqsFile into two lists of seqsSpecs and subInfos
proc loadSeqsFile {seqsFile} {
    set seqsSpecs {}
    set subInfos {}
    set fh [open $seqsFile]
    while {[gets $fh line] >= 0} {
        set s [parseSeqsFileLine $line $seqsFile]
        lappend seqsSpecs [lindex $s 0]
        lappend subInfos [lindex $s 1]
    }
    close $fh
    return [list $seqsSpecs $subInfos]
}

##
# count number of sequences in a fasta file
proc faCount {fa} {
    return [string trim [callProg faSize -detailed $fa | wc -l]]
}

##
# extract mondo sequences into a temporary fasta file, return
# fasta file path
proc extractMondoSeqs {genomeFile seqsSpecs} {
    global tmpDir

    # build list of sequences to feed to twoBitToFa
    set seqsFile $tmpDir/genomeSeqs.spec
    set fh [open $seqsFile w]
    foreach s $seqsSpecs {
        puts $fh $s
    }
    close $fh

    # extract into fasta
    set seqsFa $tmpDir/genomeSeqs.fa
    callProg twoBitToFa -seqList=$seqsFile $genomeFile $seqsFa
    
    # a little paranoia is good
    set numFa [faCount $seqsFa]
    if {$numFa != [llength $seqsSpecs]} {
        error "extractMondoSeqs: expected [llength $seqsSpecs] in fasta, got $numFa"
    }
    return $seqsFa
}

##
# generate mondo alignments, using seqs file.  Extract sequences into
# a temporary fasta file, since blat was really slow doing one sequence
# at a time.
proc genMondoAlignments {database srcDb orgCat cdnaType genomeFile rnaFa outFiles seqsFile} {
    set blatParams [determineBlatParams $database $srcDb $orgCat $cdnaType]

    # gets sequence/subsequence info and info needed to lift back
    lassign [loadSeqsFile $seqsFile] seqsSpecs subInfos
    set seqsFa [extractMondoSeqs $genomeFile $seqsSpecs]
    alignToGenome $seqsFa $rnaFa $blatParams $orgCat $cdnaType $outFiles $subInfos
}

##
# handle an caught error, avoid dumping stack on subprocess or system call
# errors.
proc handleError {errorResult} {
    global errorInfo errorCode keepTmp tmpDir lastExec verbose
    set holdErrorInfo $errorInfo
    set holdErrorCode $errorCode
    if {!$keepTmp} {
        # don't use callProg here, need to preserve lastExec
         exec rm -rf $tmpDir &
    }
    if {$verbose} {
        puts stderr "ErrorInfo: $holdErrorInfo"
        puts stderr "ErrorCode: $holdErrorCode"
    }
    switch [lindex $holdErrorCode 0] {
        CHILDSTATUS {
            puts stderr "Error: $errorResult"
            puts stderr "Exec: $lastExec"
            exit 1
        }
        POSIX {
            puts stderr "Error: $errorResult"
            exit 1
        }
        default {
            error $errorResult $holdErrorInfo $holdErrorCode
        }
    }
}

##
# entry, parse arguments
set keepTmp 0
set verbose 0
set overwrite 0
set seqsFile {}
while {[llength $argv] && [string match -* [lindex $argv 0]]} {
    set opt [cmdlinePop]
    switch -- $opt {
        -keep {
            set keepTmp 1
        }
        -seqs {
            set seqsFile [cmdlinePopVal $opt]
        }
        -verbose {
            set verbose 1
        }
        -overwrite {
            set overwrite 1
        }
        default {
            puts stderr "Error: invalid option: $opt"
            exit 1
        }
    }
}

if {[llength $argv] != 4} {
    abort {Wrong \# args: gbBlat [options] database genomeFile rnaFa pslBaseDir}
}
set database [lindex $argv 0]
set genomeFile [lindex $argv 1]
set rnaFa [lindex $argv 2]
set outPsl [lindex $argv 3]

set outDir [file dirname $outPsl]
set outBase [file root [file tail $outPsl]]
set outPrefix $outDir/$outBase
set outOi $outPrefix.oi
set outIntronPsl $outPrefix.intronPsl
set outFiles [list $outPsl $outOi $outIntronPsl]

# include user name in tmpDir name, since stale directories from another
# user can't be removed.  Prefer /scratch/tmp, an fall back to /var/tmp
set user $env(USER)

if {[file isdirectory /scratch/tmp]} {
    set tmpDir /scratch/tmp/gbBlat.$user.[pid].tmp
} else {
    set tmpDir /var/tmp/gbBlat.$user.[pid].tmp
}

# skip if output file already exists
if {[file exists $outPsl] && !$overwrite} {
    puts stderr "Note: output psl exists, skipping: $outPsl"
    exit 0
}

lassign [parseCDnaFaPath $rnaFa] srcDb orgCat cdnaType

lassign [getGeneomeInputType $genomeFile] genomeType genomeFmt
if {$genomeType == "subseq"} {
    if {$seqsFile != ""} {
        abort("can't specify -seqs with subrange");
    }
    set subInfo [parseSubRangeSpec $genomeFile $genomeType $genomeFmt]
} else {
    set subInfo {}
}

if {($seqsFile != "") && ($genomeFmt != "2bit")} {
    abort("can only specify -seqs with twobit files");
}

# tmp and output setup
# create out directory now, so mkdir failure (usually NFS) will not happen
# after blat has completed. Maintain group write/sticky
callProg rm -rf $tmpDir
callProg mkdir -p -m 02775 $tmpDir
if {[catch {callProg mkdir -p -m 02775 $outDir}]} {
    # Try twice, just because we sometimes get weird failures.  
    callProg sleep 2
    callProg mkdir -p -m 02775 $outDir
}
set tmpBase $tmpDir/$outBase
if {$keepTmp} {
    puts stderr "note: will keep [callProg hostname] tmpDir $tmpDir"
}

# generate alignments, cleaning up tmp on error
if {[catch {
    if {$seqsFile == ""} {
        genAlignments $database $srcDb $orgCat $cdnaType $genomeFile $rnaFa $outFiles $subInfo
    } else {
        genMondoAlignments $database $srcDb $orgCat $cdnaType $genomeFile $rnaFa $outFiles $seqsFile
    }
} errorResult]} {
    handleError $errorResult
}
if {!$keepTmp} {
    callProg rm -rf $tmpDir &
}
