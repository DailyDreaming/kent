#!/usr/bin/env tclsh

#
# Run blat, polyInfo and pslIntronsOnly.
#
# gbBlat [options] jobSpecFile out.psl
#
# Options:
#  -keep - keep temporary files.
#  -verbose - verbose debugging
#  -overwrite - overwrite existing output (for debugging)
#  -tmpDir - use this tmpdir (for debugging).
#
# Arguments:
#  - jobSpecFile - path to a file describing the set of alignments to perform.
#    The format is described below.
#  - out.psl - PSL output file  The other output filenames are derived
#    by removing the .psl from the name.  If no sequences align, an
#    empty psl is still created to server as a job-completed marker.
#
# Job specification file:
#   Format are lines of key words and values. Blank lines and lines where
#   the first non-blank character is '#' are ignored.  A line ending in
#   a '\' is continued to the next line.  Records are in the form
#      key<whitespace+>value
#   A job spec defines a set of queries and target to align against each
#   other, as well as a set of parameters that control the alignment.
#
#   The following keys are recognized:
#     o type - alignment type, two value, first is the orgCat (native or xeno),
#       second is the cDNA type (mrna or est)
#     o ooc - blat ooc file to use (optional).
#     o tdb - target database, this is either a NIB directory or a twoBit file.
#     o tdbSlow2bit - If yes, then this is a twoBit file with a large number
#       of sequences.  It is most likely faster to extract the target sequence
#       from the file than repeatedly access it (optional).
#     o tseq - white-space separated list of target sequences, which are either
#       a sequence id (chr1), or a sequence size and subrange
#       (chr1:size:start-end).
#     o qdb - white-space seperated list of query fasta files.  All sequences
#       in the files will be queried.
#     o preFilterOpts - pslCDnaFilter options to use for prefiltering.  This
#       should only include the non-comparitive options.
# PSL files are written to a local tmp directory and then copied to the output
# directory to reduce NFS impact.  If no sequences align, an empty psl file
# is still produced.  This script is very careful to exit non-zero if an error
# occurs.



# written in Tcl because bash version was getting hideously hard and wanted
# a language with named fuction parameters, ya known, like in fortran.
#
# $Id: gbBlat,v 1.44.4.10 2005/08/16 23:20:17 markd Exp $
#

# Tools are normally taken from /cluster/bin, however we allow them to be
# overridden by puting them under gbRoot/bin/$ARCH.  Use path to this script to
# find bin dir.
if {$tcl_platform(machine) == "i686"} {
    set arch $tcl_platform(machine)
} else {
    set arch $tcl_platform(machine)
}

# include i386 as a fall back on x86_64 platforms
set gbBinDir [file dir [info script]]
set env(PATH) "$gbBinDir/$arch:$gbBinDir/i386:/cluster/bin/$arch:$env(PATH)"

# FXIME: tmp workaround for libmysqlclient.so.* not being on cluster
set env(LD_LIBRARY_PATH) [file dir [file dir [info script]]]/lib/i386

# use to record last command executed so that a shorter, more useful error
# message can be generated on child process error
set lastExec {}

# lassign list varname ?varname..?
proc lassign {vals args} {
    set i 0
    foreach var $args {
        if {$var != ""} {
            set val [lindex $vals $i]
            uplevel 1 [list set $var $val]
        }
        incr i
    }
    return [lrange $vals $i end]
}

##
# exec a command with verbose output if requested stderr passed through
proc doExec {args} {
    global verbose lastExec

    if {$verbose} {
        puts stderr [join $args]
    }
    set lastExec $args
    eval exec $args 2>@stderr
}

##
# exec, recording last command, return stdout
proc callProg {args} {
    global lastExec
    set lastExec $args
    return [eval exec $args]
}

##
# writes a message and abort without a stack trace
proc abort {msg} {
    puts stderr "Error: $msg"
    exit 1
}

##
# pop a command line argument
proc cmdlinePop {} {
    global argv
    set opt [lindex $argv 0]
    set argv [lreplace $argv 0 0]
    return $opt
}

##
# pop a command line option argument
proc cmdlinePopVal {opt} {
    global argv
    if {[llength $argv] == 0} {
        abort "$opt requires an argument"
    }
    return [cmdlinePop]
}

##
# read the next job spec record from the file, or empty if no more.
proc nextJobSpec {fh} {
    # find next record
    set line {}
    while {[gets $fh line] >= 0} {
        set line [string trimleft $line]
        if {![regexp {^(\#|$)} $line]} {
            break
        }
    }
    if {[string length $line] == 0} {
        return {}  ;# eof
    }

    # read continuation lines, ensuring a blank between each line
    while {[regsub {\\$} $line {} line]} {
        if {[gets $fh line2] < 0} {
            error "EOF while parsing line continuation"
        }
        set line "$line $line2"
    }
    
    # break into a list of words
    regsub -all {[[:space:]]+} $line { } line
    return [split [string trim $line]]
}

##
# constants used in validating specs.  specsDef is an array of valid keys,
# with the value being a list of {numValues required}.  Where numValues
# is the required number of values, or negative of the minimum number of values.
#    
array set specsDef {
    type {2 1}
    ooc  {1 0}
    tdb  {1 1}
    tseq {-1 1}
    qdb  {-1 1}
    maxIntron {1 0}
    tdbSlow2bit {1 0}
    preFilterOpts {-1 0}
}

##
# parse open jobs specs file
proc parseJobSpecsFh {fh specsVar} {
    upvar $specsVar specs
    global specsDef

    # read specs
    while {[llength [set spec [nextJobSpec $fh]]]} {
        set specs([lindex $spec 0]) [lrange $spec 1 end]
    }

    # validate
    foreach key [array names specs] {
        if {![info exists specsDef($key)]} {
            error "unknown key \"$key\""
        }
    }
    foreach key [array names specsDef] {
        set def $specsDef($key)
        if {[lindex $def 1] && ![info exists specs($key)]} {
            error "missing required key \"$key\""
        }
        if {![info exists specs($key)]} {
            if {[lindex $def 1]} {
                error "missing required key \"$key\""
            }
        } else {
            set numVals [lindex $def 0]
            if {$numVals >= 0} {
                if {[llength $specs($key)] != $numVals} {
                    error "$key requires $numVals values"
                }
            } else {
                if {[llength $specs($key)] < $numVals} {
                    error "$key requires at least $numVals values"
                }
            }
        }
    }
    if {[lsearch {native xeno} [lindex $specs(type) 0]] < 0} {
        error "key \"type\" orgCat should be \"native\" or \"xeno\""
    }
    if {[lsearch {mrna est} [lindex $specs(type) 1]] < 0} {
        error "key \"type\" cDNA type should be \"mrna\" or \"est\""
    }

    if {[info exists specs(tdbSlow2bit)]} {
        if {[lsearch {yes no} $specs(tdbSlow2bit)] < 0} {
            error "value for \"tdbSlow2bit\" should be \"yes\" or \"no\", got\"$specs(tdbSlow2bit)\""
        }
    } else {
        # default
        set specs(tdbSlow2bit) no
    }

}

##
# parse the job spec file into an array indexed by key, with values being a list
proc parseJobSpecs {specFile specsVar} {
    upvar $specsVar specs
    set fh [open $specFile]
    if {[catch {
        parseJobSpecsFh $fh specs
    } msg]} {
        error "$msg: $specFile" "parsing $specFile\n$::errorInfo" $::errorCode
    }
    close $fh
}

# figure out BLAT parameters bases on specs
proc determineBlatParams {specsVar} {
    upvar $specsVar specs
    lassign $specs(type) orgCat cdnaType
    set blatParams {}

    #- repeat-masking only used on xeno, ooc not used for translated
    switch $orgCat {
        native {
            switch $cdnaType {
                mrna {lappend blatParams -q=rna -fine}
                est {}
            }
            if {[info exists specs(ooc)]} {
                lappend blatParams -ooc=$specs(ooc)
            }
        }
        xeno {
            switch $cdnaType {
                mrna {lappend blatParams -q=rnax -t=dnax -mask=lower}
                est  {lappend blatParams -q=dnax -t=dnax -mask=lower}
            }
        }
    }
    # hack: until we have more orgCats, use special blatParams for human
    set qdb0 [lindex $specs(qdb) 0]
    if {[string match "*refseq*" $qdb0] && [string match "*/panTro*/*" $qdb0]
        && [string match "*xeno*" $qdb0]} {
        set blatParams "-q=rna -fine -mask=lower"
    }

    if {[info exists specs(maxIntron)]} {
        lappend blatParams -maxIntron=$specs(maxIntron)
    }

    return $blatParams
}

##
# Extract a subsequence from a twoBit file into tmp
proc getTwoBitSlow {genomeSeqRef seqId subStart subEnd} {
    global tmpDir
    set faPath $tmpDir/$seqId
    if {$subStart != {}} {
        append faPath :$subStart-$subEnd
    }
    append faPath .fa
    if {![file exists $faPath]} {
        doExec twoBitToFa $genomeSeqRef $faPath
    }
    return $faPath
}

##
# create name referencing a genome sequences in a genome file.
proc makeGenomeSeqRef {specsVar tSeqSpec} {
    upvar $specsVar specs
    set path $specs(tdb)
    if {[string match *.2bit $specs(tdb)]} {
        # either single subrange, or list of whole sequences
        append path : [join $tSeqSpec ,]
    } else {
        # nib whole sequence of subrange
        lassign [parseTSeq [lindex $tSeqSpec 0]] seqId seqSize subStart subEnd
        append path /$seqId.nib
        if {$subStart != {}} {
            append path :$subStart-$subEnd
        }
    }
    return $path
}

# checksum a file
proc cksum {file} {
    return [lindex [split [exec cksum $file]] 0]
} 

##
# parse a target sequence spec into a list
# return either {seqId seqSize subStart subEnd} or {seqId}
proc parseTSeq {tseq} {
    if {[regexp {^(.+):(.+):(.+)-(.+)$} $tseq {} seqId seqSize subStart subEnd]} {
        return [list $seqId $seqSize $subStart $subEnd]
    } else {
        return [list $tseq]
    }
}

##
# create a temporary lift file for the specified subsequence
proc makeLift {seqId seqSize subStart subEnd} {
    global tmpPrefix
    set liftFile $tmpPrefix.lft
    set fh [open $liftFile w]
    set subName $seqId:$subStart-$subEnd
    set subSize [expr $subEnd-$subStart]
    puts $fh [join [list $subStart $subName $subSize $seqId $seqSize] \t]
    close $fh
    return $liftFile
}

##
# create a lift file, if needed, otherwise return {}.
# seqSpecs is a list, will only make a lift if this is a single sequecne with
# a subrange.
# 
proc makeLiftIfNeeded {tSeqSpec} {
    set liftFile {}
    if {[llength $tSeqSpec] == 1} {
        lassign [parseTSeq [lindex $tSeqSpec 0]] seqId seqSize subStart subEnd
        if {$subStart != {}} {
            set liftFile [makeLift $seqId $seqSize $subStart $subEnd]
        }
    }
    return $liftFile
}

##
# append a file to a cummulative tmp output file, optionally lifting
proc liftOrCp {type inFile outFile liftFile} {
    set outFh [open $outFile a]
    if {$liftFile == ""} {
        exec cat $inFile >@$outFh
    } else {
        # Note: wanted to specify "error", however blat doesn't include
        # subrange if it covers the whole sequence
        doExec liftUp -nohead -nosort -type=.$type stdout $liftFile carry $inFile >@$outFh
    }
    close $outFh
}  

##
# get poly-A sizes for a cDNA fasta
proc getPolyASizes {cdnaFa} {
    return [file root $cdnaFa].polya
}

##
# prefilter a psl file with non-comparive pslCDnaFilter options
#
proc preFilterAligns {specsVar cdnaFa inPsl} {
    global tmpPrefix
    upvar $specsVar specs
    set outPsl $tmpPrefix.filtered.psl

    set polyASizes [getPolyASizes $cdnaFa]
    set cmd [list pslCDnaFilter -verbose=0 -nonComparative -polyASizes=$polyASizes]
    set cmd [concat $cmd $specs(preFilterOpts)]
    lappend cmd $inPsl $outPsl
    eval doExec $cmd
    return $outPsl
}

##
# atomic install of a file to it's final location
proc installFile {inFile outFile} {
    # copy to global storage and verify checksum
    set inCksum [cksum $inFile]
    doExec cp $inFile $outFile.tmp
    set cpCksum [cksum $outFile.tmp]
    if {$inCksum != $cpCksum} {
        error "checksum mismatch after copy to global storage: $inFile ($inCksum) != $outFile.tmp ($cpCksum)"
    }
    # atomic rename
    file rename -force $outFile.tmp $outFile
}

##
# Align and process results, appending results to specified cummulative output
# files.  This may either align a single sequence with subseq specs, or if 
# this is a nib, a list of whole sequences.
proc alignToGenome {specsVar blatParams tSeqSpec cdnaFa outPsl outOi outIntronPsl} {
    global tmpPrefix
    upvar $specsVar specs
    lassign $specs(type) orgCat cdnaType

    # unfiltered tmp output on local FS
    set localPsl $tmpPrefix.psl
    set localOi $tmpPrefix.oi
    set localIntronPsl $tmpPrefix.intronPsl
    file delete $localPsl $localOi $localIntronPsl
    
    set genomeSeqRef [makeGenomeSeqRef specs $tSeqSpec]
    set liftFile [makeLiftIfNeeded $tSeqSpec]

    # align
    set cmd [concat {blat -noHead -repeats=lower} $blatParams \
                 [list $genomeSeqRef $cdnaFa $localPsl]]
    eval doExec $cmd
    if {[info exists specs(preFilterOpts)]} {
        set localPsl [preFilterAligns specs $cdnaFa $localPsl]
    }
    liftOrCp psl $localPsl $outPsl $liftFile

    # orientation info info and ESTs w/intron selection is only done for
    # native and if the output file length is greater than zero
    if {([file size $localPsl] > 0) && ($orgCat == "native")} {
        # get orientation info
        doExec polyInfo $localPsl $genomeSeqRef $cdnaFa $localOi
        liftOrCp bed $localOi $outOi $liftFile

        # if these are native ESTs, select ones that have introns, saving only
        # if some actually exist.
        if {$cdnaType == "est"} {
            doExec pslIntronsOnly $localPsl $genomeSeqRef $localIntronPsl
            if {[file size $localIntronPsl] > 0} {
                liftOrCp psl $localIntronPsl $outIntronPsl $liftFile
            }
        }
    }
}

##
# partation target sequences into sets that can be passed to alignToGenome.
# This optimize 2bit access by group whole seqs together, but avoiding
# overflowing command lines
proc partitionTargetSeqs {specsVar} {
    upvar $specsVar specs
    if {![string match *.2bit $specs(tdb)]} {
        # nib, each sequence individually
        puts stderr "ret=[list $specs(tseq)]"
        return $specs(tseq)
    }
    # split into subseqs and whole seqs
    set subSpecs {}
    set wholeSpecs {}
    foreach tseq $specs(tseq) {
        if {[string match *:*-* $tseq]} {
            lassign [parseTSeq $tseq] seqId {} subStart subEnd
            lappend subSpecs $seqId:$subStart-$subEnd
        } else {
            lappend wholeSpecs $tseq
        }
    }
    # build partitions
    set tSeqSpecs {}
    if {[llength $wholeSpecs] > 0} {
        set maxSeqsPerLine 8000
        set nSeqs [llength $wholeSpecs]
        for {set i 0} {$i < $nSeqs} {incr i $maxSeqsPerLine} {
            lappend tSeqSpecs [lrange $wholeSpecs $i [expr $i+($maxSeqsPerLine)-1]]
        }
        if {[llength $subSpecs] > 0} {
            set tSeqSpecs [concat $tSeqSpecs $subSpecs]
        }
    }
    return [concat $tSeqSpecs $subSpecs]
}

##
# generate alignments based on the specs
proc genAlignments {specsVar outPrefix} {
    global tmpPrefix
    upvar $specsVar specs
    set blatParams [determineBlatParams specs]

    # accumulate output files in tmpdir
    set cumPsl $tmpPrefix.cum.psl
    set cumOi $tmpPrefix.cum.oi
    set cumIntronPsl $tmpPrefix.cum.intronPsl

    # loop over each target sequence set and each query fasta
    foreach tSeqSpec [partitionTargetSeqs specs] {
        foreach cdnaFa $specs(qdb) {
            alignToGenome specs $blatParams $tSeqSpec $cdnaFa $cumPsl $cumOi $cumIntronPsl
        }
    }

    # install to final location, psl last to indicate completion
    if {[file exist $cumOi]} {
        installFile $cumOi $outPrefix.oi
    }
    if {[file exist $cumIntronPsl]} {
        installFile $cumIntronPsl $outPrefix.intronPsl
    }
    installFile $cumPsl $outPrefix.psl
}

##
# handle an caught error, avoid dumping stack on subprocess or system call
# errors.
proc handleError {errorResult} {
    global errorInfo errorCode keepTmp tmpDir lastExec verbose
    set holdErrorInfo $errorInfo
    set holdErrorCode $errorCode
    if {!$keepTmp} {
        # don't use callProg here, need to preserve lastExec
         exec rm -rf $tmpDir &
    }
    if {$verbose} {
        puts stderr "ErrorInfo: $holdErrorInfo"
        puts stderr "ErrorCode: $holdErrorCode"
    }
    switch [lindex $holdErrorCode 0] {
        CHILDSTATUS {
            puts stderr "Error: $errorResult"
            puts stderr "Exec: $lastExec"
            exit 1
        }
        POSIX {
            puts stderr "Error: $errorResult"
            exit 1
        }
        default {
            error $errorResult $holdErrorInfo $holdErrorCode
        }
    }
}

##
# create tmp directory
proc mkTmpDir {tmpArg} {
    global env keepTmp
    # include user name in tmpDir name, since stale directories from another
    # user can't be removed.  Prefer /scratch/tmp, an fall back to /var/tmp
    set dirName gbBlat.$env(USER).[pid].tmp

    if {$tmpArg != {}} {
        set tmpDir $tmpArg/$dirName
    } elseif {[file isdirectory /scratch/tmp]} {
        set tmpDir /scratch/tmp/$dirName
    } else {
        set tmpDir /var/tmp/$dirName
    }
    callProg rm -rf $tmpDir
    callProg mkdir -p -m 02775 $tmpDir
    if {$keepTmp} {
        puts stderr "note: will keep [callProg hostname] tmpDir $tmpDir"
    }
    return $tmpDir
}

##
# create output directory Call early, so mkdir failure (usually NFS) will not happen
# after blat has completed. Maintain group write/sticky
proc mkOutDir {outDir} {
    if {[catch {callProg mkdir -p -m 02775 $outDir}]} {
        # Try twice, just because we sometimes get weird failures.  
        callProg sleep 2
        callProg mkdir -p -m 02775 $outDir
    }
}

##
# entry, parse arguments
set keepTmp 0
set verbose 0
set overwrite 0
set tmpArg {}
while {[llength $argv] && [string match -* [lindex $argv 0]]} {
    set opt [cmdlinePop]
    switch -- $opt {
        -keep {
            set keepTmp 1
        }
        -verbose {
            set verbose 1
        }
        -overwrite {
            set overwrite 1
        }
        -tmpDir {
            set tmpArg [cmdlinePopVal $opt]
        }
        default {
            puts stderr "Error: invalid option: $opt"
            exit 1
        }
    }
}

if {[llength $argv] != 2} {
    abort {Wrong \# args: gbBlat [options] jobSpecFile out.psl}
}
parseJobSpecs [lindex $argv 0] specs
set outPsl [lindex $argv 1]

set outDir [file dirname $outPsl]
set outBase [file root [file tail $outPsl]]
set outPrefix $outDir/$outBase

# skip if output file already exists
if {[file exists $outPsl] && !$overwrite} {
    puts stderr "Note: output psl exists, skipping: $outPsl"
    exit 0
}

set tmpDir [mkTmpDir $tmpArg]
set tmpPrefix $tmpDir/$outBase
mkOutDir $outDir

# generate alignments, cleaning up tmp on error
if {[catch {
    genAlignments specs $outPrefix
} errorResult]} {
    handleError $errorResult
}
if {!$keepTmp} {
    callProg rm -rf $tmpDir &
}
