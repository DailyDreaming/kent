#!/usr/bin/perl

$main::usage="
gbAlignSetup [options] database ...

Do setup for the alignment step.

Options:
  -workdir=work/align - work directory where alignment is built.
   See gbAlignStep for details;.

  -clusterWorkDir=dir - location of work directory on cluster.

  -verbose=n - print details

  -srcDb=name - Restrict the source database to either \"genbank\" or \"refseq\".

  -type=name - Restrict the type of sequence processeed to either \"mrna\"
   or \"est\".

  -orgCat=name - Restrict type of sequences to processe to native or xeon
   If not speicifed, categories that are to be loaded are used from
   genbank.conf.  Maybe repeated.

  -noMigrate - Don't migrate alignments.

Arguments:
  - database - databases to align

Obtains other parameters from etc/genbank.conf:

  - $db.genome - a glob pattern of where to find the genome
     contig or chromosome fasta, nib, or 2bit files on the cluster.
     For example: 
       hg13.genome = /scratch/hg/gs.14/build31/trfFa.1204/NT_*.fa.trf

  - $db.lift - the lift file is used to split up nibs.  If fasta files or
     whole nibs are used, it is ignored and can be empty or no.

  - $db.mondoTwoBitParts - If specified, genome file is s two-bit file
    with lots (tens of K) of small scaffolds.  This splits the genome into
    this number of parts for alignment.

Does:
   - Find updates that are missing alignments in the latest releases for
     each specified database. 
   - Extract tmp fasta file to align into the alignment work directory.
   - Produce a single parasol jobs file to do all of the alignments.
   - This checks if the contig alignments exist in the work/align directory
     before adding the job.  This allows this program to be re-run as a last
     ditch way of restarting on failure.  Normally, using parasol to restart
     the failed jobs is the way to recover.
   - create a list of all expected PSL files.";

#
# $Id: gbAlignSetup,v 1.12.8.1 2004/12/23 21:58:23 markd Exp $
#
use strict;
use warnings;
use File::Basename;
use FindBin;
use lib "$FindBin::Bin/../lib";
use gbCommon;

# Maximum size of an individual fasta file, in bytes.
my $maxFaSize = 64*1024*1024; # 64mb

# global table to make sure we don't generate output file more than
# once
my %gOutPsls;

# other globals
my $workDir = "work/align";
my $clusterWorkDir;
my $gbBlatPath;
my $srcDbs;
my $cwd = `pwd`;
chomp($cwd);
my @srcDbs;
my @types;
my @orgCats;
my $noMigrate = 0;


# determine if a file is a nib file.
sub isNibFile($) {
    my($genomeFile) = @_;
    return ($genomeFile =~ /\.nib$/);
}

# get chrom for a NIB
sub getNibChrom($) {
    my($genomeFile) = @_;
    my $chrom = $genomeFile;
    $chrom =~ s/^.+\///;
    $chrom =~ s/\.nib$//;
    return $chrom;
}

# get the size of a chromosome from a nib
sub getNibSize($) {
    my($nibFile) = @_;
    my $nibSizeOut = callProg("nibSize $nibFile", 1);
    chomp($nibSizeOut);
    my @nibSizeInfo = split(/\t/, $nibSizeOut);
    return $nibSizeInfo[2];
}

# determine if a file is a 2bit file.
sub isTwoBitFile($) {
    my($genomeFile) = @_;
    return ($genomeFile =~ /\.2bit$/);
}

# get chroms and size in a twobit file.  This is does in one pass because
# there can be a lot of scaffolds in a twobit. Return list of chroms, sorted in
# assending size order, fill in hash with sizes.
sub getTwoBitChromsSizes($$) {
    my($genomeFile, $sizeTblRef) = @_;
    my @chroms;
    # warning: can't use pipe here, would be nice to just: | sort -k 2,2n
    my $twoBitOut = callProg("twoBitInfo $genomeFile stdout");
    foreach my $line (split(/\n/, $twoBitOut)) {
        my @row = split(/\t/, $line);
        $sizeTblRef->{$row[0]} = $row[1];
        push(@chroms, $row[0]);
    }
    
    @chroms = sort {$sizeTblRef->{$a} - $sizeTblRef->{$b}} @chroms;

    return @chroms;
}

# split unaligned string into it's component names
# $release/$db/$update/$typeAccPrefix/$orgCatsStr
# $orgCatsStr  = native,xeno
sub splitUnaligned($) {
    my($unaligned) = @_;
    my($release, $db, $update, $typeAccPrefix, $orgCatsStr) = split(/\//, $unaligned);
    if (!defined($release)) {
        die("invalid unaligned spec: $unaligned");
    }
    my @orgCats = split(",", $orgCatsStr);
    return ($release, $db, $update, $typeAccPrefix, @orgCats);
}

# get unaligned for an update
sub getUpdateUnaligned($$$$@) {
    my($release, $update, $db, $type, @orgCats) = @_;
    my %unaligned;
    my @gbIdxFiles = ($type eq "est")
        ? glob("data/processed/$release/$update/$type.*.gbidx")
        : glob("data/processed/$release/$update/$type.gbidx");

    foreach my $gbIdx (@gbIdxFiles) {
        # will produce both native and xeno indices
        my $typeAccPrefix = basename($gbIdx, ".gbidx");
        my $baseIdx = "data/aligned/$release/$db/$update/$typeAccPrefix";
        my $nativeAlIdx = "$baseIdx.native.alidx";
        my $xenoAlIdx = "$baseIdx.xeno.alidx";
        my @missingOrgCats;
        if (inList("native", @orgCats) && !-e $nativeAlIdx) {
            push(@missingOrgCats, "native");
        }
        if (inList("xeno", @orgCats) && !-e $xenoAlIdx) {
            push(@missingOrgCats, "xeno");
        }
        if ($#missingOrgCats >= 0) {
            my $name = "$release/$db/$update/$typeAccPrefix/"
                . join(",", @missingOrgCats);
            $unaligned{$name} = 1;
        }
    }
    return sort(keys(%unaligned));
}

# build list of release/db/update/typeAccPrefix that need to be aligned
# for a release.  Returned with updates sorted.
sub findUnaligned($$$@) {
    my($release, $db, $type, @orgCats) = @_;
    my $srcDb = $release;
    $srcDb =~ s/\..+$//;
    if ($#orgCats < 0) {
        # set orgCats from config
        if (getDbConf($db, "$srcDb.$type.native.load") eq "yes") {
            push(@orgCats, "native");
        }
        if (getDbConf($db, "$srcDb.$type.xeno.load") eq "yes") {
            push(@orgCats, "xeno");
        }
    }

    my @unalignedList = ();
    foreach my $update (getUpdates("processed", $release)) {
        push(@unalignedList, getUpdateUnaligned($release, $update, $db, $type, @orgCats));
    }

    return @unalignedList;
}

# Extract fasta files of sequences to align for an update and type by running
# gbAlignGet. Return list with number of sequences to align and the fully
# qualified paths to the fasta files.
sub extractMRnaFastas($) {
    my($unaligned) = @_;
    my($release, $db, $update, $typeAccPrefix, @orgCats) = splitUnaligned($unaligned);

    # check if it already extracted
    my @alignsList = glob("$workDir/$unaligned.*.aligns");
    if ($#alignsList >= 0) {
        gbError("setup already done, don't know why we found: "
                . join(" ", @alignsList));
    }

    # run program to extract fasta files, get back count and number.
    my $cmd = "gbAlignGet";
    if ($maxFaSize > 0) {
        $cmd .= " -fasize=$maxFaSize";
    }
    if ($gbCommon::verbose) {
        $cmd .= " -verbose=$gbCommon::verbose";
    }
    if ($noMigrate) {
        $cmd .= " -noMigrate";
    }
    $cmd .= " -workdir=$workDir -orgCats=" . join(",", @orgCats)
        . " $release $update $typeAccPrefix $db";
    my $out = callProg($cmd);
    my $numAlign;
    my @mrnaFas = ();
    
    foreach my $line (split('\n', $out)) {
        chomp($line);
        my @parts = split(' ',$line);
        if ($parts[0] eq "alignFa:") {
            push(@mrnaFas, $parts[1]);
        } elsif ($parts[0] eq "alignCnt:") {
            $numAlign = int($parts[1]);
        } else {
            gbError("unexpected line returned from \"$cmd\": $line");
        }
    }
    
    if (!defined($numAlign)) {
        gbError("numAligned not returned from \"$cmd\"");
    }
    if ((($numAlign == 0) && ($#mrnaFas >= 0))
        || (($numAlign > 0) && ($#mrnaFas < 0))) {
        gbError("numAlign ($numAlign) does not make sense with number of fastas ($#mrnaFas) returned from \"$cmd\"");
    }
    
    return ($numAlign, @mrnaFas);
}

# parse NIB subrange file references for getOutPslPath
sub parseNibSubrangePath($) {
    my($nibBase) = @_;

    # build33/chromTrfMixedNib/chr1.nib:50000-217280
    #   dir1 is chrom
    #   dir2 is first digit of start
    #   base is chr:start-end
    my($chrom, $range) = ($nibBase =~ /^(.+)\.nib:(.+)$/);

    return ($chrom, substr($range, 0, 1), $chrom . ":" . $range);
}

# parse twobit subrange file references for getOutPslPath
sub parseTwoBitSubrangePath($) {
    my($twoBitBase) = @_;

    # build33/hg15.2bit:chr1:50000-217280
    #   dir1 is chrom
    #   dir2 is first digit of start
    #   base is chr:start-end
    my($chrom, $range) = ($twoBitBase =~ /^.+.2bit:(.+):(.+)$/);

    return ($chrom, substr($range, 0, 1), $chrom . ":" . $range);
}

# parse mondo seq file subrange file references for getOutPslPath
sub parseMondoSeqFilePath($) {
    my($mondoSeqFile) = @_;

    # genbank.37.0/mondo/bosTau1/scaffold1000.seqs
    #   dir1 is scaffold
    #   dir2 is last char
    #   base is scaffold
    my $chrom = basename($mondoSeqFile, ("\.seqs"));
    return ($chrom, substr($chrom, length($chrom)-1), $chrom);
}

# parse a fasta or full nib file path for getOutPslPath
sub parseFullFilePath($) {
    my($filePath) = @_;
    my($dir1, $dir2);

    my $fileBase = basename($filePath, ("\.fa\.trf", "\.fa", "\.nib", "\.2bit"));
    if ($dir1 =~ /.+_.+/) {
        # form dirs from name part
        ($dir1, $dir2) = split(/_/, $dir1);
    } else {
        # use first and last char
        $dir1 = substr($fileBase, 0, 1);
        $dir2 = substr($fileBase, -1, 1);
    }
    return ($dir1, $dir2, $fileBase);
}

# Create the path to the PSL (or other) output file.  This will output the
# files into subdirectories of a directory psl.  A multi-level tree is created
# to avoid too many files in a single directory, which drives NFS nuts.
# care is also be take to generate unique names (which is sanity checked
# later).
#
# An alignment of .../mrna.0.fa and  .../NT_035745.fa.trf will end up in:
#
#   $pslBaseDir/mrna.0/4/5/NT_035745.psl
#
# The way the directory names are derived depends on the the genome file
# name:
#
#    NT_035745.fa.trf -> 4/5/NT_035745.psl
#    chr1_10.nib -> chr1/10/chr1_10.psl
#    chr1.nib:207000000-217000000 -> chr1/2/0/chr1.psl
#    
# IMPORTANT NOTE: gbAlignFinish takes advantage of a one-to-one mapping between
# query file and the first directory level to make sorting more efficient, so
# don't change this with understanding what is going on.
#
sub getOutPslPath($$$$) {
    my($genomeFile, $mondoSeqFile, $rnaFa, $pslBaseDir) = @_;
    my $rnaBase = basename($rnaFa, "\.fa");
    my $genomeBase = basename($genomeFile);

    my($dir1, $dir2, $base);

    if (defined($mondoSeqFile)) {
        ($dir1, $dir2, $base) = parseMondoSeqFilePath($mondoSeqFile);
    } elsif ($genomeBase =~ /^.+\.nib:.+$/) {
        ($dir1, $dir2, $base) = parseNibSubrangePath($genomeBase);
    } elsif ($genomeBase =~ /^.+\.2bit:.+$/) {
        ($dir1, $dir2, $base) = parseTwoBitSubrangePath($genomeBase);
    } else {
        ($dir1, $dir2, $base) = parseFullFilePath($genomeFile);
    }
    return "$pslBaseDir/$rnaBase/$dir1/$dir2/$base.psl";
}

# load a lift file into a list of hash-refs
sub loadLiftFile($) {
    my($liftFile) = @_;

    # lift format: offset oldName oldSize newName newSize
    # old name maybe in the form 1/NT_034471
    open(LIFTFH, $liftFile) || die("can't open $liftFile");
    my(@lifts);
    my $line;
    my $lineCnt = 0;
    while (($line = <LIFTFH>)) {
        chomp($line);
        $lineCnt++;
        if (!($line =~ /\#.*$/)) {
            my($offset, $oldName, $oldSize, $newName, $newSize) = split(/\t/,$line);
            if (!defined($newSize)) {
                die("$liftFile:$lineCnt: lift file line must have at least 5 tab-separated columns");
            }
            if ($oldName ne "gap") {
                $oldName =~ s/^.+\///;  # 1/NT_034471 => NT_034471
                my $row = {
                    'offset' => $offset,
                    'oldName' => $oldName,
                    'oldSize' => $oldSize,
                    'newName' => $newName,
                    'newSize' => $newSize,
                };
                push(@lifts, $row);
            }
        }
    }
    close(LIFTFH) || die("close failed");

    return @lifts;
}

# get lifts for a chrom, sorted in assending offset order
sub getChromLifts($@) {
    my($chrom, @lifts) = @_;

    my(@chromLifts);
    for my $lift (@lifts) {
        if ($lift->{newName} eq $chrom) {
            push(@chromLifts, $lift);
        }
    }
    # look, more syntax (gag)
    @chromLifts = sort {$a->{offset} <=> $b->{offset}} @chromLifts;

    return @chromLifts;
}

# get a set of offset, size, end lift-like record for chomosome, merging
# records to allow for gaps upto maxGapSize.
sub getChromMaxGappedLifts($$@) {
    my($maxGapSize, $chrom, @lifts) = @_;
    my @maxGapLifts;
    my $curRec = undef;
    my $curEnd = undef;
    foreach my $lift (getChromLifts($chrom, @lifts)) {
        if (defined($curRec) && (($lift->{offset}  - $curEnd) > $maxGapSize)) {
            # gap from last greater than max, start a new record
            push(@maxGapLifts, $curRec);
            $curRec = undef;
            $curEnd = undef;
        }
        if (!defined($curRec)) {
            # add new
            $curRec = {
                'offset' => $lift->{offset},
                'oldSize' => $lift->{oldSize},
                'newName' => $lift->{newName},
            };
        } else {
            # extend curRec
            $curRec->{oldSize} = ($lift->{offset} + $lift->{oldSize})
                - $curRec->{offset};
        }
        $curEnd = $curRec->{offset} + $curRec->{oldSize};
    }
    if (defined($curRec)) {
        push(@maxGapLifts, $curRec);
    }
    return @maxGapLifts;
}

# Partition part or all of a genome file into overlaping (or non-overlapping)
# ranges.  This maybe called on an entire chromosome on an ungapped range.
sub partitionRange($$$$$$$) {
    my($db, $genomeFile, $chrom, $start, $end, $winSize, $winOverlap) = @_;
    my @specs;

    my $winStart = $start;
    while ($winStart < $end) {
        # get window
        my $winEnd = $winStart + $winSize;
        if ($winEnd > $end) {
            $winEnd = $end;
        } elsif ($winEnd+$winOverlap >= $end)  {
            # next overlap will take us to end, just included it now
            $winEnd = $end
        }
        if ($winEnd <= $winStart) {
            die("partitionRange: confused window $winStart to $winEnd");
        }

        # construct subrange spec
        my $spec;
        if (isNibFile($genomeFile)) {
            $spec = $genomeFile . ":" . $winStart . "-" . $winEnd;
        } else {
            # include chrom name for 2bit
            $spec = $genomeFile . ":" . $chrom . ":" . $winStart . "-" . $winEnd;
        }
        push(@specs, $spec);

        # advance window with overlap.
        $winStart += ($winSize - $winOverlap);
    }
    return @specs;
}

# Partition a genome file and chromosome using lifts to skip gaps over a\
# maximum size.
sub partitionWithLift($$$$@) {
    my($db, $genomeFile, $chrom, $chromSize, @lifts) = @_;
    my $winSize = getDbConf($db, "align.window");
    if ($winSize <= 0) {
        $winSize = $chromSize;
    }
    my $winOverlap = getDbConf($db, "align.overlap");
    my $maxGapSize = getDbConf($db, "align.maxGap");
    my @specs;
    
    foreach my $lift (getChromMaxGappedLifts($maxGapSize, $chrom, @lifts)) {
        my @rspec = partitionRange($db, $genomeFile, $chrom,
                                   $lift->{offset}, $lift->{offset}+$lift->{oldSize},
                                   $winSize, $winOverlap);
        push(@specs, @rspec);
    }
    return @specs;
}


# Partition a genome file by windows across a whole chromosome
sub partitionByWindows($$$$) {
    my($db, $genomeFile, $chrom, $chromSize) = @_;
    my $winSize = getDbConf($db, "align.window");
    if ($winSize <= 0) {
        $winSize = $chromSize;
    }
    my $winOverlap = getDbConf($db, "align.overlap");
    return partitionRange($db, $genomeFile, $chrom, 0, $chromSize,
                          $winSize, $winOverlap);
}

# partition a nib file into a list of fileSepces
sub partitionNibFile($$@) {
    my($db, $nibFile, @lifts) = @_;
    my @fileSpecs;
    foreach my $chrom (getNibChrom($nibFile)) {
        if ($#lifts >= 0) {
            push(@fileSpecs,
                 partitionWithLift($db, $nibFile, $chrom, getNibSize($nibFile), @lifts));
        } else {
            push(@fileSpecs,
                 partitionByWindows($db, $nibFile, $chrom, getNibSize($nibFile)));
        }
    }
    return @fileSpecs;
}

# partition a 2bit file into a list of fileSpecs
sub partitionTwoBitFile($$@) {
    my($db, $twoBitFile, @lifts) = @_;
    my @fileSpecs;
    my %sizeTbl;
    my @chroms = getTwoBitChromsSizes($twoBitFile, \%sizeTbl);
    foreach my $chrom (@chroms) {
        if ($#lifts >= 0) {
            push(@fileSpecs,
                 partitionWithLift($db, $twoBitFile, $chrom, $sizeTbl{$chrom}, @lifts));
        } else {
            push(@fileSpecs,
                 partitionByWindows($db, $twoBitFile, $chrom, $sizeTbl{$chrom}));
        }
    }
    return @fileSpecs;
}

# Crude attempt to sort mondo sequences so that jobs with an even number
# of sequences still have a mixture of large and small sequences.
sub mondoBalance($@) {
    my($sizeTblRef, @chroms) = @_;
    # assumes chroms is sorted in assending order
    my $iTop = 0;
    my $iBot = $#chroms;
    my @newChroms;

    while ($iTop <= $iBot) {
        # 1 from bottom (larger)
        push(@newChroms, $chroms[$iBot--]);
        # 4 from top
        for (my $i = 0; ($i < 4) && ($iTop <= $iBot); $i++) {
            push(@newChroms, $chroms[$iTop++]);
        }
    }
    if ($#newChroms != $#chroms) {
        die("mondoBalance logic error, chrom lists different sizes: "
            . "  old: " . $#chroms  . "  new: " . $#newChroms);
    }
    return @newChroms;
}

# partition on chrom in a mondo 2bit and write to SEQIDS
sub partitionMondoTwoBitChrom($$$$@) {
    my($db, $twoBitFile, $chrom, $sizeTblRef, @lifts) = @_;

    # get list of file specs the standard way
    my @fileSpecs;
    if ($#lifts >= 0) {
        push(@fileSpecs,
             partitionWithLift($db, $twoBitFile, $chrom, $sizeTblRef->{$chrom}, @lifts));
    } else {
        push(@fileSpecs,
             partitionByWindows($db, $twoBitFile, $chrom, $sizeTblRef->{$chrom}));
    }

    # now split it up, fileSpecs is either
    #   "dir/foo.2bit:seqid:start-end"
    #   "dir/foo.2bit:seqid"
    foreach my $spec (@fileSpecs) {
        # results is 4 parts:
        #   (seqId, :st-end, st, end)
        # or
        #   (seqId, , , )
        my(@parts) = ($spec =~ /\/[^\/]+\.2bit:([^:]+)(:([0-9]+)-([0-9]+))?/);
        if (($#parts != 3) || (($parts[1] ne "") and ($parts[3] eq ""))) {
            die("can't parse file spec: $spec");
        }
        if (!defined($sizeTblRef->{$parts[0]})) {
            die("size not defined for seq $parts[0] from file spec: $spec");
        }
        if ($parts[1] ne "") {
            print SEQIDS $parts[0],"\t",$sizeTblRef->{$parts[0]},"\t",$parts[2],"\t",$parts[3],"\n";
        } else {
            print SEQIDS $parts[0],"\n";
        }
    }
}

# partition a 2bit file with lots of small sequences in it.  Write files in
# $outDir/$id.seqs, where id is the first sequence in the list.  Return list
# of workDir relative seq files. This was done for bosTau1, which had 450K
# scaffolds, lots of small ones.  Since gbBlat loops over the sequences,
# invoking several programs, try to balancing number of sequences for each
# jobs as well as sizes
sub partitionMondoTwoBitFile($$$$) {
    my($db, $twoBitFile, $numParts, $outDir) = @_;
    my @seqFiles;
    my %sizeTbl;
    my @chroms = getTwoBitChromsSizes($twoBitFile, \%sizeTbl);
    @chroms = mondoBalance(\%sizeTbl, @chroms);

    my $liftFile = getDbConfNo($db, "lift");
    my @lifts;
    if (defined($liftFile)) {
        @lifts = loadLiftFile($liftFile);
    }

    makeDir($workDir . "/" . $outDir);

    # determine number of parts per jobs
    my $chromsPerPart = ($#chroms+$numParts)/$numParts;
    for (my $iChr = 0; $iChr <= $#chroms;) {
        my $seqFile = $outDir . "/" . $chroms[$iChr] . ".seqs";
        my $seqPath = $workDir . "/" . $seqFile;
        open(SEQIDS, ">", $seqPath) || gbError("can't create $seqPath");
        for (my $i = 0; ($iChr <= $#chroms) && $i < $chromsPerPart; $i++, $iChr++) {
            partitionMondoTwoBitChrom($db, $twoBitFile, $chroms[$iChr], \%sizeTbl, @lifts)
        }
        close(SEQIDS) || gbError("error writing $seqFile");
        push(@seqFiles, $seqFile);
    }
    return @seqFiles;
}

# partition a single genome file into a list of fileSepces
sub partitionGenomeFile($$@) {
    my($db, $genomeFile, @lifts) = @_;
    my @fileSpecs;
    # partition if we have a file format that supprot subrange spec.
    if (isNibFile($genomeFile)) {
        push(@fileSpecs, partitionNibFile($db, $genomeFile, @lifts));
    } elsif (isTwoBitFile($genomeFile)) {
        push(@fileSpecs, partitionTwoBitFile($db, $genomeFile, @lifts));
    } else {
        push(@fileSpecs, $genomeFile);
    }
    return @fileSpecs;
}

# Generate the list of genome target files.  For fasta files, this is a
# simple glob, for nib files, we use the lift file to generate subsequence
# requests to blat.
sub getGenomeFileSpecs($) {
    my($db) = @_;
    
    my $genomeGlob = getDbConf($db, "genome");
    my @gfiles = glob($genomeGlob);
    if ($#gfiles < 0) {
        gbError("no files matching genome glob: $genomeGlob");
    }
    my $liftFile = getDbConfNo($db, "lift");
    my @lifts;
    if (defined($liftFile)) {
        @lifts = loadLiftFile($liftFile);
    }

    # genrate specs.
    my @fileSpecs;
    foreach my $genomeFile (@gfiles) {
        push(@fileSpecs, partitionGenomeFile($db, $genomeFile, @lifts));
    }
    return @fileSpecs;
}

# write a single blat job
sub writeBlatJob($$$$$$$) {
    my($jobFh, $expectedFh, $db, $genomeFile, $mondoSeqFile, $mrnaFa, $pslBaseDir) = @_;
    my $outPsl = getOutPslPath($genomeFile, $mondoSeqFile, $mrnaFa, $pslBaseDir);

    # make sure we don't overwrite output files
    if (defined($gOutPsls{$outPsl})) {
        gbError("BUG: multiple output files named $outPsl");
    }
    $gOutPsls{$outPsl} = 1;

    # add to list of expected
    print($expectedFh $outPsl . "\n");
    if (-e "$workDir/$outPsl") {
        if ($gbCommon::verbose) {
            print(STDERR "output psl already exists, skipping: $outPsl\n");
        }
        return;  # exists
    }
    # make mrna fa relative to workdir (make . not wild in RE)
    my $qWorkDir = $workDir;
    $qWorkDir =~ s/\./\\./g;
    my $qWorkDirRE = "^(\.\/)?$qWorkDir\/";
    $mrnaFa =~ s/$qWorkDirRE//;
        
    # if all the cluster, prefix with that dir.
    if (defined($clusterWorkDir)) {
        $mrnaFa = $clusterWorkDir . "/" . $mrnaFa;
    }
        
    my $cmd = $gbBlatPath;
    if (defined($mondoSeqFile)) {
        $cmd .= " -seqs " . $mondoSeqFile;
    }
    $cmd .= " $db $genomeFile $mrnaFa {check out exists $outPsl}\n";
    print $jobFh $cmd;
}

# generate blat jobs
sub genBlatJobs($$$@) {
    my($jobFh, $expectedFh, $genomeFilesRef, $mondoSeqFilesRef, $unaligned, $mrnaFasRef) = @_;
    my($release, $db, $update, $typeAccPrefix) = splitUnaligned($unaligned);
    
    # relative to work/align
    my $pslBaseDir = "$release/$db/$update/psl";

    foreach my $genomeFile (@{$genomeFilesRef}) {
        foreach my $mondoSeqFile (@{$mondoSeqFilesRef}) {
            foreach my $mrnaFa (@{$mrnaFasRef}) {
                writeBlatJob($jobFh, $expectedFh, $db, $genomeFile, $mondoSeqFile, $mrnaFa, $pslBaseDir);
            }
        }
    }
}

# generate jobs for on update. $mondoSeqFiles should be a list with one undef if
# not being used
sub genAlignUpdateJobs($$$$$$$) {
    my($jobFh, $expectedFh, $release, $db, $unaligned, $genomeFilesRef, $mondoSeqFilesRef) = @_;
    my $totalNumAlign = 0;
    if ($gbCommon::verbose) {
        print STDERR "gbAlignSetup: $unaligned\n";
    }
    my ($numAlign, @mrnaFas) = extractMRnaFastas($unaligned);
    if ($gbCommon::verbose) {
        print STDERR "  $numAlign unaligned\n";
    }
    if ($numAlign > 0) {
        genBlatJobs($jobFh, $expectedFh, $genomeFilesRef, $mondoSeqFilesRef, $unaligned, \@mrnaFas);
        $totalNumAlign += $numAlign;
    }
    return $totalNumAlign;
}

# Do all setup for blat alignment jobs for a release and update; extracting 
# sequences to align, checking for existing tmp output alignments, etc.
sub genAlignJobs($$$$$@) {
    my($jobFh, $expectedFh, $release, $db, $type, @orgCats) = @_;
    my @unalignedList = findUnaligned($release, $db, $type, @orgCats);
    my $totalNumAlign = 0;

    # different setups depending on if we have the mondoTwoBitParts conf option

    my $mondoNumParts = getDbConfUndef($db, "mondoTwoBitParts");
    my(@genomeFiles, @mondoSeqFiles);

    if (defined($mondoNumParts)) {
        my $seqFileDir = $release . "/mondo/" . $db;
        push(@genomeFiles, getDbConf($db, "genome"));
        @mondoSeqFiles = partitionMondoTwoBitFile($db, $genomeFiles[0], $mondoNumParts, $seqFileDir);
    } else {
        @genomeFiles = getGenomeFileSpecs($db);
        push(@mondoSeqFiles, undef);
    }
    foreach my $unaligned (@unalignedList) {
        $totalNumAlign += genAlignUpdateJobs($jobFh, $expectedFh, $release, $db, $unaligned, \@genomeFiles, \@mondoSeqFiles);
    }
    return $totalNumAlign;
}

# Entry, don't allow odd number of arguments.
setTaskName("gbAlignSetup");

# parse into globals used in program
while (($#ARGV >= 0) && ($ARGV[0] =~/^-.*/)) {
    my $opt = $ARGV[0];
    shift @ARGV;
    if ($opt =~ /^-workdir($|=)/) {
        $workDir = parseOptEq($opt);
    } elsif ($opt =~ /^-clusterWorkDir($|=)/) {
        $clusterWorkDir = parseOptEq($opt);
    } elsif ($opt eq "-noMigrate") {
        $noMigrate = 1;
    } elsif ($opt eq "-verbose") {
        $gbCommon::verbose = 1;
    } elsif ($opt =~ /^-verbose=/) {
        $gbCommon::verbose = parseOptEq($opt);
    } elsif ($opt =~ /^-srcDb($|=)/) {
        my $srcDb = parseOptEq($opt);
        if (!inList($srcDb, ("genbank", "refseq"))) {
            gbError("-srcDb must have a value of \"genbank\" or \"refseq\", got \"$srcDb\"");
        }
        push(@srcDbs, $srcDb);
    } elsif ($opt =~ /^-type($|=)/) {
        my $type = parseOptEq($opt);
        if (!inList($type, ("mrna", "est"))) {
            gbError("-type must have a value of \"mrna\" or \"est\", got \"$type\"");
        }
        push(@types, $type);
    } elsif ($opt =~ /^-orgCat($|=)/) {
        my $orgCat = parseOptEq($opt);
        if (!inList($orgCat, ("native", "xeno"))) {
            gbError("-orgCat must have a values of \"native\" or \"xeno\", got \"$orgCat\"");
        }
        push(@orgCats, $orgCat);
    } else {
        gbError("invalid option \"$opt\"");
    }
}

if ($#ARGV < 0) {
    gbError("wrong # args: $main::usage");
}

my @databases;
while ($#ARGV >= 0) {
    push(@databases, $ARGV[0]);
    shift @ARGV;
}

makeDir($workDir);

$gbBlatPath = callProg("sh -c 'which gbBlat'");
chomp($gbBlatPath);

# default options
if ($#srcDbs < 0) {
    @srcDbs = ("genbank", "refseq");
}
if ($#types < 0) {
    @types = ("mrna", "est");
}

# Get last releases, allow one to be missing for testing
my $gbRelease = undef;
if (inList("genbank", @srcDbs)) {
    $gbRelease = getLastRelease("processed", "genbank");
}

my $rsRelease = undef;
if (inList("refseq", @srcDbs)) {
    $rsRelease = getLastRelease("processed", "refseq");
}
if (!(defined($gbRelease) || defined($rsRelease))) {
    gbError("no data/processed/genbank.* or data/processed/refseq.* directories found in "
            . $cwd);
}

# setup jobs file
my $alignJobs = "$workDir/align.jobs";
my $alignJobsTmp = "$alignJobs.tmp";

if (-e $alignJobs) {
    gbError("job file exists, not overwriting: $alignJobs");
}
if (-e $alignJobsTmp) {
    gbError("tmp job file exists: $alignJobs");
}

open(JOBS, ">>", $alignJobsTmp)
    || gbError("can't create $alignJobsTmp");
my $jobFh = \*JOBS;  # gag..

# setup expected file
my $alignExpected = "$workDir/align.expected";
my $alignExpectedTmp = "$alignExpected.tmp";

open(EXPECTED, ">>", $alignExpectedTmp)
    || gbError("can't create $alignExpectedTmp");
my $expectedFh = \*EXPECTED;  # gag #2..

my $totalNumAlign = 0;

# GenBank releases
if (defined($gbRelease)) {
    foreach my $db (@databases) {
        if (inList("mrna", @types)) {
            $totalNumAlign += genAlignJobs($jobFh, $expectedFh, $gbRelease, $db, "mrna", @orgCats);
        }
        if (inList("est", @types)) {
            $totalNumAlign += genAlignJobs($jobFh, $expectedFh, $gbRelease, $db, "est", @orgCats);
        }
    }
}

# RefSeq releases
if (defined($rsRelease)) {
    foreach my $db (@databases) {
        $totalNumAlign += genAlignJobs($jobFh, $expectedFh, $rsRelease, $db, "mrna");
    }
}

print("numAlign: $totalNumAlign\n");
# install jobs and expected file.
close(EXPECTED) || die("close failed");
close(JOBS) || die("close failed");
if ($totalNumAlign > 0) {
    renameFile($alignExpectedTmp, $alignExpected);
    renameFile($alignJobsTmp, $alignJobs);
} else {
    unlink($alignExpectedTmp, $alignJobsTmp);
    
    # leave flag indicating nothing to align
    my $alignNone = "$workDir/align.none";
    open(NONE, ">$alignNone") || die("can't create $alignNone");
    close(NONE) || die("close failed");
}
