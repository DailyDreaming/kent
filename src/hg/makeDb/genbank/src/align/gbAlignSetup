#!/usr/bin/perl
#
# gbAlignSetup [options] database genomeGlob liftFile ...
#
# Do setup for the alignment step.
#
# Options:
#   -workdir=work/align - work directory where alignment is built.
#    See gbAlignStep for details;.
#
#   -clusterdir=dir - The directory where the files will exist on the
#    cluster. See gbAlignStep for details;.
#
#   -verbose=n - print details
#
#   -srcDb=name - Restrict the source database to either "genbank" or "refseq".
#
#   -type=name - Restrict the type of sequence processeed to either "mrna"
#    or "est".
#
# Arguments:
#   - database genomeGlob liftFile - Triples of database name, a glob
#     patttern (quoted to prevent shell expansion) of where to find the genome
#     contig or chromosome fasta or nib files, and the liftFile.  For example:
#
#       hg13 '/scratch/hg/gs.14/build31/trfFa.1204/NT_*.fa.trf'
#
#     the lift file is used to split up nibs.  If fasta files or whole nibs
#     are used, it is ignored and can be empty.
#
# Does:
#  - Find updates that are missing alignments in the latest releases for
#    each specified database. 
#  - Extract tmp fasta file to align into the alignment work directory.
#  - Produce a single parasol jobs file to do all of the alignments.
#  - This checks if the contig alignments exist in the work/align directory
#    before adding the job.  This allows this program to be re-run as a last
#    ditch way of restarting on failure.  Normally, using parasol to restart
#    the failed jobs is the way to recover.
#  - create a list of all expected PSL files.
#
use strict;
use warnings;
use File::Basename;
use FindBin;
use lib "$FindBin::Bin/../lib";
use gbCommon;

# Maximum size of an individual fasta file, in bytes.
my $maxFaSize = 64*1024*1024; # 64mb

# global table to make sure we don't generate output file more than
# once
my %gOutPsls;

# split unaligned string into it's component names
sub splitUnaligned($) {
    my($unaligned) = @_;
    my($release, $db, $update, $typeAccPrefix) = split(/\//, $unaligned);
    if (!defined($release)) {
        die("invalid unaligned spec: $unaligned");
    }
    return ($release, $db, $update, $typeAccPrefix);
}

# get unaligned for an update
sub getUpdateUnaligned($$$$) {
    my($release, $update, $db, $type) = @_;
    my %unaligned;
    my @gbIdxFiles = ($type eq "est")
        ? glob("data/processed/$release/$update/$type.*.gbidx")
        : glob("data/processed/$release/$update/$type.gbidx");

    foreach my $gbIdx (@gbIdxFiles) {
        # will produce both native and xeno indices (refseq only produces
        # native)
        my $typeAccPrefix = basename($gbIdx, ".gbidx");
        my $baseIdx = "data/aligned/$release/$db/$update/$typeAccPrefix";
        my $nativeAlIdx = "$baseIdx.native.alidx";
        my $xenoAlIdx = "$baseIdx.xeno.alidx";
        my $name = "$release/$db/$update/$typeAccPrefix";
        if (! (-e $nativeAlIdx && -e $xenoAlIdx)) {
            $unaligned{$name} = 1;
        }
    }
    return sort(keys(%unaligned));
}

# build list of release/db/update/typeAccPrefix that need to be aligned
# for a release.  Returned with updates sorted.
sub findUnaligned($$$) {
    my($release, $db, $type) = @_;
    my @unalignedList = ();
    foreach my $update (getUpdates("processed", $release)) {
        push(@unalignedList, getUpdateUnaligned($release, $update, $db, $type));
    }

    return @unalignedList;
}

# Extract fasta files of sequences to align for an update and type by running
# gbAlignGet. Return list with number of sequences to align and the fully
# qualified paths to the fasta files.
sub extractMRnaFastas($) {
    my($unaligned) = @_;
    my($release, $db, $update, $typeAccPrefix) = splitUnaligned($unaligned);

    # check if it already extracted
    my @alignsList = glob("$main::workDir/$unaligned.*.aligns");
    if ($#alignsList >= 0) {
        gbError("setup already done, don't know why we found: "
                . join(" ", @alignsList));
    }

    # run program to extract fasta files, get back count and number.
    my $cmd = "gbAlignGet";
    if ($maxFaSize > 0) {
        $cmd .= " -fasize=$maxFaSize";
    }
    if ($gbCommon::verbose) {
        $cmd .= " -verbose=$gbCommon::verbose";
    }
    $cmd .= " -workdir=$main::workDir $release $update $typeAccPrefix $db";
    my $out = callProg($cmd);
    my $numAlign;
    my @mrnaFas = ();
    
    foreach my $line (split('\n', $out)) {
        chomp($line);
        my @parts = split(' ',$line);
        if ($parts[0] eq "alignFa:") {
            push(@mrnaFas, $parts[1]);
        } elsif ($parts[0] eq "alignCnt:") {
            $numAlign = int($parts[1]);
        } else {
            gbError("unexpected line returned from \"$cmd\": $line");
        }
    }
    
    if (!defined($numAlign)) {
        gbError("numAligned not returned from \"$cmd\"");
    }
    if ((($numAlign == 0) && ($#mrnaFas >= 0))
        || (($numAlign > 0) && ($#mrnaFas < 0))) {
        gbError("numAlign ($numAlign) does not make sense with number of fastas ($#mrnaFas) returned from \"$cmd\"");
    }
    
    return ($numAlign, @mrnaFas);
}

# Create the path to the PSL (or other) output file.  This will output the
# files into subdirectories of a directory psl.  A multi-level tree is created
# to avoid too many files in a single directory, which drives NFS nuts.
#
# For human contig naming, an alignment of .../mrna.0.fa.gz and
# .../NT_035745.fa.trf will end up in:
#
#   $pslBaseDir/mrna.0/4/5/NT_035745.psl.gz
#
# For contig names in the form chr10_8, two directories are created by spliting
# on the `_', thus .../chr1_10.nib results in 
#
#   $pslBaseDir/mrna.0/chr1/10/chr1_10.psl.gz
#
# IMPORTANT NOTE: gbAlignFinish takes advantage of a one-to-one mapping between
# query file and the first directory level to make sorting more efficient, so
# don't change this with understanding what is going on.
#
sub getOutPslPath($$$) {
    my($genomeFile, $rnaFa, $pslBaseDir) = @_;
    my $rnaBase = basename($rnaFa, "\.fa\.gz");

    my $genomeBase;
    if ($genomeFile =~ /.*\.nib:.*:.*-.*/) {
        # nib subrange
        $genomeBase = basename($genomeFile);
        $genomeBase =~ s/^.*\.nib://;
        $genomeBase =~ s/:.*$//;
    } else {
        # fasta or full nib
        $genomeBase = basename($genomeFile, ("\.fa\.trf", "\.fa", "\.nib"));
    }
    my($l1,$l2);

    # get two directory levels, depending on contig naming convention:
    if ($genomeBase =~ /^chr.+_.+/) {
        my @names = split(/_/, $genomeBase);
        $l1 = $names[0];
        $l2 = join("_", @names[1 .. $#names]);
    } else {
        $l1 = substr($genomeBase, -2, 1);
        $l2 = substr($genomeBase, -1, 1);
    }
    my $outDir = "$pslBaseDir/$rnaBase/$l1/$l2";
    my $outPsl="$outDir/$genomeBase.psl.gz";
    return $outPsl;
}

# Partition a nib file using the lift file.
sub partitionNibFile($$) {
    my($db, $nibFile) = @_;
    my @nibSpecs;

    # Get chrom from nib path
    my $chrom = basename($nibFile);
    $chrom =~ s/\..*$//;
    
    # lift format: offset oldName oldSize newName newSize
    # old name maybe in the form 1/NT_034471
    my $liftFile = $main::dbLiftFiles{$db};
    open(NIBFH, $liftFile) || die("can't open $liftFile");
    my $line;
    my $lineCnt = 0;
    while (($line = <NIBFH>)) {
        $lineCnt++;
        if (!($line =~ /\#.*$/)) {
            my($offset, $oldName, $oldSize, $newName, $newSize) = split(/\t/,$line);
            if (!defined($newSize)) {
                die("lift file line must have at least 5 columns: line $lineCnt of $liftFile");
            }
            if ($newName eq $chrom) {
                $oldName =~ s/^.+\///;  # 1/NT_034471 => NT_034471

                # construct nibFile:seqId:start-end
                my $nibSpec = $nibFile . ":" . $oldName . ":"
                    . $offset . "-" . ($offset+$oldSize);
                push(@nibSpecs, $nibSpec);
            }
        }
    }
    close(NIBFH) || die("close failed");
    return @nibSpecs;
}

# Generate the list of genome target files.  For fasta files, this is a
# simple glob, for nib files, we use the lift file to generate subsequence
# requests to blat.
sub getGenomeFileSpecs($) {
    my($db) = @_;
    
    my $genomeGlob = $main::dbGenomGlobs{$db};
    my @gfiles = glob($genomeGlob);
    if ($#gfiles < 0) {
        gbError("no files matching genomeGlob: $genomeGlob");
    }

    # genrate specs, validating that node are generated twice.
    my @fileSpecs;
    foreach my $gfile (@gfiles) {
        # partation if a nib and we have a lift file, otherwise use the entire file
        if (($gfile =~ /.*\.nib$/) && defined($main::dbLiftFiles{$db})) {
            push(@fileSpecs, partitionNibFile($db, $gfile));
        } else {
            push(@fileSpecs, $gfile);
        }
    }
    return @fileSpecs;
}

# write a single blat job
sub writeBlatJob($$$$$$) {
    my($jobFh, $expectedFh, $db, $genomeFile, $mrnaFa, $pslBaseDir) = @_;
    my $outPsl = getOutPslPath($genomeFile, $mrnaFa, $pslBaseDir);

    # make sure we don't overwrite output files
    if (defined($gOutPsls{$outPsl})) {
        gbError("BUG: multiple output files named $outPsl");
    }
    $gOutPsls{$outPsl} = 1;

    # add to list of expected
    print($expectedFh $outPsl . "\n");
    if (-e "$main::workDir/$outPsl") {
        if ($gbCommon::verbose) {
            print(STDERR "output psl already exists, skipping: $outPsl\n");
        }
        return;  # exists
    }
    # make mrna fa relative to workdir (make . not wild in RE)
    my $qWorkDir = $main::workDir;
    $qWorkDir =~ s/\./\\./g;
    my $qWorkDirRE = "^(\.\/)?$qWorkDir\/";
    $mrnaFa =~ s/$qWorkDirRE//;
        
    # if all the cluster, prefix with that dir.
    if (defined($main::clusterWorkDir)) {
        $mrnaFa = $main::clusterWorkDir . "/" . $mrnaFa;
    }
        
    my $cmd = "$main::gbBlatPath";
    $cmd .= " $db $genomeFile $mrnaFa {check out exists $outPsl}\n";
    print $jobFh $cmd;
}

# Add alignment commands to a job file.  Check for existing files tmp
# output psls to allow rerunnign if needed.
sub genBlatJobs($$$@) {
    my($jobFh, $expectedFh, $unaligned, @mrnaFas) = @_;
    my($release, $db, $update, $typeAccPrefix) = splitUnaligned($unaligned);
    
    # relative to work/align
    my $pslBaseDir = "$release/$db/$update/psl";

    my @genomeFiles = getGenomeFileSpecs($db);
    foreach my $genomeFile (@genomeFiles) {
        foreach my $mrnaFa (@mrnaFas) {
            writeBlatJob($jobFh, $expectedFh, $db, $genomeFile, $mrnaFa, $pslBaseDir);
        }
    }
}

# Do all setup for blat alignment jobs for a release and update; extracting 
# sequences to align, checking for existing tmp output alignments, etc.
sub genAlignJobs($$$$$) {
    my($jobFh, $expectedFh, $release, $db, $type) = @_;
    my @unalignedList = findUnaligned($release, $db, $type);
    my $totalNumAlign = 0;
    foreach my $unaligned (@unalignedList) {
        if ($gbCommon::verbose) {
            print STDERR "gbAlignSetup: $unaligned\n";
        }
        my ($numAlign, @mrnaFas) = extractMRnaFastas($unaligned);
        if ($gbCommon::verbose) {
            print STDERR "  $numAlign unaligned\n";
        }
        if ($numAlign > 0) {
            genBlatJobs($jobFh, $expectedFh, $unaligned, @mrnaFas);
            $totalNumAlign += $numAlign;
        }
    }
    return $totalNumAlign;
}

# Entry, don't allow odd number of arguments.
setTaskName("gbAlignSetup");

# parse into globals used in program
$main::cwd = `pwd`;
chomp($main::cwd);
$main::workDir = "work/align";
@main::srcDbs = ();
@main::types = ();
while (($#ARGV >= 0) && ($ARGV[0] =~/^-.*/)) {
    my $opt = $ARGV[0];
    shift @ARGV;
    if ($opt =~ /^-workdir($|=)/) {
        $main::workDir = parseOptEq($opt);
    } elsif ($opt eq "-verbose") {
        $gbCommon::verbose = 1;
    } elsif ($opt =~ /^-verbose=/) {
        $gbCommon::verbose = parseOptEq($opt);
    } elsif ($opt =~ /^-clusterdir($|=)/) {
        $main::clusterDir = parseOptEq($opt);
    } elsif ($opt =~ /^-srcDb($|=)/) {
        my $srcDb = parseOptEq($opt);
        if (!inList($srcDb, ("genbank", "refseq"))) {
            gbError("-srcDb must have a value of \"genbank\" or \"refseq\", got \"$srcDb\"");
        }
        push(@main::srcDbs, $srcDb);
    } elsif ($opt =~ /^-type($|=)/) {
        my $type = parseOptEq($opt);
        if (!inList($type, ("mrna", "est"))) {
            gbError("-type must have a value of \"mrna\" or \"est\", got \"$type\"");
        }
        push(@main::types, $type);
    } else {
        gbError("invalid option \"$opt\"");
    }
}

if (($#ARGV < 1) || (($#ARGV+1) % 3) != 0) {
    gbError("wrong # args: gbAlignSetup [options] database genomeGlob liftFile ...");
}

my @databases;
while ($#ARGV >= 0) {
    my $db = $ARGV[0];
    push(@databases, $db);
    shift @ARGV;
    $main::dbGenomGlobs{$db} = $ARGV[0];
    shift @ARGV;
    if ($ARGV[0] ne "") {
        $main::dbLiftFiles{$db} = $ARGV[0];
    }
    shift @ARGV;
}

$main::gbBlatPath = callProg("sh -c 'which gbBlat'");
chomp($main::gbBlatPath);

# default options
if ($#main::srcDbs < 0) {
    @main::srcDbs = ("genbank", "refseq");
}
if ($#main::types < 0) {
    @main::types = ("mrna", "est");
}
$main::clusterWorkDir = undef;
if (defined($main::clusterDir)) {
    # use last two directories in workDir on cluster
    $main::clusterWorkDir = $main::clusterDir . "/"
        . basename(dirname($main::workDir)) . "/"
        . basename($main::workDir);
}

makeDir($main::workDir);

# Get last releases, allow one to be missing for testing
my $gbRelease = undef;
if (inList("genbank", @main::srcDbs)) {
    $gbRelease = getLastRelease("processed", "genbank");
}

my $rsRelease = undef;
if (inList("refseq", @main::srcDbs)) {
    $rsRelease = getLastRelease("processed", "refseq");
}
if (!(defined($gbRelease) || defined($rsRelease))) {
    gbError("no data/processed/genbank.* or data/processed/refseq.* directories found in "
            . $main::cwd);
}

# setup jobs file
my $alignJobs = "$main::workDir/align.jobs";
my $alignJobsTmp = "$alignJobs.tmp";

if (-e $alignJobs) {
    gbError("job file exists, not overwriting: $alignJobs");
}
if (-e $alignJobsTmp) {
    gbError("tmp job file exists: $alignJobs");
}

open(JOBS, ">>", $alignJobsTmp)
    || gbError("can't create $alignJobsTmp");
my $jobFh = \*JOBS;  # gag..

# setup expected file
my $alignExpected = "$main::workDir/align.expected";
my $alignExpectedTmp = "$alignExpected.tmp";

open(EXPECTED, ">>", $alignExpectedTmp)
    || gbError("can't create $alignExpectedTmp");
my $expectedFh = \*EXPECTED;  # gag #2..

my $totalNumAlign = 0;

# GenBank releases
if (defined($gbRelease)) {
    foreach my $db (@databases) {
        if (inList("mrna", @main::types)) {
            $totalNumAlign += genAlignJobs($jobFh, $expectedFh, $gbRelease, $db, "mrna");
        }
        if (inList("est", @main::types)) {
            $totalNumAlign += genAlignJobs($jobFh, $expectedFh, $gbRelease, $db, "est");
        }
    }
}

# RefSeq releases
if (defined($rsRelease)) {
    foreach my $db (@databases) {
        $totalNumAlign += genAlignJobs($jobFh, $expectedFh, $rsRelease, $db, "mrna");
    }
}

print("numAlign: $totalNumAlign\n");
# install jobs and expected file.
close(EXPECTED) || die("close failed");
close(JOBS) || die("close failed");
if ($totalNumAlign > 0) {
    renameFile($alignExpectedTmp, $alignExpected);
    renameFile($alignJobsTmp, $alignJobs);
} else {
    unlink($alignExpectedTmp, $alignJobsTmp);
    
    # leave flag indicating nothing to align
    my $alignNone = "$main::workDir/align.none";
    open(NONE, ">$alignNone") || die("can't create $alignNone");
    close(NONE) || die("close failed");
}
