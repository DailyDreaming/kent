#!/usr/bin/perl

$main::usage="
gbAlignSetup [options] database ...

Do setup for the alignment step.

Options:
  -workdir=work/align - work directory where alignment is built.
   See gbAlignStep for details;.

  -clusterWorkDir=dir - location of work directory on cluster.

  -verbose=n - print details

  -srcDb=name - Restrict the source database to either \"genbank\" or \"refseq\".

  -type=name - Restrict the type of sequence processeed to either \"mrna\"
   or \"est\".

  -orgCat=name - Restrict type of sequences to processe to native or xeon
   If not speicifed, categories that are to be loaded are used from
   genbank.conf.  Maybe repeated.

  -noMigrate - Don't migrate alignments.

Arguments:
  - database - databases to align

Obtains other parameters from etc/genbank.conf:

- $db.genome - a glob pattern of where to find the genome
   contig or chromosome fasta, nib, or 2bit files on the cluster.
   For example: 
     hg13.genome = /scratch/hg/gs.14/build31/trfFa.1204/NT_*.fa.trf

- $db.lift - the lift file is used to split up nibs.  If fasta files or
   whole nibs are used, it is ignored and can be empty or no.

Does:
   - Find updates that are missing alignments in the latest releases for
     each specified database. 
   - Extract tmp fasta file to align into the alignment work directory.
   - Produce a single parasol jobs file to do all of the alignments.
   - This checks if the contig alignments exist in the work/align directory
     before adding the job.  This allows this program to be re-run as a last
     ditch way of restarting on failure.  Normally, using parasol to restart
     the failed jobs is the way to recover.
   - create a list of all expected PSL files.";

#
# $Id: gbAlignSetup,v 1.10 2004/10/16 05:02:49 markd Exp $
#
use strict;
use warnings;
use File::Basename;
use FindBin;
use lib "$FindBin::Bin/../lib";
use gbCommon;

# Maximum size of an individual fasta file, in bytes.
my $maxFaSize = 64*1024*1024; # 64mb

# global table to make sure we don't generate output file more than
# once
my %gOutPsls;

# other globals
my $workDir = "work/align";
my $clusterWorkDir;
my $gbBlatPath;
my $srcDbs;
my $cwd = `pwd`;
chomp($cwd);
my @srcDbs;
my @types;
my @orgCats;
my $noMigrate = 0;


# determine if a file is a nib file.
sub isNibFile($) {
    my($genomeFile) = @_;
    return ($genomeFile =~ /\.nib$/);
}

# get chrom for a NIB
sub getNibChrom($) {
    my($genomeFile) = @_;
    my $chrom = $genomeFile;
    $chrom =~ s/^.+\///;
    $chrom =~ s/\.nib$//;
    return $chrom;
}

# get the size of a chromosome from a nib
sub getNibSize($) {
    my($nibFile) = @_;
    my $nibSizeOut = callProg("nibSize $nibFile", 1);
    chomp($nibSizeOut);
    my @nibSizeInfo = split(/\t/, $nibSizeOut);
    return $nibSizeInfo[2];
}

# determine if a file is a 2bit file.
sub isTwoBitFile($) {
    my($genomeFile) = @_;
    return ($genomeFile =~ /\.2bit$/);
}

# get chroms and size in a twobit file.  This is does in one
# pass because there can be a lot of scaffolds in a twobit
# These are return in pairs because perl is such a pain.
sub getTwoBitChromsSizes($) {
    my($genomeFile) = @_;
    my @chromsSizes;
    my $twoBitOut = callProg("twoBitInfo $genomeFile stdout");
    foreach my $line (split(/\n/, $twoBitOut)) {
        my @row = split(/\t/, $line);
        push(@chromsSizes, $row[0]);
        push(@chromsSizes, $row[1]);
    }
    return @chromsSizes;
}

# split unaligned string into it's component names
# $release/$db/$update/$typeAccPrefix/$orgCatsStr
# $orgCatsStr  = native,xeno
sub splitUnaligned($) {
    my($unaligned) = @_;
    my($release, $db, $update, $typeAccPrefix, $orgCatsStr) = split(/\//, $unaligned);
    if (!defined($release)) {
        die("invalid unaligned spec: $unaligned");
    }
    my @orgCats = split(",", $orgCatsStr);
    return ($release, $db, $update, $typeAccPrefix, @orgCats);
}

# get unaligned for an update
sub getUpdateUnaligned($$$$@) {
    my($release, $update, $db, $type, @orgCats) = @_;
    my %unaligned;
    my @gbIdxFiles = ($type eq "est")
        ? glob("data/processed/$release/$update/$type.*.gbidx")
        : glob("data/processed/$release/$update/$type.gbidx");

    foreach my $gbIdx (@gbIdxFiles) {
        # will produce both native and xeno indices
        my $typeAccPrefix = basename($gbIdx, ".gbidx");
        my $baseIdx = "data/aligned/$release/$db/$update/$typeAccPrefix";
        my $nativeAlIdx = "$baseIdx.native.alidx";
        my $xenoAlIdx = "$baseIdx.xeno.alidx";
        my @missingOrgCats;
        if (inList("native", @orgCats) && !-e $nativeAlIdx) {
            push(@missingOrgCats, "native");
        }
        if (inList("xeno", @orgCats) && !-e $xenoAlIdx) {
            push(@missingOrgCats, "xeno");
        }
        if ($#missingOrgCats >= 0) {
            my $name = "$release/$db/$update/$typeAccPrefix/"
                . join(",", @missingOrgCats);
            $unaligned{$name} = 1;
        }
    }
    return sort(keys(%unaligned));
}

# build list of release/db/update/typeAccPrefix that need to be aligned
# for a release.  Returned with updates sorted.
sub findUnaligned($$$@) {
    my($release, $db, $type, @orgCats) = @_;
    my $srcDb = $release;
    $srcDb =~ s/\..+$//;
    if ($#orgCats < 0) {
        # set orgCats from config
        if (getDbConf($db, "$srcDb.$type.native.load") eq "yes") {
            push(@orgCats, "native");
        }
        if (getDbConf($db, "$srcDb.$type.xeno.load") eq "yes") {
            push(@orgCats, "xeno");
        }
    }

    my @unalignedList = ();
    foreach my $update (getUpdates("processed", $release)) {
        push(@unalignedList, getUpdateUnaligned($release, $update, $db, $type, @orgCats));
    }

    return @unalignedList;
}

# Extract fasta files of sequences to align for an update and type by running
# gbAlignGet. Return list with number of sequences to align and the fully
# qualified paths to the fasta files.
sub extractMRnaFastas($) {
    my($unaligned) = @_;
    my($release, $db, $update, $typeAccPrefix, @orgCats) = splitUnaligned($unaligned);

    # check if it already extracted
    my @alignsList = glob("$workDir/$unaligned.*.aligns");
    if ($#alignsList >= 0) {
        gbError("setup already done, don't know why we found: "
                . join(" ", @alignsList));
    }

    # run program to extract fasta files, get back count and number.
    my $cmd = "gbAlignGet";
    if ($maxFaSize > 0) {
        $cmd .= " -fasize=$maxFaSize";
    }
    if ($gbCommon::verbose) {
        $cmd .= " -verbose=$gbCommon::verbose";
    }
    if ($noMigrate) {
        $cmd .= " -noMigrate";
    }
    $cmd .= " -workdir=$workDir -orgCats=" . join(",", @orgCats)
        . " $release $update $typeAccPrefix $db";
    my $out = callProg($cmd);
    my $numAlign;
    my @mrnaFas = ();
    
    foreach my $line (split('\n', $out)) {
        chomp($line);
        my @parts = split(' ',$line);
        if ($parts[0] eq "alignFa:") {
            push(@mrnaFas, $parts[1]);
        } elsif ($parts[0] eq "alignCnt:") {
            $numAlign = int($parts[1]);
        } else {
            gbError("unexpected line returned from \"$cmd\": $line");
        }
    }
    
    if (!defined($numAlign)) {
        gbError("numAligned not returned from \"$cmd\"");
    }
    if ((($numAlign == 0) && ($#mrnaFas >= 0))
        || (($numAlign > 0) && ($#mrnaFas < 0))) {
        gbError("numAlign ($numAlign) does not make sense with number of fastas ($#mrnaFas) returned from \"$cmd\"");
    }
    
    return ($numAlign, @mrnaFas);
}

# parse NIB subrange file references for getOutPslPath
sub parseNibSubrangePath($) {
    my($nibBase) = @_;

    # build33/chromTrfMixedNib/chr1.nib:50000-217280
    #   dir1 is chrom
    #   dir2 is first digit of start
    #   base is chr:start-end
    my($chrom, $range) = ($nibBase =~ /^(.+)\.nib:(.+)$/);

    return ($chrom, substr($range, 0, 1), $chrom . ":" . $range);
}

# parse twobit subrange file references for getOutPslPath
sub parseTwoBitSubrangePath($) {
    my($twoBitBase) = @_;

    # build33/hg15.2bit:chr1:50000-217280
    #   dir1 is chrom
    #   dir2 is first digit of start
    #   base is chr:start-end
    my($chrom, $range) = ($twoBitBase =~ /^.+.2bit:(.+):(.+)$/);

    return ($chrom, substr($range, 0, 1), $chrom . ":" . $range);
}

# parse a fasta or full nib file path for getOutPslPath
sub parseFullFilePath($) {
    my($filePath) = @_;
    my($dir1, $dir2);

    my $fileBase = basename($filePath, ("\.fa\.trf", "\.fa", "\.nib", "\.2bit"));
    if ($dir1 =~ /.+_.+/) {
        # form dirs from name part
        ($dir1, $dir2) = split(/_/, $dir1);
    } else {
        # use first and last char
        $dir1 = substr($fileBase, 0, 1);
        $dir2 = substr($fileBase, -1, 1);
    }
    return ($dir1, $dir2, $fileBase);
}

# Create the path to the PSL (or other) output file.  This will output the
# files into subdirectories of a directory psl.  A multi-level tree is created
# to avoid too many files in a single directory, which drives NFS nuts.
# care is also be take to generate unique names (which is sanity checked
# later).
#
# An alignment of .../mrna.0.fa and  .../NT_035745.fa.trf will end up in:
#
#   $pslBaseDir/mrna.0/4/5/NT_035745.psl
#
# The way the directory names are derived depends on the the genome file
# name:
#
#    NT_035745.fa.trf -> 4/5/NT_035745.psl
#    chr1_10.nib -> chr1/10/chr1_10.psl
#    chr1.nib:207000000-217000000 -> chr1/2/0/chr1.psl
#    
# IMPORTANT NOTE: gbAlignFinish takes advantage of a one-to-one mapping between
# query file and the first directory level to make sorting more efficient, so
# don't change this with understanding what is going on.
#
sub getOutPslPath($$$) {
    my($genomeFile, $rnaFa, $pslBaseDir) = @_;
    my $rnaBase = basename($rnaFa, "\.fa");
    my $genomeBase = basename($genomeFile);

    my($dir1, $dir2, $base);

    if ($genomeBase =~ /^.+\.nib:.+$/) {
        ($dir1, $dir2, $base) = parseNibSubrangePath($genomeBase);
    } elsif ($genomeBase =~ /^.+\.2bit:.+$/) {
        ($dir1, $dir2, $base) = parseTwoBitSubrangePath($genomeBase);
    } else {
        ($dir1, $dir2, $base) = parseFullFilePath($genomeFile);
    }
    return "$pslBaseDir/$rnaBase/$dir1/$dir2/$base.psl";
}

# load a lift file into a list of hash-refs
sub loadLiftFile($) {
    my($liftFile) = @_;

    # lift format: offset oldName oldSize newName newSize
    # old name maybe in the form 1/NT_034471
    open(LIFTFH, $liftFile) || die("can't open $liftFile");
    my(@lifts);
    my $line;
    my $lineCnt = 0;
    while (($line = <LIFTFH>)) {
        chomp($line);
        $lineCnt++;
        if (!($line =~ /\#.*$/)) {
            my($offset, $oldName, $oldSize, $newName, $newSize) = split(/\t/,$line);
            if (!defined($newSize)) {
                die("$liftFile:$lineCnt: lift file line must have at least 5 tab-separated columns");
            }
            if ($oldName ne "gap") {
                $oldName =~ s/^.+\///;  # 1/NT_034471 => NT_034471
                my $row = {
                    'offset' => $offset,
                    'oldName' => $oldName,
                    'oldSize' => $oldSize,
                    'newName' => $newName,
                    'newSize' => $newSize,
                };
                push(@lifts, $row);
            }
        }
    }
    close(LIFTFH) || die("close failed");

    return @lifts;
}

# get lifts for a chrom, sorted in assending offset order
sub getChromLifts($@) {
    my($chrom, @lifts) = @_;

    my(@chromLifts);
    for my $lift (@lifts) {
        if ($lift->{newName} eq $chrom) {
            push(@chromLifts, $lift);
        }
    }
    # look, more syntax (gag)
    @chromLifts = sort {$a->{offset} <=> $b->{offset}} @chromLifts;

    return @chromLifts;
}

# Partition part or all of a genome file into overlaping (or non-overlapping)
# ranges.  This maybe called on an entire chromosome on an ungapped range.
sub partitionRange($$$$$$$) {
    my($db, $genomeFile, $chrom, $start, $end, $winSize, $winOverlap) = @_;
    my @specs;

    my $winStart = $start;
    while ($winStart < $end) {
        # get window
        my $winEnd = $winStart + $winSize;
        if ($winEnd > $end) {
            $winEnd = $end;
        } elsif ($winEnd+$winOverlap >= $end)  {
            # next overlap will take us to end, just included it now
            $winEnd = $end
        }
        if ($winEnd <= $winStart) {
            die("partitionRange: confused window $winStart to $winEnd");
        }

        # construct subrange spec
        my $spec;
        if (isNibFile($genomeFile)) {
            $spec = $genomeFile . ":" . $winStart . "-" . $winEnd;
        } else {
            # include chrom name for 2bit
            $spec = $genomeFile . ":" . $chrom . ":" . $winStart . "-" . $winEnd;
        }
        push(@specs, $spec);

        # advance window with overlap.
        $winStart += ($winSize - $winOverlap);
    }
    return @specs;
}

# Partition a genome file and chromosome using lifts to skip gaps.
sub partitionWithLift($$$$@) {
    my($db, $genomeFile, $chrom, $chromSize, @lifts) = @_;
    my $winSize = getDbConf($db, "align.window");
    if ($winSize <= 0) {
        $winSize = $chromSize;
    }
    my $winOverlap = getDbConf($db, "align.overlap");
    my @specs;
    
    foreach my $lift (getChromLifts($chrom, @lifts)) {
        my @rspec = partitionRange($db, $genomeFile, $chrom,
                                   $lift->{offset}, $lift->{offset}+$lift->{oldSize},
                                   $winSize, $winOverlap);
        push(@specs, @rspec);
    }
    return @specs;
}


# Partition a genome file by windows across a whole chromosome
sub partitionByWindows($$$$) {
    my($db, $genomeFile, $chrom, $chromSize) = @_;
    my $winSize = getDbConf($db, "align.window");
    if ($winSize <= 0) {
        $winSize = $chromSize;
    }
    my $winOverlap = getDbConf($db, "align.overlap");
    return partitionRange($db, $genomeFile, $chrom, 0, $chromSize,
                          $winSize, $winOverlap);
}

# partition a nib file into a list of fileSepces
sub partitionNibFile($$@) {
    my($db, $nibFile, @lifts) = @_;
    my @fileSpecs;
    foreach my $chrom (getNibChrom($nibFile)) {
        if ($#lifts >= 0) {
            push(@fileSpecs,
                 partitionWithLift($db, $nibFile, $chrom, getNibSize($nibFile), @lifts));
        } else {
            push(@fileSpecs,
                 partitionByWindows($db, $nibFile, $chrom, getNibSize($nibFile)));
        }
    }
    return @fileSpecs;
}

# partition a 2bit file into a list of fileSpecs
sub partitionTwoBitFile($$@) {
    my($db, $twoBitFile, @lifts) = @_;
    my @fileSpecs;
    # gets a list of pairs
    my @chromsSizes = getTwoBitChromsSizes($twoBitFile);
    for (my $i = 0; $i <= $#chromsSizes; $i += 2) {
        my $chrom = $chromsSizes[$i];
        my $chromSize = $chromsSizes[$i+1];
        if ($#lifts >= 0) {
            push(@fileSpecs,
                 partitionWithLift($db, $twoBitFile, $chrom, $chromSize, @lifts));
        } else {
            push(@fileSpecs,
                 partitionByWindows($db, $twoBitFile, $chrom, $chromSize));
        }
    }
    return @fileSpecs;
}

# partition a single genome file into a list of fileSepces
sub partitionGenomeFile($$@) {
    my($db, $genomeFile, @lifts) = @_;
    my @fileSpecs;
    # partition if we have a file format that supprot subrange spec.
    if (isNibFile($genomeFile)) {
        push(@fileSpecs, partitionNibFile($db, $genomeFile, @lifts));
    } elsif (isTwoBitFile($genomeFile)) {
        push(@fileSpecs, partitionTwoBitFile($db, $genomeFile, @lifts));
    } else {
        push(@fileSpecs, $genomeFile);
    }
    return @fileSpecs;
}

# Generate the list of genome target files.  For fasta files, this is a
# simple glob, for nib files, we use the lift file to generate subsequence
# requests to blat.
sub getGenomeFileSpecs($) {
    my($db) = @_;
    
    my $genomeGlob = getDbConf($db, "genome");
    my @gfiles = glob($genomeGlob);
    if ($#gfiles < 0) {
        gbError("no files matching genome glob: $genomeGlob");
    }
    my $liftFile = getDbConfNo($db, "lift");
    my @lifts;
    if (defined($liftFile)) {
        @lifts = loadLiftFile($liftFile);
    }

    # genrate specs, validating that none are generated twice.
    my @fileSpecs;
    foreach my $genomeFile (@gfiles) {
        push(@fileSpecs, partitionGenomeFile($db, $genomeFile, @lifts));
    }
    return @fileSpecs;
}

# write a single blat job
sub writeBlatJob($$$$$$) {
    my($jobFh, $expectedFh, $db, $genomeFile, $mrnaFa, $pslBaseDir) = @_;
    my $outPsl = getOutPslPath($genomeFile, $mrnaFa, $pslBaseDir);

    # make sure we don't overwrite output files
    if (defined($gOutPsls{$outPsl})) {
        gbError("BUG: multiple output files named $outPsl");
    }
    $gOutPsls{$outPsl} = 1;

    # add to list of expected
    print($expectedFh $outPsl . "\n");
    if (-e "$workDir/$outPsl") {
        if ($gbCommon::verbose) {
            print(STDERR "output psl already exists, skipping: $outPsl\n");
        }
        return;  # exists
    }
    # make mrna fa relative to workdir (make . not wild in RE)
    my $qWorkDir = $workDir;
    $qWorkDir =~ s/\./\\./g;
    my $qWorkDirRE = "^(\.\/)?$qWorkDir\/";
    $mrnaFa =~ s/$qWorkDirRE//;
        
    # if all the cluster, prefix with that dir.
    if (defined($clusterWorkDir)) {
        $mrnaFa = $clusterWorkDir . "/" . $mrnaFa;
    }
        
    my $cmd = $gbBlatPath;
    $cmd .= " $db $genomeFile $mrnaFa {check out exists $outPsl}\n";
    print $jobFh $cmd;
}

# Add alignment commands to a job file.  Check for existing files tmp
# output psls to allow rerunnign if needed.
sub genBlatJobs($$$@) {
    my($jobFh, $expectedFh, $unaligned, @mrnaFas) = @_;
    my($release, $db, $update, $typeAccPrefix) = splitUnaligned($unaligned);
    
    # relative to work/align
    my $pslBaseDir = "$release/$db/$update/psl";

    my @genomeFiles = getGenomeFileSpecs($db);
    foreach my $genomeFile (@genomeFiles) {
        foreach my $mrnaFa (@mrnaFas) {
            writeBlatJob($jobFh, $expectedFh, $db, $genomeFile, $mrnaFa, $pslBaseDir);
        }
    }
}

# Do all setup for blat alignment jobs for a release and update; extracting 
# sequences to align, checking for existing tmp output alignments, etc.
sub genAlignJobs($$$$$@) {
    my($jobFh, $expectedFh, $release, $db, $type, @orgCats) = @_;
    my @unalignedList = findUnaligned($release, $db, $type, @orgCats);
    my $totalNumAlign = 0;
    foreach my $unaligned (@unalignedList) {
        if ($gbCommon::verbose) {
            print STDERR "gbAlignSetup: $unaligned\n";
        }
        my ($numAlign, @mrnaFas) = extractMRnaFastas($unaligned);
        if ($gbCommon::verbose) {
            print STDERR "  $numAlign unaligned\n";
        }
        if ($numAlign > 0) {
            genBlatJobs($jobFh, $expectedFh, $unaligned, @mrnaFas);
            $totalNumAlign += $numAlign;
        }
    }
    return $totalNumAlign;
}

# Entry, don't allow odd number of arguments.
setTaskName("gbAlignSetup");

# parse into globals used in program
while (($#ARGV >= 0) && ($ARGV[0] =~/^-.*/)) {
    my $opt = $ARGV[0];
    shift @ARGV;
    if ($opt =~ /^-workdir($|=)/) {
        $workDir = parseOptEq($opt);
    } elsif ($opt =~ /^-clusterWorkDir($|=)/) {
        $clusterWorkDir = parseOptEq($opt);
    } elsif ($opt eq "-noMigrate") {
        $noMigrate = 1;
    } elsif ($opt eq "-verbose") {
        $gbCommon::verbose = 1;
    } elsif ($opt =~ /^-verbose=/) {
        $gbCommon::verbose = parseOptEq($opt);
    } elsif ($opt =~ /^-srcDb($|=)/) {
        my $srcDb = parseOptEq($opt);
        if (!inList($srcDb, ("genbank", "refseq"))) {
            gbError("-srcDb must have a value of \"genbank\" or \"refseq\", got \"$srcDb\"");
        }
        push(@srcDbs, $srcDb);
    } elsif ($opt =~ /^-type($|=)/) {
        my $type = parseOptEq($opt);
        if (!inList($type, ("mrna", "est"))) {
            gbError("-type must have a value of \"mrna\" or \"est\", got \"$type\"");
        }
        push(@types, $type);
    } elsif ($opt =~ /^-orgCat($|=)/) {
        my $orgCat = parseOptEq($opt);
        if (!inList($orgCat, ("native", "xeno"))) {
            gbError("-orgCat must have a values of \"native\" or \"xeno\", got \"$orgCat\"");
        }
        push(@orgCats, $orgCat);
    } else {
        gbError("invalid option \"$opt\"");
    }
}

if ($#ARGV < 0) {
    gbError("wrong # args: $main::usage");
}

my @databases;
while ($#ARGV >= 0) {
    push(@databases, $ARGV[0]);
    shift @ARGV;
}

makeDir($workDir);

$gbBlatPath = callProg("sh -c 'which gbBlat'");
chomp($gbBlatPath);

# default options
if ($#srcDbs < 0) {
    @srcDbs = ("genbank", "refseq");
}
if ($#types < 0) {
    @types = ("mrna", "est");
}

# for now, make sure windows are not in use.
for my $db (@databases) {
    if (getDbConf($db, "align.window") > 0) {
        die("align.window not debugged, must be zero");
    }
    if (getDbConf($db, "align.overlap") > 0) {
        die("align.overlap not debugged, must be zero");
    }
}

# Get last releases, allow one to be missing for testing
my $gbRelease = undef;
if (inList("genbank", @srcDbs)) {
    $gbRelease = getLastRelease("processed", "genbank");
}

my $rsRelease = undef;
if (inList("refseq", @srcDbs)) {
    $rsRelease = getLastRelease("processed", "refseq");
}
if (!(defined($gbRelease) || defined($rsRelease))) {
    gbError("no data/processed/genbank.* or data/processed/refseq.* directories found in "
            . $cwd);
}

# setup jobs file
my $alignJobs = "$workDir/align.jobs";
my $alignJobsTmp = "$alignJobs.tmp";

if (-e $alignJobs) {
    gbError("job file exists, not overwriting: $alignJobs");
}
if (-e $alignJobsTmp) {
    gbError("tmp job file exists: $alignJobs");
}

open(JOBS, ">>", $alignJobsTmp)
    || gbError("can't create $alignJobsTmp");
my $jobFh = \*JOBS;  # gag..

# setup expected file
my $alignExpected = "$workDir/align.expected";
my $alignExpectedTmp = "$alignExpected.tmp";

open(EXPECTED, ">>", $alignExpectedTmp)
    || gbError("can't create $alignExpectedTmp");
my $expectedFh = \*EXPECTED;  # gag #2..

my $totalNumAlign = 0;

# GenBank releases
if (defined($gbRelease)) {
    foreach my $db (@databases) {
        if (inList("mrna", @types)) {
            $totalNumAlign += genAlignJobs($jobFh, $expectedFh, $gbRelease, $db, "mrna", @orgCats);
        }
        if (inList("est", @types)) {
            $totalNumAlign += genAlignJobs($jobFh, $expectedFh, $gbRelease, $db, "est", @orgCats);
        }
    }
}

# RefSeq releases
if (defined($rsRelease)) {
    foreach my $db (@databases) {
        $totalNumAlign += genAlignJobs($jobFh, $expectedFh, $rsRelease, $db, "mrna");
    }
}

print("numAlign: $totalNumAlign\n");
# install jobs and expected file.
close(EXPECTED) || die("close failed");
close(JOBS) || die("close failed");
if ($totalNumAlign > 0) {
    renameFile($alignExpectedTmp, $alignExpected);
    renameFile($alignJobsTmp, $alignJobs);
} else {
    unlink($alignExpectedTmp, $alignJobsTmp);
    
    # leave flag indicating nothing to align
    my $alignNone = "$workDir/align.none";
    open(NONE, ">$alignNone") || die("can't create $alignNone");
    close(NONE) || die("close failed");
}
