#!/usr/bin/perl
#
# gbAlignFinish [options] database liftFile ...
#
# Finish up the BLAT alignments, combining and lifting PSL files.
#
# Options:
#   -workdir=work/align - Must be the same as specified for gbAlignSetup.
#   -verbose - print details.
#   -keep - keep tmp files for debugging.
#
# Arguments:
#   - database liftFile - Pairs of database name and a lift file for the
#     assembly contigs.  All database that were aligned must be specified.
#     The liftFile can be empty if lifting should not be done.
#
use strict;
use warnings;
use File::Basename;
use FindBin;
use lib "$FindBin::Bin/../lib";
use gbCommon;

# get dirs+type+accPrefixes for a work directory
sub getUpdWorkDirPrefixes($) {
    my($updWorkDir) = @_;
    my %dirPrefixes;
    # use orgCat.aligns files to get prefixes, excluding category.
    foreach my $aln (glob("$updWorkDir/*.native.aligns"),
                      glob("$updWorkDir/*.xeno.aligns")) {
        my $dirPrefix = dirname($aln) . "/"
            . basename($aln, ("\.native\.aligns", "\.xeno\.aligns"));
        $dirPrefixes{$dirPrefix} = 1;
    }
    return sort(keys(%dirPrefixes));
}

# Build list of update dirs with type and accPrefixes:
#    work/align/genbank.132.0/hg13/full/mrna
#    work/align/genbank.132.0/hg13/full/est.aj
# result is sorted by update so that full is returned first, followed
# by sorted dailies.  My return an empty list if none are being aligned
# for this database.
sub getDirsPrefixes($) {
    my($db) = @_;
    # find based on fasta files used to align
    my @dirPrefixes = ();
    # loop over releases and databases
    for my $relDbWorkDir ((glob("$main::workDir/genbank.*/$db"),
                           glob("$main::workDir/refseq.*/$db"))) {
        # loop over updates, full first
        foreach my $updWorkDir ((glob("$relDbWorkDir/full"),
                                 sort(glob("$relDbWorkDir/daily.*")))) {
            push(@dirPrefixes, getUpdWorkDirPrefixes($updWorkDir));
        }
    }
    return @dirPrefixes;
}

# Parse an update directory and file prefix (can be work dir or aligned dir)
#    work/align/genbank.132.0/hg13test/full
sub parseDirPrefix($) {
    my($dirPrefix) = @_;

    my $typePrefix = basename($dirPrefix);
    my $dir = dirname($dirPrefix);
    my $update = basename($dir);
    $dir = dirname($dir);
    my $database = basename($dir);
    $dir = dirname($dir);
    my $release = basename($dir);

    my $type = $typePrefix;
    $type =~ s/\..*$//;
    return ($release, $database, $update, $type, $typePrefix);
}

# Determine pslReps parameters to use.  Return undef to skip PSL reps.
sub getPslRepsArgs($$) {
    my ($release, $typePrefix) = @_;
    
    # parse typePrefix, dropping accPrefix
    my @typeList = split(/\./, $typePrefix);
    my $type = $typeList[0];
    my $orgCat = ($type eq "est") ? $typeList[2] : $typeList[1];

    if ($release =~ /^refseq\..*/) {
        # RefSeq:
        if ($orgCat eq "native") {
            return "-minCover=0.15 -sizeMatters -minAli=0.96 -nearTop=0.001";
        } elsif ($orgCat eq "xeno") {
            return "-minCover=0.15 -sizeMatters -minAli=0.96 -nearTop=0.005";
        }
    } else {
        # GenBank:
        if ($type eq "mrna") {
            if ($orgCat eq "native") {
                return "-minAli=0.96 -sizeMatters -nearTop=0.005";
            } elsif ($orgCat eq "xeno") {
                return "-minAli=0.25";
            }
        } elsif ($type eq "est") {
            if ($orgCat eq "native") {
                return "-minAli=0.96 -sizeMatters -nearTop=0.005";
            } elsif ($orgCat eq "xeno") {
                return "-minAli=0.10";
            }
        }
    }
    die("getPslRepsArgs: can't determine for: release=\"$release\" typePrefix=\"$typePrefix\"");
}

# Combine PSL from one set of PSL (results from one query file), appending to
# output file.  Record the offset of the start and end of the psl that were
# added.  Return 1 if there were PSL added, 0 if none.
sub combinePslSet($$$$$$) {
    my($queryDir, $pslRepsArgs, $liftFile, $tmpDir, $outPsl, $pslQueryOffsets) = @_;

    my $startOff = (-e $outPsl) ? getFileSize($outPsl) : 0;

    my $cmd = "find $queryDir -name '*.psl.gz' | xargs zcat "
        . "| sort -T $tmpDir -k 10,10 -k 12n,12n ";
    if (defined($pslRepsArgs)) {
        $cmd .= "| pslReps -nohead $pslRepsArgs stdin stdout /dev/null "
    }
    if (defined($liftFile)) {
        $cmd .= "| liftUp -nohead -type=.psl stdout $liftFile carry stdin ";
    }
    $cmd .= " >> $outPsl";
    runPipe($cmd);
    my $endOff = (-e $outPsl) ? getFileSize($outPsl) : 0;

    # always save offsets, even if empty
    $$pslQueryOffsets{$queryDir} = [$startOff, $endOff];
    if ($endOff > $startOff) {
        return 1;
    } else {
        return 0;
    }
}

# Combine and lift alignments, removing repeats, return name of output psl or
# undef if no PSLs.
sub combinePsls($$$$$$$@) {
    my($release, $type, $typePrefix, $liftFile, $updWorkDir, $tmpDir,
       $pslQueryOffsets, @queryDirs) = @_;
    
    # We do this as a pipeline, to avoid intermediate disk I/O if possible.
    # We need to sort by query for pslReps.  We use sort rather than pslSort,
    # since pslSort can't read from a pipe (and sort is much faster).  We use
    # the gbBlat naming convention where query file is the first level of
    # directory to group into small batches for pslRep processing.  However,
    # we need to save the output of pslRep for use by selectWithPsl.  Instead
    # of writing the data twice, we just save the offsets in the output PSL
    # file.  These are used by selectWithPsl to only load a subset of the
    # PSL.
    my $outPsl = "$updWorkDir/$typePrefix.psl";
    if (-e $outPsl) {
        unlink($outPsl) || die("unlink $outPsl");
    }

    my $pslRepsArgs = getPslRepsArgs($release, $typePrefix);

    # Process each query dir in a pipeline with error checking, use find to
    # avoid possible comand line overflow. Sort by qName,qStart,qEnd for
    # pslReps and lift.
    my $gotPsls = 0;
    foreach my $queryDir (@queryDirs) {
        if (combinePslSet($queryDir, $pslRepsArgs, $liftFile,
                          $tmpDir, $outPsl, $pslQueryOffsets)) {
            $gotPsls = 1;
        }
    }
    if ($gotPsls) {
        return $outPsl;
    } else {
        return undef;  # didn't get anything
    }
}

# get the list start and end offsets from a pslQueryOffsets
sub getPslQueryOffsets($$) {
    my($queryDir, $pslQueryOffsets) = @_;
    if (!defined(${$pslQueryOffsets}{$queryDir})) {
        gbError("BUG: no PSL offsets found for queryDir $queryDir");
    }
    return (${$pslQueryOffsets}{$queryDir}[0],
            ${$pslQueryOffsets}{$queryDir}[1]);
}

# Combine one set of orientation info files.  Return 1 if any were extracted.
sub combineOISet($$$$$) {
    my($queryDir, $liftFile, $outPsl, $pslQueryOffsets, $outOI) = @_;

    my($startOff, $endOff) =  getPslQueryOffsets($queryDir, $pslQueryOffsets);
    if ($startOff == $endOff) {
        return 0;  # will no PSLs save
    }
    my $cmd = "find $queryDir -name '*.oi.gz' | xargs zcat ";
    if (defined($liftFile)) {
        $cmd .= "| liftUp -type=.bed -nosort stdout $liftFile carry stdin ";
    }
    $cmd .= "| selectWithPsl -fmt=oi -startOff=$startOff -endOff=$endOff $outPsl stdin stdout"
        . " >> $outOI";
    runPipe($cmd);
    return 1;
}

# Combine and lift orientation info. Only called if there are PSLs, and hence
# must be orientInfo files.  This processing parallels combinePsls.
sub combineOIs($$$$$$@) {
    my($typePrefix, $liftFile, $updWorkDir, $tmpDir, $outPsl, $pslQueryOffsets, @queryDirs) = @_;

    # Process each query dir in a pipeline, selecting the ones kept
    # by pslReps.
    my $outOI = "$updWorkDir/$typePrefix.oi";
    if (-e $outOI) {
        unlink($outOI) || die("unlink $outOI");
    }
    my $gotOIs = 0;
    foreach my $queryDir (@queryDirs) {
        if (combineOISet($queryDir, $liftFile, $outPsl, $pslQueryOffsets, $outOI)) {
            $gotOIs = 1;
        }
    }
    if ($gotOIs) {
        return $outOI;
    } else {
        return undef;
    }
}

# combine one set of intron PSLs
sub combineIntronPslSet($$$$$) {
    my($queryDir, $liftFile, $outPsl, $pslQueryOffsets, $outIntronPsl) = @_;

    # must determine if there are any intronPsl files, as liftUp will
    # complain about empty input
    my @intronPsls = glob("$queryDir/*/*/*.intronPsl.gz");
    if ($#intronPsls < 0) {
        return 0;
    }
    my($startOff, $endOff) =  getPslQueryOffsets($queryDir, $pslQueryOffsets);
    if ($startOff == $endOff) {
        return 0;  # will no PSLs saved
    }
    my $cmd = "find $queryDir -name '*.intronPsl.gz' | xargs zcat ";
    if (defined($liftFile)) {
        $cmd .= "| liftUp -nohead -type=.psl -nosort stdout $liftFile carry stdin ";
    }
    $cmd .= "| selectWithPsl -fmt=psl -startOff=$startOff -endOff=$endOff $outPsl stdin stdout"
        . " >> $outIntronPsl";
    runPipe($cmd);
    return 1;
}

# Combine and lift intronPsl files. This processing parallels combinePsls,
# however intronPsl files only exist for native ESTs and not all EST psl will
# have intronPsl files.
sub combineIntronPsls($$$$$$@) {
    my($typePrefix, $liftFile, $updWorkDir, $tmpDir, $outPsl, $pslQueryOffsets, @queryDirs) = @_;

    my $outIntronPsl = "$updWorkDir/$typePrefix.intronPsl";
    if (-e $outIntronPsl) {
        unlink($outIntronPsl) || die("unlink $outIntronPsl");
    }

    # Process each query dir in a pipeline, selecting the ones kept
    # by pslReps.
    my $gotPsls = 0;
    foreach my $queryDir (@queryDirs) {
        if (combineIntronPslSet($queryDir, $liftFile, $outPsl,
                                $pslQueryOffsets, $outIntronPsl)) {
            $gotPsls = 1;
        }
    }
    
    if ($gotPsls) {
        return $outPsl;
    } else {
        return undef;  # didn't get anything
    }
}

# check if a set of alignments has already been installed. 
sub checkIfDone($) {
    my($dirPrefix) = @_;
    # replace workdir
    my $outDirPrefix = $dirPrefix;
    $outDirPrefix =~ s/^[^\/]+\///;
    $outDirPrefix = "aligned/$outDirPrefix";
    if (-e "$outDirPrefix.alidx") {
        return 1;
    } else {
        return 0;
    }
}

# Do work of combining PSL, etc for release+update+typeAccPrefix+orgCat.
sub finishOrgCatAligns($$$) {
    my($dirPrefix, $orgCat, $tmpDir) = @_;
    my($release, $database, $update, $type, $typeAccPrefix)
        = parseDirPrefix($dirPrefix);
    my $typePrefix = "$typeAccPrefix.$orgCat";
    my $liftFile = $main::dbLiftFiles{$database};
    my $updWorkDir = "$main::workDir/$release/$database/$update";

    my ($outPsl, $queryPslDir, $outOI, $outIntronPsl, %pslQueryOffset);
    my @queryDirs = glob("$updWorkDir/psl/$typePrefix.*");
    if ($#queryDirs >= 0) {
        ($outPsl, $queryPslDir)
            = combinePsls($release, $type, $typePrefix, $liftFile,
                          $updWorkDir, $tmpDir, \%pslQueryOffset,
                          @queryDirs);

        # build orient info and intron psl if we have PSLs and are native.
        if (defined($outPsl) && ($orgCat eq "native")) {
            $outOI = combineOIs($typePrefix, $liftFile, $updWorkDir,
                                $tmpDir, $outPsl, \%pslQueryOffset,
                                @queryDirs);
            if ($type eq "est") {
                $outIntronPsl = combineIntronPsls($typePrefix, $liftFile,
                                                  $updWorkDir,$tmpDir,
                                                  $outPsl, \%pslQueryOffset,
                                                  @queryDirs);
            }
        }
    }
    return ($outPsl, $outOI, $outIntronPsl);
}

# Process a release+update+typeAccPrefix, combining cluster-generated files,
# migrating alignments, and building the index file.
sub finishAligns($) {
    my($dirPrefix) = @_;
    my($release, $database, $update, $type, $typePrefix)
        = parseDirPrefix($dirPrefix);
    if ($main::verbose) {
        print STDERR "finishAligns: $release $database $update $typePrefix\n";
    }
    # check if already completed
    my $alidxBase = "data/aligned/$release/$database/$update/$typePrefix";
    my $finished = (-e "$alidxBase.native.alidx" && -e "$alidxBase.xeno.alidx");
    if ($finished) {
        if ($main::verbose) {
            print STDERR "finishAligns: $alidxBase.*.alidx exists, skipping,\n";
        }
        return;
    }
    my $tmpDir = getTmpDir("gbAlign");
    
    # combine and save in intermediate files, which will be installed
    # by gbAlignInstall
    my @nativeInter = finishOrgCatAligns($dirPrefix, "native", $tmpDir);
    my @xenoInter = finishOrgCatAligns($dirPrefix, "xeno", $tmpDir);

    if ($main::keep) {
        print STDERR "keeping tmp directory $tmpDir\n";
    } else {
        removeDir($tmpDir);
    }

    # copy psl, migrate alignments, and build index.  This is done even
    # if output files were not produced, as the index lists unaligned seqs.
    runProg("gbAlignInstall -workdir=$main::workDir $release $update $typePrefix $database");

    if (!$main::keep) {
        foreach my $f (@nativeInter, @xenoInter) {
            if (defined($f)) {
                unlink($f);
            }
        }
    }
}

# Verify that all expected PSLs exist
sub verifyExpectedPsls() {
    my $expected = "$main::workDir/align.expected";
    open(EXPECTED, $expected) || die("can't open $expected");
    my $relPsl;
    my $missingCnt = 0;
    while ($relPsl = <EXPECTED>) {
        my $psl = "$main::workDir/$relPsl";
        chomp($psl);
        if (! -e $psl) {
            print STDERR "Error: missing PSL: $psl\n";
            $missingCnt++;
        }
    }
    close(EXPECTED) || die("close failed");
    if ($missingCnt > 0) {
        die("$missingCnt missing PSLs");
    }
}

# Entry
setTaskName("gbAlignFinish");

# parse into globals used in program
$main::verbose = 0;
$main::keep = 0;
$main::workDir = "work/align";

while (($#ARGV >= 0) && ($ARGV[0] =~/^-.*/)) {
    my $opt = $ARGV[0];
    shift @ARGV;
    if ($opt =~ /^-workdir($|=)/) {
        $main::workDir = parseOptEq($opt);
    } elsif ($opt eq "-verbose") {
        $gbCommon::verbose = 1;
    } elsif ($opt =~ /^-verbose=/) {
        $gbCommon::verbose = parseOptEq($opt);
    } elsif ($opt eq "-keep") {
        $main::keep = 1;
    } else {
        gbError("invalid option \"$opt\"");
    }
}
if ($#ARGV < 0) {
    gbError("wrong # args: gbAlignFinish [-workdir=dir] [-keep] [-verbose] database liftFile ...");
}
my @databases;
while ($#ARGV >= 0) {
    my $db = $ARGV[0];
    push(@databases, $db);
    shift @ARGV;

    if ($ARGV[0] ne "") {
        $main::dbLiftFiles{$db} = $ARGV[0];
    }
    shift @ARGV;
}

# check that the empty done file was created
my $doneFlag = "$main::workDir/align.done";
if (! -e $doneFlag) {
    gbError("alignment appears not to have completed, $doneFlag does not exist");
}

verifyExpectedPsls();

# process each update and type for each database
foreach my $db (@databases) {
    foreach my $dirPrefix (getDirsPrefixes($db)) {
        if (!checkIfDone($dirPrefix)) {
            finishAligns($dirPrefix);
        }
    }
}
