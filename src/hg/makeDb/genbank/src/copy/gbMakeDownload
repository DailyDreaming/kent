#!/usr/bin/perl
#
# gbMakeDownload [options] database ...
#
# create download sequences
#
# $Id: gbMakeDownload,v 1.5 2005/09/01 00:05:45 markd Exp $
#
use strict;
use warnings;
use File::Basename;
use FindBin;
use lib "$FindBin::Bin/../lib";
use gbCommon;

my $usage = 
    " gbMakeDownload [options] database ...\n"
    . "\n"
    . "create download files\n"
    . "\n"
    . " Options:\n"
    . "   -getDownloadSeqs=days - create sequence gzipped fasta files and save in\n"
    . "    \$gbRoot/download if download/dump.time doesn't exists or time is\n"
    . "    more than \$days days old. If not specified, they will be recreated only\n"
    . "    if they don't exist. Specify 0 to force recreation.\n"
    . "   -downloadRootDir=dir - save download files in this directory, default is:\n"
    . "       /mirrordata/apache/htdocs/goldenPath/\n"
    . "   -verbose\n";

my $verboseArg;

# location of /usr/local/apache/htdocs/goldenPath on hgdownload:
my $downloadRootDir = "/mirrordata/apache/htdocs/goldenPath";

# determine if download files need to be updated for a database
sub downloadOutOfData($$) {
    my($db, $getDownloadSeqsDays) = @_;
    my $timeFile = getDownloadTimeFile($downloadRootDir, $db);

    if (define($getDownloadSeqsDays)) {
        # check if non-existant or out-of-date
        my $downloadTime = loadTimeFile($timeFile);
        my $deltaDays = (time() - $downloadTime) / (60 * 60 * 24);
        return ($deltaDays > $getDownloadSeqsDays);
    } else {
        # check only if non-existant
        return !(-e $timeFile);
    }
}

# Build a sequence fa for a download file, or undef if not defined for
# this db
sub makeSeqFa($$$$$) {
    my($db, $srcDb, $type, $orgCat, $outBase) = @_;

    # one create if table is loaded
    my $loadTbl = getDbConfNo($db, "$srcDb.$type.$orgCat.load");
    if (defined($loadTbl) && ($loadTbl eq "yes")) {
        # setup out directory to put 
        my $downloadDir = "download/" . getRelDownloadDir($db) . "/bigZips";
        makeDir($downloadDir);

        my $fa = "$downloadDir/$outBase.fa";
        my $cmd = "gbGetSeqs -get=seq -db=$db -$orgCat";
        if (defined($verboseArg)) {
            $cmd .= " " . $verboseArg;
        }
        $cmd .= " $srcDb $type $fa";
        runProg($cmd);
        return $fa;
    } else {
        return undef;
    }
}

# create one sequence fa.gz if the table is loaded for this genome.
sub createSeqFaGz($$$$$) {
    my($db, $srcDb, $type, $orgCat, $outBase) = @_;

    my $fa = makeSeqFa($db, $srcDb, $type, $orgCat, $outBase);
    if (defined($fa)) {
        my $gzip =  dirname($fa) . "/$outBase.fa.gz";
        runProg("gzip -1c $fa> $gzip.tmp");
        unlink($fa);
        renameFile("$gzip.tmp", $gzip);
    }
}

# make sequence download files
sub makeDownloadSeqs($) {
    my($db) = @_;
    prMsg("making download sequences for $db");
    createSeqFaGz($db, "genbank", "mrna", "native", "mrna");
    createSeqFaGz($db, "genbank", "mrna", "xeno", "xenoMrna");
    createSeqFaGz($db, "genbank", "est", "native", "est");
    createSeqFaGz($db, "refseq", "mrna", "native", "refMrna");
    #FIXME: not supported gbGetSeqs:
    #createSeqFaGz($db, "native", "refseq", "mrna", "refPep");
    # FIXME: need to add up/down stream seqs
}

# handle download file processing
sub createDownload($) {
    my($db) = @_;
    my $timeFile = getDownloadTimeFile($downloadRootDir, $db);
    makeDownloadSeqs($db);
    makeTimeFile($timeFile);
}

# Entry
my $getDownloadSeqsDays = undef;
while (($#ARGV >= 0) && ($ARGV[0] =~ /^-.*/)) {
    my $opt = $ARGV[0];
    shift @ARGV;
    if ($opt eq "-verbose") {
        $verboseArg = "-verbose";
        $gbCommon::verbose = 1;
    } elsif ($opt =~ /^-verbose=/) {
        $verboseArg = "-verbose=" . parseOptEq($opt);
        $gbCommon::verbose = parseOptEq($opt);
    } elsif ($opt =~ /^-getDownloadSeqs(=|$)/) {
        $getDownloadSeqsDays = parseOptEq($opt);
    } elsif ($opt =~ /^-downloadRootDir(=|$)/) {
        $downloadRootDir = parseOptEq($opt);
    } else {
        gbError("invalid option \"$opt\"\n$usage");
    }
}
if ($#ARGV < 0) {
    gbError("wrong # args: $usage");
}
my @databases = @ARGV;

# Before locking, determine if anything needs to be done.  This avoids
# a log and e-mail message if not needed.
my @outdatedDbs;
foreach my $db (@databases) {
    if (downloadOutOfData($db, $getDownloadSeqsDays)) {
        push(@outdatedDbs, $db);
    }
}
if ($#outdatedDbs < 0) {
    exit(0);
}
             
beginTask("mkdownload", "mkdownload");

foreach my $db (@outdatedDbs) {
    createDownload($db);
}

endTask();

