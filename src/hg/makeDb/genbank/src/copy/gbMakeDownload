#!/usr/bin/perl
#
# gbMakeDownload [options] database ...
#
# create download sequences
#
# in order to create upstream sequences a file
# etc/.hg.mkdownload.conf must contain host/password
# to database.
#
#
# $Id: gbMakeDownload,v 1.11 2008/10/14 22:51:10 markd Exp $
#
use strict;
use warnings;
use File::Basename;
use FindBin;
use lib "$FindBin::Bin/../lib";
use gbCommon;

my $usage = 
    " gbMakeDownload [options] database ...\n"
    . "\n"
    . "create download files\n"
    . "\n"
    . " Options:\n"
    . "   -getDownloadSeqs=days - create sequence gzipped fasta files and save in\n"
    . "    \$gbRoot/ftp if ftp/\$db/download.time doesn't exists or time is\n"
    . "    more than \$days days old. If not specified, they will be recreated only\n"
    . "    if they don't exist. Specify 0 to force recreation.\n"
    . "   -downloadRootDir=dir - save download files in this directory, default is:\n"
    . "       ./ftp\n"
    . "   -rsyncGbdb - rsync gbdb to local /gbdb\n"
    . "   -verbose=n\n";

my $verboseArg;
my $getDownloadSeqsDays = undef;
my $rsyncGbdb = 0;
my $downloadRootDir = "ftp";

# rsync gbdb links to local system
sub rsyncGbdbLinks() {
    runProg("rsync -a hgwdev:/gbdb/ /gbdb");
}

# get file time modification time or undef if it doen't exist
sub getFileMTime($) {
    my($file) = @_;
    if (! -e $file) {
        return undef;
    } else {
        my @st = stat($file);
        if ($#st == 0) {
            die("can't stat $file");
        }
        return $st[9];
    }
}

# determine if a download file needs to be updated for a database
sub fileOutOfDate($) {
    my($file) = @_;
    my $mtime = getFileMTime($file);
    if (defined($getDownloadSeqsDays) && defined($mtime)) {
        # check if non-existant or out-of-date
        my $deltaDays = (time() - $mtime) / (60 * 60 * 24);
        return ($deltaDays > $getDownloadSeqsDays);
    } else {
        # check only if non-existant
        return !defined($mtime);
    }
}

# create an md5sum of a file, with path in file being
# specified file name, rather than full path.
sub createMd5($$$) {
    my($file, $name, $md5file) = @_;
    my $sumstr = callProg("md5sum $file");
    chomp($sumstr);
    my($sum, $junk) = split(/\s+/,$sumstr);
    open(MD5SUM, ">", $md5file) || die("can't open $md5file");
    print MD5SUM "$sum  $name\n";
    close(MD5SUM);
}

# Build a sequence fa and md5sum files
sub makeSeqFa($$$$$) {
    my($db, $srcDb, $type, $orgCat, $outPre) = @_;
    my $fa = "$outPre.fa.gz";
    my $md5 = "$fa.md5";
    prMsg("creating $fa");

    my $tmpFa = "$fa.tmp.gz";
    my $tmpMd5 = "$md5.tmp";
    my $cmd = "gbGetSeqs -get=seq -db=$db -$orgCat";
    if (defined($verboseArg)) {
        $cmd .= " " . $verboseArg;
    }
    $cmd .= " $srcDb $type $tmpFa";
    runProg($cmd);
    createMd5($tmpFa, basename($fa), $tmpMd5);
    renameFile($tmpFa, $fa);
    renameFile($tmpMd5, $md5);
}

# Create one sequence FASTA if the table is loaded for this genome
# and the files if out of date or doesn't exist.  If called with
# $justCheck, just return status indicating if they need to be
# updated
sub maybeMakeSeqFa($$$$$$) {
    my($justCheck, $db, $srcDb, $type, $orgCat, $outBase) = @_;
    my $downloadDir = getSeqDownloadDir($downloadRootDir, $db);
    my $outPre = "$downloadDir/$outBase";
    my $loadTbl = getDbConfNo($db, "$srcDb.$type.$orgCat.load");
    if ($loadTbl && fileOutOfDate("$outPre.fa.gz")) {
        if (!$justCheck) {
            makeDir($downloadDir);
            makeSeqFa($db, $srcDb, $type, $orgCat, $outPre);
        }
        return 1;
    } else {
        return 0;
    }
}

# make sequence fasta download files, or just check if they need updates
sub maybeMakeSeqFaFiles($$) {
    my($justCheck, $db) = @_;
    my $needUpdated = 0;
    if (maybeMakeSeqFa($justCheck, $db, "genbank", "mrna", "native", "mrna")) {
        $needUpdated = 1;
    }
    if (maybeMakeSeqFa($justCheck, $db, "genbank", "mrna", "xeno", "xenoMrna")) {
        $needUpdated = 1;
    }
    if (maybeMakeSeqFa($justCheck, $db, "genbank", "est", "native", "est")) {
        $needUpdated = 1;
    }
    if (maybeMakeSeqFa($justCheck, $db, "refseq", "mrna", "native", "refMrna")) {
        $needUpdated = 1;
    }
    return $needUpdated;
}

# make an upstream FASTA  file and checksum
sub makeUpstreamFaSize($$$$) {
    my($db, $geneTbl, $size, $fa) = @_;
    my $md5 = "$fa.md5";
    my $tmpFa = "$fa.tmp.gz";
    my $tmpMd5 = "$md5.tmp";
    makeDir(dirname($fa));
    runPipe("featureBits -fa=stdout $db ${geneTbl}:upstream:${size} | gzip -c > $tmpFa");
    createMd5($tmpFa, basename($fa), $tmpMd5);
    renameFile($tmpFa, $fa);
    renameFile($tmpMd5, $md5);
}

# Determine gene table to use to creating upstream files, or undef if none.
sub getUpstreamGeneTbl($) {
    my($db) = @_;
    my $geneTbl = getDbConfUndef($db, "upstreamGeneTbl");
    if (defined($geneTbl)) {
        return $geneTbl;
    } else {
        return undef;
    }
}    

# Determine get the upstream MAF table and organism file to use to creating
# upstream MAFS, or (undef,undef) if not specified.
sub getUpstreamMafTblOrgs($) {
    my($db) = @_;
    my $spec = getDbConfUndef($db, "upstreamMaf");
    if (!defined($spec)) {
        return (undef, undef);
    }
    my @parts = splitSpaceList($spec);
    if ($#parts != 1) {
        gbError("expected two arguments to $db.upstreamMaf, got: $spec");
    }
    return ($parts[0], $parts[1]);
}

# create upstream FASTA file for a database and size if it doesn't exist or
# is out of date.
sub maybeMakeUpstreamFaSize($$$) {
    my($justCheck, $db, $size) = @_;
    my $downloadDir = getSeqDownloadDir($downloadRootDir, $db);
    my $fa = "$downloadDir/upstream${size}.fa.gz";
    my $geneTbl = getUpstreamGeneTbl($db);
    if (defined($geneTbl) && fileOutOfDate($fa)) {
        if (!$justCheck) {
            makeUpstreamFaSize($db, $geneTbl, $size, $fa);
        }
        return 1;
    } else {
        return 0;
    }
}

# create upstream FASTA files for a database if they don't exist or are out
# of date.
sub maybeMakeUpstreamFa($$) {
    my($justCheck, $db) = @_;
    my $needUpdated = 0;
    foreach my $size (1000, 2000, 5000) {
        if (maybeMakeUpstreamFaSize($justCheck, $db, $size)) {
            $needUpdated = 1;
        }
    }
    return $needUpdated;
}

# make an upstream MAF file and checksum
sub makeUpstreamMafSize($$$$$$) {
    my($db, $geneTbl, $mafTbl, $mafOrgs, $size, $maf) = @_;
    my $md5 = "$maf.md5";
    my $tmpMaf = "$maf.tmp.gz";
    my $tmpMd5 = "$md5.tmp";
    makeDir(dirname($maf));
    # WARNING: -fa=/dev/null is need as it changes bed format.
    # sed cleanups nasty names generated by featureBits
    runPipe("featureBits -bed=stdout -fa=/dev/null -verbose=0 $db ${geneTbl}:upstream:${size} | sed -re 's/_up_[^\\t]+//' | sort -k1,1 -k2,2n | mafFrags -txStarts -orgs=${mafOrgs} ${db} ${mafTbl} stdin stdout | gzip -c > $tmpMaf");
    createMd5($tmpMaf, basename($maf), $tmpMd5);
    renameFile($tmpMaf, $maf);
    renameFile($tmpMd5, $md5);
}

# create upstream MAF file for a database and size if it doesn't exist or
# are out of date.
sub maybeMakeUpstreamMafSize($$$) {
    my($justCheck, $db, $size) = @_;
    my($mafTbl, $mafOrgs) = getUpstreamMafTblOrgs($db);
    my $geneTbl = getUpstreamGeneTbl($db);
    if (defined($geneTbl) && defined($mafTbl)) {
        
        my $downloadDir = getMafDownloadDir($downloadRootDir, $db, $mafTbl);
        my $maf = "$downloadDir/upstream${size}.maf.gz";
        if (fileOutOfDate($maf)) {
            if (!$justCheck) {
                makeUpstreamMafSize($db, $geneTbl, $mafTbl, $mafOrgs, $size, $maf);
            }
            return 1;
        }
    }
    return 0;
}

# create upstream download files for a database if they don't exist or are out
# of date.
sub maybeMakeUpstreamMaf($$) {
    my($justCheck, $db) = @_;
    my $needUpdated = 0;
    foreach my $size (1000, 2000, 5000) {
        if (maybeMakeUpstreamMafSize($justCheck, $db, $size)) {
            $needUpdated = 1;
        }
    }
    return $needUpdated;
}


# make download files, or just check if they need updates
sub updateDownloadFiles($$) {
    my($justCheck, $db) = @_;
    if (!$justCheck) {
        prMsg("making download sequences for $db");
    }
    my $needUpdated = 0;
    if (maybeMakeSeqFaFiles($justCheck, $db)) {
        $needUpdated = 1;
    }
    if (maybeMakeUpstreamFa($justCheck, $db)) {
        $needUpdated = 1;
    }
    if (maybeMakeUpstreamMaf($justCheck, $db)) {
        $needUpdated = 1;
    }
    return $needUpdated;
}

# Entry
while (($#ARGV >= 0) && ($ARGV[0] =~ /^-.*/)) {
    my $opt = $ARGV[0];
    shift @ARGV;
    if ($opt =~ /^-verbose=/) {
        $verboseArg = "-verbose=" . parseOptEq($opt);
        $gbCommon::verbose = parseOptEq($opt);
    } elsif ($opt =~ /^-getDownloadSeqs(=|$)/) {
        $getDownloadSeqsDays = parseOptEq($opt);
    } elsif ($opt =~ /^-downloadRootDir(=|$)/) {
        $downloadRootDir = parseOptEq($opt);
    } elsif ($opt eq "-rsyncGbdb") {
        $rsyncGbdb = 1;
    } else {
        gbError("invalid option \"$opt\"\n$usage");
    }
}
if ($#ARGV < 0) {
    gbError("wrong # args: $usage");
}
my @databases = @ARGV;
$ENV{"HGDB_CONF"} = "etc/.hg.mkdownload.conf";

# Before locking, determine if anything needs to be done.  This avoids
# a log and e-mail message if not needed.
my @outdatedDbs;
foreach my $db (@databases) {
    if (updateDownloadFiles(1, $db)) {
        push(@outdatedDbs, $db);
    }
}
if ($#outdatedDbs < 0) {
    exit(0);
}
             
beginTask("mkdownload", "mkdownload");
if ($rsyncGbdb) {
    rsyncGbdbLinks();
}
foreach my $db (@outdatedDbs) {
    updateDownloadFiles(0, $db);
}
endTask();

