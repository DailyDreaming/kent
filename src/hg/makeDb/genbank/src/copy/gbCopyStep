#!/usr/bin/perl
#
# gbCopyStep [options] buildServer buildRoot
#
# rsync data/processed and data/aligned files build server to local directory
# available to systems to be updated.  Update the /gbdb/ directory with fasta
# files.  Must be run in local gbRoot directory.  This gets the build.time
# file before locking and with exit without any messages if build.time
# has not changed.
#
# Options:
#   -rsyncPort=port - rsync port to use, or `rsh' or `ssh'.
#   -gbdb=dir - Use this directory for /gbdb (useful in debugging).
#   -verbose
# Arguments:`
#   - buildServer - host with build files.
#   - buildRoot - gbRoot directory on buildServer
#
#
use strict;
use warnings;
use File::Basename;
use FindBin;
use lib "$FindBin::Bin/../lib";
use gbCommon;

# Get the port option to use with rsync
sub getRSyncPortOpt($) {
    my($rsyncPort) = @_;
    if ($rsyncPort eq "rsh") {
        return "--rsh=rsh";
    }
    if ($rsyncPort eq "ssh") {
        return "--rsh=ssh";
    }
    return "--port=$rsyncPort";
}

# use rsync to get build.time file, return path to file, or undef it
# can't be retrieved.
sub getBuildTimeFile($$$) {
    my($rsyncPort, $buildServer, $buildRoot) = @_;

    my $buildTimeTmp = "var/copy/build.time.$gbCommon::hostName.$$.tmp";
    makeFileDir($buildTimeTmp);
    
    my $remBuildFile = "$buildRoot/var/build/build.time";

    my $cmd = "rsync " . getRSyncPortOpt($rsyncPort) . " $buildServer:$remBuildFile "
        . " $buildTimeTmp";
    my $stat = runProgNoAbort($cmd);
    if ($stat != 0) {
        print STDERR "Warning: can't rsync $buildServer:$remBuildFile, will try again later\n";
        return undef;
    } else {
        return $buildTimeTmp;
    }
}

# compare build times, return 1 if the build is newer than what we have.
sub checkBuildTime($$) {
    my($lastBuildTime, $buildTimeTmp) = @_;
    if (!-e $lastBuildTime) {
        return 1;  # no current time file
    }
    my $lastBuildTimeSec = loadTimeFile($lastBuildTime);
    my $buildTimeSec = loadTimeFile($buildTimeTmp);
    return ($lastBuildTimeSec < $buildTimeSec);
}

# rsync the processed and aligned files with the local directory
sub rsyncBuildFiles($$$) {
    my($rsyncPort, $buildServer, $buildRoot) = @_;
    my $baseCmd = "rsync --archive " . getRSyncPortOpt($rsyncPort);
    makeDir("data");

    # get ignore.idx
    my $cmd = $baseCmd . " $buildServer:$buildRoot/data/ignore.idx data";
    runProg($cmd);

    # get processed
    $cmd = $baseCmd . " $buildServer:$buildRoot/data/processed data";
    runProg($cmd);

    # get aligned
    $cmd = $baseCmd . " $buildServer:$buildRoot/data/aligned data";
    runProg($cmd);
}

# check if the /gbdb/genbank/processed  directory is on the same file system
# as the local genbank root.  Create directory if it doesn't exist.
sub checkIfGbdbLinkable($) {
    my($gbdbDir) = @_;
    my $processedDir = "data/processed";
    my $gbdbProcessedDir = "$gbdbDir/genbank/data/processed";
    makeDir($gbdbProcessedDir);
    my($processedDev) = stat($processedDir);
    my($gbdbProcessedDev) = stat($gbdbProcessedDir);
    
    return ($processedDev == $gbdbProcessedDev);
}

# link processed fasta to gbdb directory
sub linkProcessedFastas($) {
    my($gbdbDir) = @_;
    # create links
    runPipe("find data/processed -name '*.fa' | cpio -pduml $gbdbDir/genbank");

    # cpio doesn't set the permission on created directories, os force them
    runPipe("find $gbdbDir/genbank/data -follow -type d | xargs chmod a+rx");
}

# Entry
my $rsyncPort = "rsh";
my $gbdbDir = "/gbdb";
while (($#ARGV >= 0) && ($ARGV[0] =~ /^-.*/)) {
    my $opt = $ARGV[0];
    shift @ARGV;
    if ($opt =~ /^-verbose=/) {
        $gbCommon::verbose = 1;
    } elsif ($opt eq "-verbose") {
        $gbCommon::verbose = 1;
    } elsif ($opt =~ /^-rsyncPort=/) {
        $rsyncPort = parseOptEq($opt);
    } elsif ($opt =~ /^-gbdb=/) {
        $gbdbDir = parseOptEq($opt);
    } else {
        gbError("invalid option \"$opt\"");
    }
}
if ($#ARGV != 1) {
    gbError("wrong # args: gbCopyStep [options] buildServer buildRoot");
}
my($buildServer, $buildRoot) = @ARGV;

# Retrieve and check the build.time file before opening the log file.
# This allows for frequent polling without unnecessary noise.
my $buildTimeTmp = getBuildTimeFile($rsyncPort, $buildServer, $buildRoot);
my $lastBuildTime = "var/copy/build.time";

if (defined($buildTimeTmp)
    && checkBuildTime($lastBuildTime, $buildTimeTmp)) {

    # build time has changed
    beginTask("copy", "copy");
    my $copyTime = "var/copy/copy.time";

    rsyncBuildFiles($rsyncPort, $buildServer, $buildRoot);

    if (checkIfGbdbLinkable($gbdbDir)) {
        linkProcessedFastas($gbdbDir);
    } else {
        # haven't implemented copying with local rsync
        gbError("can link, not on same filesystem: data/processed and $gbdbDir/genbank/data/Processed");
    }

    # install time files.
    makeTimeFile($copyTime);
    renameFile($buildTimeTmp, $lastBuildTime);

    endTask();
} else {
    # not new build.
    unlink($buildTimeTmp);
}
