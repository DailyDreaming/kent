#!/usr/bin/perl
#
# gbUpdateDownload [options]
#
# update download directories
#
# $Id: gbUpdateDownload,v 1.1 2004/05/28 00:15:50 markd Exp $
#
my $usage = 
    "gbUpdateDownload [options]\n"
    . "\n"
    . "Update download directories\n"
    . "\n"
    . "Options:\n"
    . "   -verbose\n";

use strict;
use warnings;
use File::Basename;
use FindBin;
use lib "$FindBin::Bin/../lib";
use gbCommon;

# 
# Generate list of databases with download files
#
sub getDownloadDbs() {
    my @downDbs;
    foreach my $downTime (glob("download/*/download.time")) {
        push(@downDbs, basename(dirname($downTime)))
    }
    return @downDbs;
}

# update the download files for the web server.  Must check time file
# to keep in-progress dump from being updated
sub updateDownload($) {
    my($db) = @_;
    my $dbDir = getRelDownloadDir($db);
    my $htdocsDir = "/usr/local/apache/htdocs/goldenPath";

    my $downloadTime = getDownloadTimeFile($db);
    my $htdocsTime = "$htdocsDir/$dbDir/download.time";

    if ((-e $downloadTime) 
        && ((!-e $htdocsTime)
            || (loadTimeFile($downloadTime) > loadTimeFile($htdocsTime)))) {
        # download dir can't have trailing / for rsync
        my $downloadDir = "download/$dbDir";
        $downloadDir =~ s/\/$//;
        my $htdocsDir = "/usr/local/apache/htdocs/goldenPath";
        if ($gbCommon::verbose) {
            prMsg("update download files for $db");
        }
        makeDir("$htdocsDir/$dbDir");
        runProg("rsync -r $downloadDir $htdocsDir");
    }
}

# Entry
while (($#ARGV >= 0) && ($ARGV[0] =~ /^-.*/)) {
    my $opt = $ARGV[0];
    shift @ARGV;
    if ($opt eq "-verbose") {
        $gbCommon::verbose = 1;
    } elsif ($opt =~ /^-verbose=/) {
        $gbCommon::verbose = 1;
    } else {
        gbError("invalid option \"$opt\"");
    }
}
if ($#ARGV >= 0) {
    gbError("wrong # args: gbUpdateDownload [options]");
}

beginTask("update-download", "update-download");

foreach my $db (getDownloadDbs()) {
    updateDownload($db);
}

endTask();
