/* encodeDataWarehouse.c was originally generated by the autoSql program, which also 
 * generated encodeDataWarehouse.h and encodeDataWarehouse.sql.  This module links the database and
 * the RAM representation of objects. */

#include "common.h"
#include "linefile.h"
#include "dystring.h"
#include "jksql.h"
#include "encodeDataWarehouse.h"


void edwUserStaticLoad(char **row, struct edwUser *ret)
/* Load a row from edwUser table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->name = row[1];
safecpy(ret->sid, sizeof(ret->sid), row[2]);
safecpy(ret->access, sizeof(ret->access), row[3]);
ret->email = row[4];
}

struct edwUser *edwUserLoad(char **row)
/* Load a edwUser from row fetched with select * from edwUser
 * from database.  Dispose of this with edwUserFree(). */
{
struct edwUser *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->name = cloneString(row[1]);
safecpy(ret->sid, sizeof(ret->sid), row[2]);
safecpy(ret->access, sizeof(ret->access), row[3]);
ret->email = cloneString(row[4]);
return ret;
}

struct edwUser *edwUserLoadAll(char *fileName) 
/* Load all edwUser from a whitespace-separated file.
 * Dispose of this with edwUserFreeList(). */
{
struct edwUser *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[5];

while (lineFileRow(lf, row))
    {
    el = edwUserLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwUser *edwUserLoadAllByChar(char *fileName, char chopper) 
/* Load all edwUser from a chopper separated file.
 * Dispose of this with edwUserFreeList(). */
{
struct edwUser *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[5];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = edwUserLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwUser *edwUserCommaIn(char **pS, struct edwUser *ret)
/* Create a edwUser out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwUser */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->name = sqlStringComma(&s);
sqlFixedStringComma(&s, ret->sid, sizeof(ret->sid));
sqlFixedStringComma(&s, ret->access, sizeof(ret->access));
ret->email = sqlStringComma(&s);
*pS = s;
return ret;
}

void edwUserFree(struct edwUser **pEl)
/* Free a single dynamically allocated edwUser such as created
 * with edwUserLoad(). */
{
struct edwUser *el;

if ((el = *pEl) == NULL) return;
freeMem(el->name);
freeMem(el->email);
freez(pEl);
}

void edwUserFreeList(struct edwUser **pList)
/* Free a list of dynamically allocated edwUser's */
{
struct edwUser *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    edwUserFree(&el);
    }
*pList = NULL;
}

void edwUserOutput(struct edwUser *el, FILE *f, char sep, char lastSep) 
/* Print out edwUser.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->name);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->sid);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->access);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->email);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void edwHostStaticLoad(char **row, struct edwHost *ret)
/* Load a row from edwHost table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->name = row[1];
ret->lastOkTime = sqlLongLong(row[2]);
ret->lastNotOkTime = sqlLongLong(row[3]);
ret->firstAdded = sqlLongLong(row[4]);
ret->errorMessage = row[5];
ret->openSuccesses = sqlLongLong(row[6]);
ret->openFails = sqlLongLong(row[7]);
ret->historyBits = sqlLongLong(row[8]);
}

struct edwHost *edwHostLoad(char **row)
/* Load a edwHost from row fetched with select * from edwHost
 * from database.  Dispose of this with edwHostFree(). */
{
struct edwHost *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->name = cloneString(row[1]);
ret->lastOkTime = sqlLongLong(row[2]);
ret->lastNotOkTime = sqlLongLong(row[3]);
ret->firstAdded = sqlLongLong(row[4]);
ret->errorMessage = cloneString(row[5]);
ret->openSuccesses = sqlLongLong(row[6]);
ret->openFails = sqlLongLong(row[7]);
ret->historyBits = sqlLongLong(row[8]);
return ret;
}

struct edwHost *edwHostLoadAll(char *fileName) 
/* Load all edwHost from a whitespace-separated file.
 * Dispose of this with edwHostFreeList(). */
{
struct edwHost *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[9];

while (lineFileRow(lf, row))
    {
    el = edwHostLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwHost *edwHostLoadAllByChar(char *fileName, char chopper) 
/* Load all edwHost from a chopper separated file.
 * Dispose of this with edwHostFreeList(). */
{
struct edwHost *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[9];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = edwHostLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwHost *edwHostCommaIn(char **pS, struct edwHost *ret)
/* Create a edwHost out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwHost */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->name = sqlStringComma(&s);
ret->lastOkTime = sqlLongLongComma(&s);
ret->lastNotOkTime = sqlLongLongComma(&s);
ret->firstAdded = sqlLongLongComma(&s);
ret->errorMessage = sqlStringComma(&s);
ret->openSuccesses = sqlLongLongComma(&s);
ret->openFails = sqlLongLongComma(&s);
ret->historyBits = sqlLongLongComma(&s);
*pS = s;
return ret;
}

void edwHostFree(struct edwHost **pEl)
/* Free a single dynamically allocated edwHost such as created
 * with edwHostLoad(). */
{
struct edwHost *el;

if ((el = *pEl) == NULL) return;
freeMem(el->name);
freeMem(el->errorMessage);
freez(pEl);
}

void edwHostFreeList(struct edwHost **pList)
/* Free a list of dynamically allocated edwHost's */
{
struct edwHost *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    edwHostFree(&el);
    }
*pList = NULL;
}

void edwHostOutput(struct edwHost *el, FILE *f, char sep, char lastSep) 
/* Print out edwHost.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->name);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%lld", el->lastOkTime);
fputc(sep,f);
fprintf(f, "%lld", el->lastNotOkTime);
fputc(sep,f);
fprintf(f, "%lld", el->firstAdded);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->errorMessage);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%lld", el->openSuccesses);
fputc(sep,f);
fprintf(f, "%lld", el->openFails);
fputc(sep,f);
fprintf(f, "%lld", el->historyBits);
fputc(lastSep,f);
}

void edwSubmitDirStaticLoad(char **row, struct edwSubmitDir *ret)
/* Load a row from edwSubmitDir table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->url = row[1];
ret->hostId = sqlUnsigned(row[2]);
ret->lastOkTime = sqlLongLong(row[3]);
ret->lastNotOkTime = sqlLongLong(row[4]);
ret->firstAdded = sqlLongLong(row[5]);
ret->errorMessage = row[6];
ret->openSuccesses = sqlLongLong(row[7]);
ret->openFails = sqlLongLong(row[8]);
ret->historyBits = sqlLongLong(row[9]);
}

struct edwSubmitDir *edwSubmitDirLoad(char **row)
/* Load a edwSubmitDir from row fetched with select * from edwSubmitDir
 * from database.  Dispose of this with edwSubmitDirFree(). */
{
struct edwSubmitDir *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->url = cloneString(row[1]);
ret->hostId = sqlUnsigned(row[2]);
ret->lastOkTime = sqlLongLong(row[3]);
ret->lastNotOkTime = sqlLongLong(row[4]);
ret->firstAdded = sqlLongLong(row[5]);
ret->errorMessage = cloneString(row[6]);
ret->openSuccesses = sqlLongLong(row[7]);
ret->openFails = sqlLongLong(row[8]);
ret->historyBits = sqlLongLong(row[9]);
return ret;
}

struct edwSubmitDir *edwSubmitDirLoadAll(char *fileName) 
/* Load all edwSubmitDir from a whitespace-separated file.
 * Dispose of this with edwSubmitDirFreeList(). */
{
struct edwSubmitDir *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[10];

while (lineFileRow(lf, row))
    {
    el = edwSubmitDirLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwSubmitDir *edwSubmitDirLoadAllByChar(char *fileName, char chopper) 
/* Load all edwSubmitDir from a chopper separated file.
 * Dispose of this with edwSubmitDirFreeList(). */
{
struct edwSubmitDir *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[10];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = edwSubmitDirLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwSubmitDir *edwSubmitDirCommaIn(char **pS, struct edwSubmitDir *ret)
/* Create a edwSubmitDir out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwSubmitDir */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->url = sqlStringComma(&s);
ret->hostId = sqlUnsignedComma(&s);
ret->lastOkTime = sqlLongLongComma(&s);
ret->lastNotOkTime = sqlLongLongComma(&s);
ret->firstAdded = sqlLongLongComma(&s);
ret->errorMessage = sqlStringComma(&s);
ret->openSuccesses = sqlLongLongComma(&s);
ret->openFails = sqlLongLongComma(&s);
ret->historyBits = sqlLongLongComma(&s);
*pS = s;
return ret;
}

void edwSubmitDirFree(struct edwSubmitDir **pEl)
/* Free a single dynamically allocated edwSubmitDir such as created
 * with edwSubmitDirLoad(). */
{
struct edwSubmitDir *el;

if ((el = *pEl) == NULL) return;
freeMem(el->url);
freeMem(el->errorMessage);
freez(pEl);
}

void edwSubmitDirFreeList(struct edwSubmitDir **pList)
/* Free a list of dynamically allocated edwSubmitDir's */
{
struct edwSubmitDir *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    edwSubmitDirFree(&el);
    }
*pList = NULL;
}

void edwSubmitDirOutput(struct edwSubmitDir *el, FILE *f, char sep, char lastSep) 
/* Print out edwSubmitDir.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->url);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%u", el->hostId);
fputc(sep,f);
fprintf(f, "%lld", el->lastOkTime);
fputc(sep,f);
fprintf(f, "%lld", el->lastNotOkTime);
fputc(sep,f);
fprintf(f, "%lld", el->firstAdded);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->errorMessage);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%lld", el->openSuccesses);
fputc(sep,f);
fprintf(f, "%lld", el->openFails);
fputc(sep,f);
fprintf(f, "%lld", el->historyBits);
fputc(lastSep,f);
}

void edwFileStaticLoad(char **row, struct edwFile *ret)
/* Load a row from edwFile table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
safecpy(ret->licensePlate, sizeof(ret->licensePlate), row[1]);
ret->submitId = sqlUnsigned(row[2]);
ret->submitDirId = sqlUnsigned(row[3]);
ret->submitFileName = row[4];
ret->edwFileName = row[5];
ret->startUploadTime = sqlLongLong(row[6]);
ret->endUploadTime = sqlLongLong(row[7]);
ret->updateTime = sqlLongLong(row[8]);
ret->size = sqlLongLong(row[9]);
safecpy(ret->md5, sizeof(ret->md5), row[10]);
ret->tags = row[11];
ret->errorMessage = row[12];
}

struct edwFile *edwFileLoad(char **row)
/* Load a edwFile from row fetched with select * from edwFile
 * from database.  Dispose of this with edwFileFree(). */
{
struct edwFile *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
safecpy(ret->licensePlate, sizeof(ret->licensePlate), row[1]);
ret->submitId = sqlUnsigned(row[2]);
ret->submitDirId = sqlUnsigned(row[3]);
ret->submitFileName = cloneString(row[4]);
ret->edwFileName = cloneString(row[5]);
ret->startUploadTime = sqlLongLong(row[6]);
ret->endUploadTime = sqlLongLong(row[7]);
ret->updateTime = sqlLongLong(row[8]);
ret->size = sqlLongLong(row[9]);
safecpy(ret->md5, sizeof(ret->md5), row[10]);
ret->tags = cloneString(row[11]);
ret->errorMessage = cloneString(row[12]);
return ret;
}

struct edwFile *edwFileLoadAll(char *fileName) 
/* Load all edwFile from a whitespace-separated file.
 * Dispose of this with edwFileFreeList(). */
{
struct edwFile *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[13];

while (lineFileRow(lf, row))
    {
    el = edwFileLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwFile *edwFileLoadAllByChar(char *fileName, char chopper) 
/* Load all edwFile from a chopper separated file.
 * Dispose of this with edwFileFreeList(). */
{
struct edwFile *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[13];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = edwFileLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwFile *edwFileCommaIn(char **pS, struct edwFile *ret)
/* Create a edwFile out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwFile */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
sqlFixedStringComma(&s, ret->licensePlate, sizeof(ret->licensePlate));
ret->submitId = sqlUnsignedComma(&s);
ret->submitDirId = sqlUnsignedComma(&s);
ret->submitFileName = sqlStringComma(&s);
ret->edwFileName = sqlStringComma(&s);
ret->startUploadTime = sqlLongLongComma(&s);
ret->endUploadTime = sqlLongLongComma(&s);
ret->updateTime = sqlLongLongComma(&s);
ret->size = sqlLongLongComma(&s);
sqlFixedStringComma(&s, ret->md5, sizeof(ret->md5));
ret->tags = sqlStringComma(&s);
ret->errorMessage = sqlStringComma(&s);
*pS = s;
return ret;
}

void edwFileFree(struct edwFile **pEl)
/* Free a single dynamically allocated edwFile such as created
 * with edwFileLoad(). */
{
struct edwFile *el;

if ((el = *pEl) == NULL) return;
freeMem(el->submitFileName);
freeMem(el->edwFileName);
freeMem(el->tags);
freeMem(el->errorMessage);
freez(pEl);
}

void edwFileFreeList(struct edwFile **pList)
/* Free a list of dynamically allocated edwFile's */
{
struct edwFile *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    edwFileFree(&el);
    }
*pList = NULL;
}

void edwFileOutput(struct edwFile *el, FILE *f, char sep, char lastSep) 
/* Print out edwFile.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->licensePlate);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%u", el->submitId);
fputc(sep,f);
fprintf(f, "%u", el->submitDirId);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->submitFileName);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->edwFileName);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%lld", el->startUploadTime);
fputc(sep,f);
fprintf(f, "%lld", el->endUploadTime);
fputc(sep,f);
fprintf(f, "%lld", el->updateTime);
fputc(sep,f);
fprintf(f, "%lld", el->size);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->md5);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->tags);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->errorMessage);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void edwSubmitStaticLoad(char **row, struct edwSubmit *ret)
/* Load a row from edwSubmit table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->url = row[1];
ret->startUploadTime = sqlLongLong(row[2]);
ret->endUploadTime = sqlLongLong(row[3]);
ret->userId = sqlUnsigned(row[4]);
ret->submitFileId = sqlUnsigned(row[5]);
ret->submitDirId = sqlUnsigned(row[6]);
ret->fileCount = sqlUnsigned(row[7]);
ret->oldFiles = sqlUnsigned(row[8]);
ret->newFiles = sqlUnsigned(row[9]);
ret->errorMessage = row[10];
}

struct edwSubmit *edwSubmitLoad(char **row)
/* Load a edwSubmit from row fetched with select * from edwSubmit
 * from database.  Dispose of this with edwSubmitFree(). */
{
struct edwSubmit *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->url = cloneString(row[1]);
ret->startUploadTime = sqlLongLong(row[2]);
ret->endUploadTime = sqlLongLong(row[3]);
ret->userId = sqlUnsigned(row[4]);
ret->submitFileId = sqlUnsigned(row[5]);
ret->submitDirId = sqlUnsigned(row[6]);
ret->fileCount = sqlUnsigned(row[7]);
ret->oldFiles = sqlUnsigned(row[8]);
ret->newFiles = sqlUnsigned(row[9]);
ret->errorMessage = cloneString(row[10]);
return ret;
}

struct edwSubmit *edwSubmitLoadAll(char *fileName) 
/* Load all edwSubmit from a whitespace-separated file.
 * Dispose of this with edwSubmitFreeList(). */
{
struct edwSubmit *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[11];

while (lineFileRow(lf, row))
    {
    el = edwSubmitLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwSubmit *edwSubmitLoadAllByChar(char *fileName, char chopper) 
/* Load all edwSubmit from a chopper separated file.
 * Dispose of this with edwSubmitFreeList(). */
{
struct edwSubmit *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[11];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = edwSubmitLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwSubmit *edwSubmitCommaIn(char **pS, struct edwSubmit *ret)
/* Create a edwSubmit out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwSubmit */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->url = sqlStringComma(&s);
ret->startUploadTime = sqlLongLongComma(&s);
ret->endUploadTime = sqlLongLongComma(&s);
ret->userId = sqlUnsignedComma(&s);
ret->submitFileId = sqlUnsignedComma(&s);
ret->submitDirId = sqlUnsignedComma(&s);
ret->fileCount = sqlUnsignedComma(&s);
ret->oldFiles = sqlUnsignedComma(&s);
ret->newFiles = sqlUnsignedComma(&s);
ret->errorMessage = sqlStringComma(&s);
*pS = s;
return ret;
}

void edwSubmitFree(struct edwSubmit **pEl)
/* Free a single dynamically allocated edwSubmit such as created
 * with edwSubmitLoad(). */
{
struct edwSubmit *el;

if ((el = *pEl) == NULL) return;
freeMem(el->url);
freeMem(el->errorMessage);
freez(pEl);
}

void edwSubmitFreeList(struct edwSubmit **pList)
/* Free a list of dynamically allocated edwSubmit's */
{
struct edwSubmit *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    edwSubmitFree(&el);
    }
*pList = NULL;
}

void edwSubmitOutput(struct edwSubmit *el, FILE *f, char sep, char lastSep) 
/* Print out edwSubmit.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->url);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%lld", el->startUploadTime);
fputc(sep,f);
fprintf(f, "%lld", el->endUploadTime);
fputc(sep,f);
fprintf(f, "%u", el->userId);
fputc(sep,f);
fprintf(f, "%u", el->submitFileId);
fputc(sep,f);
fprintf(f, "%u", el->submitDirId);
fputc(sep,f);
fprintf(f, "%u", el->fileCount);
fputc(sep,f);
fprintf(f, "%u", el->oldFiles);
fputc(sep,f);
fprintf(f, "%u", el->newFiles);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->errorMessage);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void edwSubscriberStaticLoad(char **row, struct edwSubscriber *ret)
/* Load a row from edwSubscriber table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->name = row[1];
ret->runOrder = sqlDouble(row[2]);
ret->filePattern = row[3];
ret->dirPattern = row[4];
ret->tagPattern = row[5];
ret->onFileEndUpload = row[6];
}

struct edwSubscriber *edwSubscriberLoad(char **row)
/* Load a edwSubscriber from row fetched with select * from edwSubscriber
 * from database.  Dispose of this with edwSubscriberFree(). */
{
struct edwSubscriber *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->name = cloneString(row[1]);
ret->runOrder = sqlDouble(row[2]);
ret->filePattern = cloneString(row[3]);
ret->dirPattern = cloneString(row[4]);
ret->tagPattern = cloneString(row[5]);
ret->onFileEndUpload = cloneString(row[6]);
return ret;
}

struct edwSubscriber *edwSubscriberLoadAll(char *fileName) 
/* Load all edwSubscriber from a whitespace-separated file.
 * Dispose of this with edwSubscriberFreeList(). */
{
struct edwSubscriber *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[7];

while (lineFileRow(lf, row))
    {
    el = edwSubscriberLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwSubscriber *edwSubscriberLoadAllByChar(char *fileName, char chopper) 
/* Load all edwSubscriber from a chopper separated file.
 * Dispose of this with edwSubscriberFreeList(). */
{
struct edwSubscriber *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[7];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = edwSubscriberLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwSubscriber *edwSubscriberCommaIn(char **pS, struct edwSubscriber *ret)
/* Create a edwSubscriber out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwSubscriber */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->name = sqlStringComma(&s);
ret->runOrder = sqlDoubleComma(&s);
ret->filePattern = sqlStringComma(&s);
ret->dirPattern = sqlStringComma(&s);
ret->tagPattern = sqlStringComma(&s);
ret->onFileEndUpload = sqlStringComma(&s);
*pS = s;
return ret;
}

void edwSubscriberFree(struct edwSubscriber **pEl)
/* Free a single dynamically allocated edwSubscriber such as created
 * with edwSubscriberLoad(). */
{
struct edwSubscriber *el;

if ((el = *pEl) == NULL) return;
freeMem(el->name);
freeMem(el->filePattern);
freeMem(el->dirPattern);
freeMem(el->tagPattern);
freeMem(el->onFileEndUpload);
freez(pEl);
}

void edwSubscriberFreeList(struct edwSubscriber **pList)
/* Free a list of dynamically allocated edwSubscriber's */
{
struct edwSubscriber *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    edwSubscriberFree(&el);
    }
*pList = NULL;
}

void edwSubscriberOutput(struct edwSubscriber *el, FILE *f, char sep, char lastSep) 
/* Print out edwSubscriber.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->name);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%g", el->runOrder);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->filePattern);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->dirPattern);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->tagPattern);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->onFileEndUpload);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void edwAssemblyStaticLoad(char **row, struct edwAssembly *ret)
/* Load a row from edwAssembly table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->taxon = sqlUnsigned(row[1]);
ret->name = row[2];
ret->ucscDb = row[3];
ret->twoBitId = sqlUnsigned(row[4]);
ret->baseCount = sqlLongLong(row[5]);
}

struct edwAssembly *edwAssemblyLoad(char **row)
/* Load a edwAssembly from row fetched with select * from edwAssembly
 * from database.  Dispose of this with edwAssemblyFree(). */
{
struct edwAssembly *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->taxon = sqlUnsigned(row[1]);
ret->name = cloneString(row[2]);
ret->ucscDb = cloneString(row[3]);
ret->twoBitId = sqlUnsigned(row[4]);
ret->baseCount = sqlLongLong(row[5]);
return ret;
}

struct edwAssembly *edwAssemblyLoadAll(char *fileName) 
/* Load all edwAssembly from a whitespace-separated file.
 * Dispose of this with edwAssemblyFreeList(). */
{
struct edwAssembly *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[6];

while (lineFileRow(lf, row))
    {
    el = edwAssemblyLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwAssembly *edwAssemblyLoadAllByChar(char *fileName, char chopper) 
/* Load all edwAssembly from a chopper separated file.
 * Dispose of this with edwAssemblyFreeList(). */
{
struct edwAssembly *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[6];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = edwAssemblyLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwAssembly *edwAssemblyCommaIn(char **pS, struct edwAssembly *ret)
/* Create a edwAssembly out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwAssembly */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->taxon = sqlUnsignedComma(&s);
ret->name = sqlStringComma(&s);
ret->ucscDb = sqlStringComma(&s);
ret->twoBitId = sqlUnsignedComma(&s);
ret->baseCount = sqlLongLongComma(&s);
*pS = s;
return ret;
}

void edwAssemblyFree(struct edwAssembly **pEl)
/* Free a single dynamically allocated edwAssembly such as created
 * with edwAssemblyLoad(). */
{
struct edwAssembly *el;

if ((el = *pEl) == NULL) return;
freeMem(el->name);
freeMem(el->ucscDb);
freez(pEl);
}

void edwAssemblyFreeList(struct edwAssembly **pList)
/* Free a list of dynamically allocated edwAssembly's */
{
struct edwAssembly *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    edwAssemblyFree(&el);
    }
*pList = NULL;
}

void edwAssemblyOutput(struct edwAssembly *el, FILE *f, char sep, char lastSep) 
/* Print out edwAssembly.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
fprintf(f, "%u", el->taxon);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->name);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->ucscDb);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%u", el->twoBitId);
fputc(sep,f);
fprintf(f, "%lld", el->baseCount);
fputc(lastSep,f);
}

void edwQaFileStaticLoad(char **row, struct edwQaFile *ret)
/* Load a row from edwQaFile table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->fileId = sqlUnsigned(row[1]);
ret->itemCount = sqlLongLong(row[2]);
ret->basesInItems = sqlLongLong(row[3]);
ret->samplePath = row[4];
ret->sampleCount = sqlLongLong(row[5]);
ret->basesInSample = sqlLongLong(row[6]);
ret->preferredAssembly = sqlUnsigned(row[7]);
ret->propInAsm = sqlDouble(row[8]);
ret->asmCoverage = sqlDouble(row[9]);
}

struct edwQaFile *edwQaFileLoad(char **row)
/* Load a edwQaFile from row fetched with select * from edwQaFile
 * from database.  Dispose of this with edwQaFileFree(). */
{
struct edwQaFile *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->fileId = sqlUnsigned(row[1]);
ret->itemCount = sqlLongLong(row[2]);
ret->basesInItems = sqlLongLong(row[3]);
ret->samplePath = cloneString(row[4]);
ret->sampleCount = sqlLongLong(row[5]);
ret->basesInSample = sqlLongLong(row[6]);
ret->preferredAssembly = sqlUnsigned(row[7]);
ret->propInAsm = sqlDouble(row[8]);
ret->asmCoverage = sqlDouble(row[9]);
return ret;
}

struct edwQaFile *edwQaFileLoadAll(char *fileName) 
/* Load all edwQaFile from a whitespace-separated file.
 * Dispose of this with edwQaFileFreeList(). */
{
struct edwQaFile *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[10];

while (lineFileRow(lf, row))
    {
    el = edwQaFileLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwQaFile *edwQaFileLoadAllByChar(char *fileName, char chopper) 
/* Load all edwQaFile from a chopper separated file.
 * Dispose of this with edwQaFileFreeList(). */
{
struct edwQaFile *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[10];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = edwQaFileLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwQaFile *edwQaFileCommaIn(char **pS, struct edwQaFile *ret)
/* Create a edwQaFile out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwQaFile */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->fileId = sqlUnsignedComma(&s);
ret->itemCount = sqlLongLongComma(&s);
ret->basesInItems = sqlLongLongComma(&s);
ret->samplePath = sqlStringComma(&s);
ret->sampleCount = sqlLongLongComma(&s);
ret->basesInSample = sqlLongLongComma(&s);
ret->preferredAssembly = sqlUnsignedComma(&s);
ret->propInAsm = sqlDoubleComma(&s);
ret->asmCoverage = sqlDoubleComma(&s);
*pS = s;
return ret;
}

void edwQaFileFree(struct edwQaFile **pEl)
/* Free a single dynamically allocated edwQaFile such as created
 * with edwQaFileLoad(). */
{
struct edwQaFile *el;

if ((el = *pEl) == NULL) return;
freeMem(el->samplePath);
freez(pEl);
}

void edwQaFileFreeList(struct edwQaFile **pList)
/* Free a list of dynamically allocated edwQaFile's */
{
struct edwQaFile *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    edwQaFileFree(&el);
    }
*pList = NULL;
}

void edwQaFileOutput(struct edwQaFile *el, FILE *f, char sep, char lastSep) 
/* Print out edwQaFile.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
fprintf(f, "%u", el->fileId);
fputc(sep,f);
fprintf(f, "%lld", el->itemCount);
fputc(sep,f);
fprintf(f, "%lld", el->basesInItems);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->samplePath);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%lld", el->sampleCount);
fputc(sep,f);
fprintf(f, "%lld", el->basesInSample);
fputc(sep,f);
fprintf(f, "%u", el->preferredAssembly);
fputc(sep,f);
fprintf(f, "%g", el->propInAsm);
fputc(sep,f);
fprintf(f, "%g", el->asmCoverage);
fputc(lastSep,f);
}

void edwQaEnrichTargetStaticLoad(char **row, struct edwQaEnrichTarget *ret)
/* Load a row from edwQaEnrichTarget table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->targetName = row[1];
ret->targetFile = sqlUnsigned(row[2]);
ret->targetSize = sqlLongLong(row[3]);
}

struct edwQaEnrichTarget *edwQaEnrichTargetLoad(char **row)
/* Load a edwQaEnrichTarget from row fetched with select * from edwQaEnrichTarget
 * from database.  Dispose of this with edwQaEnrichTargetFree(). */
{
struct edwQaEnrichTarget *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->targetName = cloneString(row[1]);
ret->targetFile = sqlUnsigned(row[2]);
ret->targetSize = sqlLongLong(row[3]);
return ret;
}

struct edwQaEnrichTarget *edwQaEnrichTargetLoadAll(char *fileName) 
/* Load all edwQaEnrichTarget from a whitespace-separated file.
 * Dispose of this with edwQaEnrichTargetFreeList(). */
{
struct edwQaEnrichTarget *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileRow(lf, row))
    {
    el = edwQaEnrichTargetLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwQaEnrichTarget *edwQaEnrichTargetLoadAllByChar(char *fileName, char chopper) 
/* Load all edwQaEnrichTarget from a chopper separated file.
 * Dispose of this with edwQaEnrichTargetFreeList(). */
{
struct edwQaEnrichTarget *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = edwQaEnrichTargetLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwQaEnrichTarget *edwQaEnrichTargetCommaIn(char **pS, struct edwQaEnrichTarget *ret)
/* Create a edwQaEnrichTarget out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwQaEnrichTarget */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->targetName = sqlStringComma(&s);
ret->targetFile = sqlUnsignedComma(&s);
ret->targetSize = sqlLongLongComma(&s);
*pS = s;
return ret;
}

void edwQaEnrichTargetFree(struct edwQaEnrichTarget **pEl)
/* Free a single dynamically allocated edwQaEnrichTarget such as created
 * with edwQaEnrichTargetLoad(). */
{
struct edwQaEnrichTarget *el;

if ((el = *pEl) == NULL) return;
freeMem(el->targetName);
freez(pEl);
}

void edwQaEnrichTargetFreeList(struct edwQaEnrichTarget **pList)
/* Free a list of dynamically allocated edwQaEnrichTarget's */
{
struct edwQaEnrichTarget *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    edwQaEnrichTargetFree(&el);
    }
*pList = NULL;
}

void edwQaEnrichTargetOutput(struct edwQaEnrichTarget *el, FILE *f, char sep, char lastSep) 
/* Print out edwQaEnrichTarget.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->targetName);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%u", el->targetFile);
fputc(sep,f);
fprintf(f, "%lld", el->targetSize);
fputc(lastSep,f);
}

void edwQaEnrichStaticLoad(char **row, struct edwQaEnrich *ret)
/* Load a row from edwQaEnrich table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->qaFileId = sqlUnsigned(row[1]);
ret->qaEnrichTargetId = sqlUnsigned(row[2]);
ret->targetBaseHits = sqlLongLong(row[3]);
ret->targetUniqHits = sqlLongLong(row[4]);
ret->coverage = sqlDouble(row[5]);
ret->enrichment = sqlDouble(row[6]);
ret->uniqEnrich = sqlDouble(row[7]);
}

struct edwQaEnrich *edwQaEnrichLoad(char **row)
/* Load a edwQaEnrich from row fetched with select * from edwQaEnrich
 * from database.  Dispose of this with edwQaEnrichFree(). */
{
struct edwQaEnrich *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->qaFileId = sqlUnsigned(row[1]);
ret->qaEnrichTargetId = sqlUnsigned(row[2]);
ret->targetBaseHits = sqlLongLong(row[3]);
ret->targetUniqHits = sqlLongLong(row[4]);
ret->coverage = sqlDouble(row[5]);
ret->enrichment = sqlDouble(row[6]);
ret->uniqEnrich = sqlDouble(row[7]);
return ret;
}

struct edwQaEnrich *edwQaEnrichLoadAll(char *fileName) 
/* Load all edwQaEnrich from a whitespace-separated file.
 * Dispose of this with edwQaEnrichFreeList(). */
{
struct edwQaEnrich *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[8];

while (lineFileRow(lf, row))
    {
    el = edwQaEnrichLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwQaEnrich *edwQaEnrichLoadAllByChar(char *fileName, char chopper) 
/* Load all edwQaEnrich from a chopper separated file.
 * Dispose of this with edwQaEnrichFreeList(). */
{
struct edwQaEnrich *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[8];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = edwQaEnrichLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwQaEnrich *edwQaEnrichCommaIn(char **pS, struct edwQaEnrich *ret)
/* Create a edwQaEnrich out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwQaEnrich */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->qaFileId = sqlUnsignedComma(&s);
ret->qaEnrichTargetId = sqlUnsignedComma(&s);
ret->targetBaseHits = sqlLongLongComma(&s);
ret->targetUniqHits = sqlLongLongComma(&s);
ret->coverage = sqlDoubleComma(&s);
ret->enrichment = sqlDoubleComma(&s);
ret->uniqEnrich = sqlDoubleComma(&s);
*pS = s;
return ret;
}

void edwQaEnrichFree(struct edwQaEnrich **pEl)
/* Free a single dynamically allocated edwQaEnrich such as created
 * with edwQaEnrichLoad(). */
{
struct edwQaEnrich *el;

if ((el = *pEl) == NULL) return;
freez(pEl);
}

void edwQaEnrichFreeList(struct edwQaEnrich **pList)
/* Free a list of dynamically allocated edwQaEnrich's */
{
struct edwQaEnrich *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    edwQaEnrichFree(&el);
    }
*pList = NULL;
}

void edwQaEnrichOutput(struct edwQaEnrich *el, FILE *f, char sep, char lastSep) 
/* Print out edwQaEnrich.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
fprintf(f, "%u", el->qaFileId);
fputc(sep,f);
fprintf(f, "%u", el->qaEnrichTargetId);
fputc(sep,f);
fprintf(f, "%lld", el->targetBaseHits);
fputc(sep,f);
fprintf(f, "%lld", el->targetUniqHits);
fputc(sep,f);
fprintf(f, "%g", el->coverage);
fputc(sep,f);
fprintf(f, "%g", el->enrichment);
fputc(sep,f);
fprintf(f, "%g", el->uniqEnrich);
fputc(lastSep,f);
}

/* -------------------------------- End autoSql Generated Code -------------------------------- */

