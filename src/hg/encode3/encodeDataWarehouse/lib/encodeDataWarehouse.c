/* encodeDataWarehouse.c was originally generated by the autoSql program, which also 
 * generated encodeDataWarehouse.h and encodeDataWarehouse.sql.  This module links the database and
 * the RAM representation of objects. */

#include "common.h"
#include "linefile.h"
#include "dystring.h"
#include "jksql.h"
#include "encodeDataWarehouse.h"


void edwUserStaticLoad(char **row, struct edwUser *ret)
/* Load a row from edwUser table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

safecpy(ret->sid, sizeof(ret->sid), row[0]);
safecpy(ret->access, sizeof(ret->access), row[1]);
ret->email = row[2];
}

struct edwUser *edwUserLoad(char **row)
/* Load a edwUser from row fetched with select * from edwUser
 * from database.  Dispose of this with edwUserFree(). */
{
struct edwUser *ret;

AllocVar(ret);
safecpy(ret->sid, sizeof(ret->sid), row[0]);
safecpy(ret->access, sizeof(ret->access), row[1]);
ret->email = cloneString(row[2]);
return ret;
}

struct edwUser *edwUserLoadAll(char *fileName) 
/* Load all edwUser from a whitespace-separated file.
 * Dispose of this with edwUserFreeList(). */
{
struct edwUser *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[3];

while (lineFileRow(lf, row))
    {
    el = edwUserLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwUser *edwUserLoadAllByChar(char *fileName, char chopper) 
/* Load all edwUser from a chopper separated file.
 * Dispose of this with edwUserFreeList(). */
{
struct edwUser *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[3];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = edwUserLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwUser *edwUserCommaIn(char **pS, struct edwUser *ret)
/* Create a edwUser out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwUser */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
sqlFixedStringComma(&s, ret->sid, sizeof(ret->sid));
sqlFixedStringComma(&s, ret->access, sizeof(ret->access));
ret->email = sqlStringComma(&s);
*pS = s;
return ret;
}

void edwUserFree(struct edwUser **pEl)
/* Free a single dynamically allocated edwUser such as created
 * with edwUserLoad(). */
{
struct edwUser *el;

if ((el = *pEl) == NULL) return;
freeMem(el->email);
freez(pEl);
}

void edwUserFreeList(struct edwUser **pList)
/* Free a list of dynamically allocated edwUser's */
{
struct edwUser *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    edwUserFree(&el);
    }
*pList = NULL;
}

void edwUserOutput(struct edwUser *el, FILE *f, char sep, char lastSep) 
/* Print out edwUser.  Separate fields with sep. Follow last field with lastSep. */
{
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->sid);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->access);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->email);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void edwHostStaticLoad(char **row, struct edwHost *ret)
/* Load a row from edwHost table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->name = row[1];
ret->lastOkTime = sqlLongLong(row[2]);
ret->lastNotOkTime = sqlLongLong(row[3]);
ret->firstAdded = sqlLongLong(row[4]);
ret->errorMessage = row[5];
ret->uploadAttempts = sqlLongLong(row[6]);
ret->historyBits = sqlLongLong(row[7]);
}

struct edwHost *edwHostLoad(char **row)
/* Load a edwHost from row fetched with select * from edwHost
 * from database.  Dispose of this with edwHostFree(). */
{
struct edwHost *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->name = cloneString(row[1]);
ret->lastOkTime = sqlLongLong(row[2]);
ret->lastNotOkTime = sqlLongLong(row[3]);
ret->firstAdded = sqlLongLong(row[4]);
ret->errorMessage = cloneString(row[5]);
ret->uploadAttempts = sqlLongLong(row[6]);
ret->historyBits = sqlLongLong(row[7]);
return ret;
}

struct edwHost *edwHostLoadAll(char *fileName) 
/* Load all edwHost from a whitespace-separated file.
 * Dispose of this with edwHostFreeList(). */
{
struct edwHost *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[8];

while (lineFileRow(lf, row))
    {
    el = edwHostLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwHost *edwHostLoadAllByChar(char *fileName, char chopper) 
/* Load all edwHost from a chopper separated file.
 * Dispose of this with edwHostFreeList(). */
{
struct edwHost *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[8];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = edwHostLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwHost *edwHostCommaIn(char **pS, struct edwHost *ret)
/* Create a edwHost out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwHost */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->name = sqlStringComma(&s);
ret->lastOkTime = sqlLongLongComma(&s);
ret->lastNotOkTime = sqlLongLongComma(&s);
ret->firstAdded = sqlLongLongComma(&s);
ret->errorMessage = sqlStringComma(&s);
ret->uploadAttempts = sqlLongLongComma(&s);
ret->historyBits = sqlLongLongComma(&s);
*pS = s;
return ret;
}

void edwHostFree(struct edwHost **pEl)
/* Free a single dynamically allocated edwHost such as created
 * with edwHostLoad(). */
{
struct edwHost *el;

if ((el = *pEl) == NULL) return;
freeMem(el->name);
freeMem(el->errorMessage);
freez(pEl);
}

void edwHostFreeList(struct edwHost **pList)
/* Free a list of dynamically allocated edwHost's */
{
struct edwHost *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    edwHostFree(&el);
    }
*pList = NULL;
}

void edwHostOutput(struct edwHost *el, FILE *f, char sep, char lastSep) 
/* Print out edwHost.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->name);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%lld", el->lastOkTime);
fputc(sep,f);
fprintf(f, "%lld", el->lastNotOkTime);
fputc(sep,f);
fprintf(f, "%lld", el->firstAdded);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->errorMessage);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%lld", el->uploadAttempts);
fputc(sep,f);
fprintf(f, "%lld", el->historyBits);
fputc(lastSep,f);
}

void edwSubmissionDirStaticLoad(char **row, struct edwSubmissionDir *ret)
/* Load a row from edwSubmissionDir table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->url = row[1];
ret->hostId = sqlUnsigned(row[2]);
ret->lastOkTime = sqlLongLong(row[3]);
ret->lastNotOkTime = sqlLongLong(row[4]);
ret->firstAdded = sqlLongLong(row[5]);
ret->errorMessage = row[6];
ret->uploadAttempts = sqlLongLong(row[7]);
ret->historyBits = sqlLongLong(row[8]);
}

struct edwSubmissionDir *edwSubmissionDirLoad(char **row)
/* Load a edwSubmissionDir from row fetched with select * from edwSubmissionDir
 * from database.  Dispose of this with edwSubmissionDirFree(). */
{
struct edwSubmissionDir *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->url = cloneString(row[1]);
ret->hostId = sqlUnsigned(row[2]);
ret->lastOkTime = sqlLongLong(row[3]);
ret->lastNotOkTime = sqlLongLong(row[4]);
ret->firstAdded = sqlLongLong(row[5]);
ret->errorMessage = cloneString(row[6]);
ret->uploadAttempts = sqlLongLong(row[7]);
ret->historyBits = sqlLongLong(row[8]);
return ret;
}

struct edwSubmissionDir *edwSubmissionDirLoadAll(char *fileName) 
/* Load all edwSubmissionDir from a whitespace-separated file.
 * Dispose of this with edwSubmissionDirFreeList(). */
{
struct edwSubmissionDir *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[9];

while (lineFileRow(lf, row))
    {
    el = edwSubmissionDirLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwSubmissionDir *edwSubmissionDirLoadAllByChar(char *fileName, char chopper) 
/* Load all edwSubmissionDir from a chopper separated file.
 * Dispose of this with edwSubmissionDirFreeList(). */
{
struct edwSubmissionDir *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[9];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = edwSubmissionDirLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwSubmissionDir *edwSubmissionDirCommaIn(char **pS, struct edwSubmissionDir *ret)
/* Create a edwSubmissionDir out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwSubmissionDir */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->url = sqlStringComma(&s);
ret->hostId = sqlUnsignedComma(&s);
ret->lastOkTime = sqlLongLongComma(&s);
ret->lastNotOkTime = sqlLongLongComma(&s);
ret->firstAdded = sqlLongLongComma(&s);
ret->errorMessage = sqlStringComma(&s);
ret->uploadAttempts = sqlLongLongComma(&s);
ret->historyBits = sqlLongLongComma(&s);
*pS = s;
return ret;
}

void edwSubmissionDirFree(struct edwSubmissionDir **pEl)
/* Free a single dynamically allocated edwSubmissionDir such as created
 * with edwSubmissionDirLoad(). */
{
struct edwSubmissionDir *el;

if ((el = *pEl) == NULL) return;
freeMem(el->url);
freeMem(el->errorMessage);
freez(pEl);
}

void edwSubmissionDirFreeList(struct edwSubmissionDir **pList)
/* Free a list of dynamically allocated edwSubmissionDir's */
{
struct edwSubmissionDir *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    edwSubmissionDirFree(&el);
    }
*pList = NULL;
}

void edwSubmissionDirOutput(struct edwSubmissionDir *el, FILE *f, char sep, char lastSep) 
/* Print out edwSubmissionDir.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->url);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%u", el->hostId);
fputc(sep,f);
fprintf(f, "%lld", el->lastOkTime);
fputc(sep,f);
fprintf(f, "%lld", el->lastNotOkTime);
fputc(sep,f);
fprintf(f, "%lld", el->firstAdded);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->errorMessage);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%lld", el->uploadAttempts);
fputc(sep,f);
fprintf(f, "%lld", el->historyBits);
fputc(lastSep,f);
}

void edwFileStaticLoad(char **row, struct edwFile *ret)
/* Load a row from edwFile table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
safecpy(ret->licensePlate, sizeof(ret->licensePlate), row[1]);
ret->submissionId = sqlUnsigned(row[2]);
ret->submitFileName = row[3];
ret->edwFileName = row[4];
ret->startUploadTime = sqlLongLong(row[5]);
ret->endUploadTime = sqlLongLong(row[6]);
ret->updateTime = sqlLongLong(row[7]);
ret->size = sqlLongLong(row[8]);
safecpy(ret->md5, sizeof(ret->md5), row[9]);
ret->tags = row[10];
ret->errorMessage = row[11];
}

struct edwFile *edwFileLoad(char **row)
/* Load a edwFile from row fetched with select * from edwFile
 * from database.  Dispose of this with edwFileFree(). */
{
struct edwFile *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
safecpy(ret->licensePlate, sizeof(ret->licensePlate), row[1]);
ret->submissionId = sqlUnsigned(row[2]);
ret->submitFileName = cloneString(row[3]);
ret->edwFileName = cloneString(row[4]);
ret->startUploadTime = sqlLongLong(row[5]);
ret->endUploadTime = sqlLongLong(row[6]);
ret->updateTime = sqlLongLong(row[7]);
ret->size = sqlLongLong(row[8]);
safecpy(ret->md5, sizeof(ret->md5), row[9]);
ret->tags = cloneString(row[10]);
ret->errorMessage = cloneString(row[11]);
return ret;
}

struct edwFile *edwFileLoadAll(char *fileName) 
/* Load all edwFile from a whitespace-separated file.
 * Dispose of this with edwFileFreeList(). */
{
struct edwFile *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[12];

while (lineFileRow(lf, row))
    {
    el = edwFileLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwFile *edwFileLoadAllByChar(char *fileName, char chopper) 
/* Load all edwFile from a chopper separated file.
 * Dispose of this with edwFileFreeList(). */
{
struct edwFile *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[12];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = edwFileLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwFile *edwFileCommaIn(char **pS, struct edwFile *ret)
/* Create a edwFile out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwFile */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
sqlFixedStringComma(&s, ret->licensePlate, sizeof(ret->licensePlate));
ret->submissionId = sqlUnsignedComma(&s);
ret->submitFileName = sqlStringComma(&s);
ret->edwFileName = sqlStringComma(&s);
ret->startUploadTime = sqlLongLongComma(&s);
ret->endUploadTime = sqlLongLongComma(&s);
ret->updateTime = sqlLongLongComma(&s);
ret->size = sqlLongLongComma(&s);
sqlFixedStringComma(&s, ret->md5, sizeof(ret->md5));
ret->tags = sqlStringComma(&s);
ret->errorMessage = sqlStringComma(&s);
*pS = s;
return ret;
}

void edwFileFree(struct edwFile **pEl)
/* Free a single dynamically allocated edwFile such as created
 * with edwFileLoad(). */
{
struct edwFile *el;

if ((el = *pEl) == NULL) return;
freeMem(el->submitFileName);
freeMem(el->edwFileName);
freeMem(el->tags);
freeMem(el->errorMessage);
freez(pEl);
}

void edwFileFreeList(struct edwFile **pList)
/* Free a list of dynamically allocated edwFile's */
{
struct edwFile *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    edwFileFree(&el);
    }
*pList = NULL;
}

void edwFileOutput(struct edwFile *el, FILE *f, char sep, char lastSep) 
/* Print out edwFile.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->licensePlate);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%u", el->submissionId);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->submitFileName);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->edwFileName);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%lld", el->startUploadTime);
fputc(sep,f);
fprintf(f, "%lld", el->endUploadTime);
fputc(sep,f);
fprintf(f, "%lld", el->updateTime);
fputc(sep,f);
fprintf(f, "%lld", el->size);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->md5);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->tags);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->errorMessage);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void edwSubmissionStaticLoad(char **row, struct edwSubmission *ret)
/* Load a row from edwSubmission table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->url = row[1];
ret->startUploadTime = sqlLongLong(row[2]);
ret->endUploadTime = sqlLongLong(row[3]);
safecpy(ret->userSid, sizeof(ret->userSid), row[4]);
ret->submitFileId = sqlUnsigned(row[5]);
ret->submissionDirId = sqlUnsigned(row[6]);
ret->fileCount = sqlUnsigned(row[7]);
ret->errorMessage = row[8];
}

struct edwSubmission *edwSubmissionLoad(char **row)
/* Load a edwSubmission from row fetched with select * from edwSubmission
 * from database.  Dispose of this with edwSubmissionFree(). */
{
struct edwSubmission *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->url = cloneString(row[1]);
ret->startUploadTime = sqlLongLong(row[2]);
ret->endUploadTime = sqlLongLong(row[3]);
safecpy(ret->userSid, sizeof(ret->userSid), row[4]);
ret->submitFileId = sqlUnsigned(row[5]);
ret->submissionDirId = sqlUnsigned(row[6]);
ret->fileCount = sqlUnsigned(row[7]);
ret->errorMessage = cloneString(row[8]);
return ret;
}

struct edwSubmission *edwSubmissionLoadAll(char *fileName) 
/* Load all edwSubmission from a whitespace-separated file.
 * Dispose of this with edwSubmissionFreeList(). */
{
struct edwSubmission *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[9];

while (lineFileRow(lf, row))
    {
    el = edwSubmissionLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwSubmission *edwSubmissionLoadAllByChar(char *fileName, char chopper) 
/* Load all edwSubmission from a chopper separated file.
 * Dispose of this with edwSubmissionFreeList(). */
{
struct edwSubmission *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[9];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = edwSubmissionLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwSubmission *edwSubmissionCommaIn(char **pS, struct edwSubmission *ret)
/* Create a edwSubmission out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwSubmission */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->url = sqlStringComma(&s);
ret->startUploadTime = sqlLongLongComma(&s);
ret->endUploadTime = sqlLongLongComma(&s);
sqlFixedStringComma(&s, ret->userSid, sizeof(ret->userSid));
ret->submitFileId = sqlUnsignedComma(&s);
ret->submissionDirId = sqlUnsignedComma(&s);
ret->fileCount = sqlUnsignedComma(&s);
ret->errorMessage = sqlStringComma(&s);
*pS = s;
return ret;
}

void edwSubmissionFree(struct edwSubmission **pEl)
/* Free a single dynamically allocated edwSubmission such as created
 * with edwSubmissionLoad(). */
{
struct edwSubmission *el;

if ((el = *pEl) == NULL) return;
freeMem(el->url);
freeMem(el->errorMessage);
freez(pEl);
}

void edwSubmissionFreeList(struct edwSubmission **pList)
/* Free a list of dynamically allocated edwSubmission's */
{
struct edwSubmission *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    edwSubmissionFree(&el);
    }
*pList = NULL;
}

void edwSubmissionOutput(struct edwSubmission *el, FILE *f, char sep, char lastSep) 
/* Print out edwSubmission.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->url);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%lld", el->startUploadTime);
fputc(sep,f);
fprintf(f, "%lld", el->endUploadTime);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->userSid);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%u", el->submitFileId);
fputc(sep,f);
fprintf(f, "%u", el->submissionDirId);
fputc(sep,f);
fprintf(f, "%u", el->fileCount);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->errorMessage);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void edwSubmissionLogStaticLoad(char **row, struct edwSubmissionLog *ret)
/* Load a row from edwSubmissionLog table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->submissionId = sqlUnsigned(row[1]);
ret->message = row[2];
}

struct edwSubmissionLog *edwSubmissionLogLoad(char **row)
/* Load a edwSubmissionLog from row fetched with select * from edwSubmissionLog
 * from database.  Dispose of this with edwSubmissionLogFree(). */
{
struct edwSubmissionLog *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->submissionId = sqlUnsigned(row[1]);
ret->message = cloneString(row[2]);
return ret;
}

struct edwSubmissionLog *edwSubmissionLogLoadAll(char *fileName) 
/* Load all edwSubmissionLog from a whitespace-separated file.
 * Dispose of this with edwSubmissionLogFreeList(). */
{
struct edwSubmissionLog *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[3];

while (lineFileRow(lf, row))
    {
    el = edwSubmissionLogLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwSubmissionLog *edwSubmissionLogLoadAllByChar(char *fileName, char chopper) 
/* Load all edwSubmissionLog from a chopper separated file.
 * Dispose of this with edwSubmissionLogFreeList(). */
{
struct edwSubmissionLog *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[3];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = edwSubmissionLogLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwSubmissionLog *edwSubmissionLogCommaIn(char **pS, struct edwSubmissionLog *ret)
/* Create a edwSubmissionLog out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwSubmissionLog */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->submissionId = sqlUnsignedComma(&s);
ret->message = sqlStringComma(&s);
*pS = s;
return ret;
}

void edwSubmissionLogFree(struct edwSubmissionLog **pEl)
/* Free a single dynamically allocated edwSubmissionLog such as created
 * with edwSubmissionLogLoad(). */
{
struct edwSubmissionLog *el;

if ((el = *pEl) == NULL) return;
freeMem(el->message);
freez(pEl);
}

void edwSubmissionLogFreeList(struct edwSubmissionLog **pList)
/* Free a list of dynamically allocated edwSubmissionLog's */
{
struct edwSubmissionLog *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    edwSubmissionLogFree(&el);
    }
*pList = NULL;
}

void edwSubmissionLogOutput(struct edwSubmissionLog *el, FILE *f, char sep, char lastSep) 
/* Print out edwSubmissionLog.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
fprintf(f, "%u", el->submissionId);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->message);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void edwSubscribingProgramStaticLoad(char **row, struct edwSubscribingProgram *ret)
/* Load a row from edwSubscribingProgram table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->runOrder = sqlDouble(row[1]);
ret->filePattern = row[2];
ret->hubPattern = row[3];
ret->tagPattern = row[4];
ret->onFileStartUpload = row[5];
ret->onFileEndUpload = row[6];
ret->onSubmissionStartUpload = row[7];
ret->onSubmissionEndUpload = row[8];
}

struct edwSubscribingProgram *edwSubscribingProgramLoad(char **row)
/* Load a edwSubscribingProgram from row fetched with select * from edwSubscribingProgram
 * from database.  Dispose of this with edwSubscribingProgramFree(). */
{
struct edwSubscribingProgram *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->runOrder = sqlDouble(row[1]);
ret->filePattern = cloneString(row[2]);
ret->hubPattern = cloneString(row[3]);
ret->tagPattern = cloneString(row[4]);
ret->onFileStartUpload = cloneString(row[5]);
ret->onFileEndUpload = cloneString(row[6]);
ret->onSubmissionStartUpload = cloneString(row[7]);
ret->onSubmissionEndUpload = cloneString(row[8]);
return ret;
}

struct edwSubscribingProgram *edwSubscribingProgramLoadAll(char *fileName) 
/* Load all edwSubscribingProgram from a whitespace-separated file.
 * Dispose of this with edwSubscribingProgramFreeList(). */
{
struct edwSubscribingProgram *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[9];

while (lineFileRow(lf, row))
    {
    el = edwSubscribingProgramLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwSubscribingProgram *edwSubscribingProgramLoadAllByChar(char *fileName, char chopper) 
/* Load all edwSubscribingProgram from a chopper separated file.
 * Dispose of this with edwSubscribingProgramFreeList(). */
{
struct edwSubscribingProgram *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[9];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = edwSubscribingProgramLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwSubscribingProgram *edwSubscribingProgramCommaIn(char **pS, struct edwSubscribingProgram *ret)
/* Create a edwSubscribingProgram out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwSubscribingProgram */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->runOrder = sqlDoubleComma(&s);
ret->filePattern = sqlStringComma(&s);
ret->hubPattern = sqlStringComma(&s);
ret->tagPattern = sqlStringComma(&s);
ret->onFileStartUpload = sqlStringComma(&s);
ret->onFileEndUpload = sqlStringComma(&s);
ret->onSubmissionStartUpload = sqlStringComma(&s);
ret->onSubmissionEndUpload = sqlStringComma(&s);
*pS = s;
return ret;
}

void edwSubscribingProgramFree(struct edwSubscribingProgram **pEl)
/* Free a single dynamically allocated edwSubscribingProgram such as created
 * with edwSubscribingProgramLoad(). */
{
struct edwSubscribingProgram *el;

if ((el = *pEl) == NULL) return;
freeMem(el->filePattern);
freeMem(el->hubPattern);
freeMem(el->tagPattern);
freeMem(el->onFileStartUpload);
freeMem(el->onFileEndUpload);
freeMem(el->onSubmissionStartUpload);
freeMem(el->onSubmissionEndUpload);
freez(pEl);
}

void edwSubscribingProgramFreeList(struct edwSubscribingProgram **pList)
/* Free a list of dynamically allocated edwSubscribingProgram's */
{
struct edwSubscribingProgram *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    edwSubscribingProgramFree(&el);
    }
*pList = NULL;
}

void edwSubscribingProgramOutput(struct edwSubscribingProgram *el, FILE *f, char sep, char lastSep) 
/* Print out edwSubscribingProgram.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
fprintf(f, "%g", el->runOrder);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->filePattern);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->hubPattern);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->tagPattern);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->onFileStartUpload);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->onFileEndUpload);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->onSubmissionStartUpload);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->onSubmissionEndUpload);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

/* -------------------------------- End autoSql Generated Code -------------------------------- */

