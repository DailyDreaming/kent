/* encodeDataWarehouse.c was originally generated by the autoSql program, which also 
 * generated encodeDataWarehouse.h and encodeDataWarehouse.sql.  This module links the database and
 * the RAM representation of objects. */

#include "common.h"
#include "linefile.h"
#include "dystring.h"
#include "jksql.h"
#include "encodeDataWarehouse.h"


void edwUserStaticLoad(char **row, struct edwUser *ret)
/* Load a row from edwUser table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->name = row[1];
safecpy(ret->sid, sizeof(ret->sid), row[2]);
safecpy(ret->access, sizeof(ret->access), row[3]);
ret->email = row[4];
}

struct edwUser *edwUserLoad(char **row)
/* Load a edwUser from row fetched with select * from edwUser
 * from database.  Dispose of this with edwUserFree(). */
{
struct edwUser *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->name = cloneString(row[1]);
safecpy(ret->sid, sizeof(ret->sid), row[2]);
safecpy(ret->access, sizeof(ret->access), row[3]);
ret->email = cloneString(row[4]);
return ret;
}

struct edwUser *edwUserLoadAll(char *fileName) 
/* Load all edwUser from a whitespace-separated file.
 * Dispose of this with edwUserFreeList(). */
{
struct edwUser *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[5];

while (lineFileRow(lf, row))
    {
    el = edwUserLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwUser *edwUserLoadAllByChar(char *fileName, char chopper) 
/* Load all edwUser from a chopper separated file.
 * Dispose of this with edwUserFreeList(). */
{
struct edwUser *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[5];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = edwUserLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwUser *edwUserCommaIn(char **pS, struct edwUser *ret)
/* Create a edwUser out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwUser */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->name = sqlStringComma(&s);
sqlFixedStringComma(&s, ret->sid, sizeof(ret->sid));
sqlFixedStringComma(&s, ret->access, sizeof(ret->access));
ret->email = sqlStringComma(&s);
*pS = s;
return ret;
}

void edwUserFree(struct edwUser **pEl)
/* Free a single dynamically allocated edwUser such as created
 * with edwUserLoad(). */
{
struct edwUser *el;

if ((el = *pEl) == NULL) return;
freeMem(el->name);
freeMem(el->email);
freez(pEl);
}

void edwUserFreeList(struct edwUser **pList)
/* Free a list of dynamically allocated edwUser's */
{
struct edwUser *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    edwUserFree(&el);
    }
*pList = NULL;
}

void edwUserOutput(struct edwUser *el, FILE *f, char sep, char lastSep) 
/* Print out edwUser.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->name);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->sid);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->access);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->email);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void edwHostStaticLoad(char **row, struct edwHost *ret)
/* Load a row from edwHost table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->name = row[1];
ret->lastOkTime = sqlLongLong(row[2]);
ret->lastNotOkTime = sqlLongLong(row[3]);
ret->firstAdded = sqlLongLong(row[4]);
ret->errorMessage = row[5];
ret->openSuccesses = sqlLongLong(row[6]);
ret->openFails = sqlLongLong(row[7]);
ret->historyBits = sqlLongLong(row[8]);
}

struct edwHost *edwHostLoad(char **row)
/* Load a edwHost from row fetched with select * from edwHost
 * from database.  Dispose of this with edwHostFree(). */
{
struct edwHost *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->name = cloneString(row[1]);
ret->lastOkTime = sqlLongLong(row[2]);
ret->lastNotOkTime = sqlLongLong(row[3]);
ret->firstAdded = sqlLongLong(row[4]);
ret->errorMessage = cloneString(row[5]);
ret->openSuccesses = sqlLongLong(row[6]);
ret->openFails = sqlLongLong(row[7]);
ret->historyBits = sqlLongLong(row[8]);
return ret;
}

struct edwHost *edwHostLoadAll(char *fileName) 
/* Load all edwHost from a whitespace-separated file.
 * Dispose of this with edwHostFreeList(). */
{
struct edwHost *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[9];

while (lineFileRow(lf, row))
    {
    el = edwHostLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwHost *edwHostLoadAllByChar(char *fileName, char chopper) 
/* Load all edwHost from a chopper separated file.
 * Dispose of this with edwHostFreeList(). */
{
struct edwHost *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[9];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = edwHostLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwHost *edwHostCommaIn(char **pS, struct edwHost *ret)
/* Create a edwHost out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwHost */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->name = sqlStringComma(&s);
ret->lastOkTime = sqlLongLongComma(&s);
ret->lastNotOkTime = sqlLongLongComma(&s);
ret->firstAdded = sqlLongLongComma(&s);
ret->errorMessage = sqlStringComma(&s);
ret->openSuccesses = sqlLongLongComma(&s);
ret->openFails = sqlLongLongComma(&s);
ret->historyBits = sqlLongLongComma(&s);
*pS = s;
return ret;
}

void edwHostFree(struct edwHost **pEl)
/* Free a single dynamically allocated edwHost such as created
 * with edwHostLoad(). */
{
struct edwHost *el;

if ((el = *pEl) == NULL) return;
freeMem(el->name);
freeMem(el->errorMessage);
freez(pEl);
}

void edwHostFreeList(struct edwHost **pList)
/* Free a list of dynamically allocated edwHost's */
{
struct edwHost *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    edwHostFree(&el);
    }
*pList = NULL;
}

void edwHostOutput(struct edwHost *el, FILE *f, char sep, char lastSep) 
/* Print out edwHost.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->name);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%lld", el->lastOkTime);
fputc(sep,f);
fprintf(f, "%lld", el->lastNotOkTime);
fputc(sep,f);
fprintf(f, "%lld", el->firstAdded);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->errorMessage);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%lld", el->openSuccesses);
fputc(sep,f);
fprintf(f, "%lld", el->openFails);
fputc(sep,f);
fprintf(f, "%lld", el->historyBits);
fputc(lastSep,f);
}

void edwSubmitDirStaticLoad(char **row, struct edwSubmitDir *ret)
/* Load a row from edwSubmitDir table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->url = row[1];
ret->hostId = sqlUnsigned(row[2]);
ret->lastOkTime = sqlLongLong(row[3]);
ret->lastNotOkTime = sqlLongLong(row[4]);
ret->firstAdded = sqlLongLong(row[5]);
ret->errorMessage = row[6];
ret->openSuccesses = sqlLongLong(row[7]);
ret->openFails = sqlLongLong(row[8]);
ret->historyBits = sqlLongLong(row[9]);
}

struct edwSubmitDir *edwSubmitDirLoad(char **row)
/* Load a edwSubmitDir from row fetched with select * from edwSubmitDir
 * from database.  Dispose of this with edwSubmitDirFree(). */
{
struct edwSubmitDir *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->url = cloneString(row[1]);
ret->hostId = sqlUnsigned(row[2]);
ret->lastOkTime = sqlLongLong(row[3]);
ret->lastNotOkTime = sqlLongLong(row[4]);
ret->firstAdded = sqlLongLong(row[5]);
ret->errorMessage = cloneString(row[6]);
ret->openSuccesses = sqlLongLong(row[7]);
ret->openFails = sqlLongLong(row[8]);
ret->historyBits = sqlLongLong(row[9]);
return ret;
}

struct edwSubmitDir *edwSubmitDirLoadAll(char *fileName) 
/* Load all edwSubmitDir from a whitespace-separated file.
 * Dispose of this with edwSubmitDirFreeList(). */
{
struct edwSubmitDir *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[10];

while (lineFileRow(lf, row))
    {
    el = edwSubmitDirLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwSubmitDir *edwSubmitDirLoadAllByChar(char *fileName, char chopper) 
/* Load all edwSubmitDir from a chopper separated file.
 * Dispose of this with edwSubmitDirFreeList(). */
{
struct edwSubmitDir *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[10];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = edwSubmitDirLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwSubmitDir *edwSubmitDirCommaIn(char **pS, struct edwSubmitDir *ret)
/* Create a edwSubmitDir out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwSubmitDir */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->url = sqlStringComma(&s);
ret->hostId = sqlUnsignedComma(&s);
ret->lastOkTime = sqlLongLongComma(&s);
ret->lastNotOkTime = sqlLongLongComma(&s);
ret->firstAdded = sqlLongLongComma(&s);
ret->errorMessage = sqlStringComma(&s);
ret->openSuccesses = sqlLongLongComma(&s);
ret->openFails = sqlLongLongComma(&s);
ret->historyBits = sqlLongLongComma(&s);
*pS = s;
return ret;
}

void edwSubmitDirFree(struct edwSubmitDir **pEl)
/* Free a single dynamically allocated edwSubmitDir such as created
 * with edwSubmitDirLoad(). */
{
struct edwSubmitDir *el;

if ((el = *pEl) == NULL) return;
freeMem(el->url);
freeMem(el->errorMessage);
freez(pEl);
}

void edwSubmitDirFreeList(struct edwSubmitDir **pList)
/* Free a list of dynamically allocated edwSubmitDir's */
{
struct edwSubmitDir *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    edwSubmitDirFree(&el);
    }
*pList = NULL;
}

void edwSubmitDirOutput(struct edwSubmitDir *el, FILE *f, char sep, char lastSep) 
/* Print out edwSubmitDir.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->url);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%u", el->hostId);
fputc(sep,f);
fprintf(f, "%lld", el->lastOkTime);
fputc(sep,f);
fprintf(f, "%lld", el->lastNotOkTime);
fputc(sep,f);
fprintf(f, "%lld", el->firstAdded);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->errorMessage);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%lld", el->openSuccesses);
fputc(sep,f);
fprintf(f, "%lld", el->openFails);
fputc(sep,f);
fprintf(f, "%lld", el->historyBits);
fputc(lastSep,f);
}

void edwFileStaticLoad(char **row, struct edwFile *ret)
/* Load a row from edwFile table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
safecpy(ret->licensePlate, sizeof(ret->licensePlate), row[1]);
ret->submitId = sqlUnsigned(row[2]);
ret->submitDirId = sqlUnsigned(row[3]);
ret->submitFileName = row[4];
ret->edwFileName = row[5];
ret->startUploadTime = sqlLongLong(row[6]);
ret->endUploadTime = sqlLongLong(row[7]);
ret->updateTime = sqlLongLong(row[8]);
ret->size = sqlLongLong(row[9]);
safecpy(ret->md5, sizeof(ret->md5), row[10]);
ret->tags = row[11];
ret->errorMessage = row[12];
}

struct edwFile *edwFileLoad(char **row)
/* Load a edwFile from row fetched with select * from edwFile
 * from database.  Dispose of this with edwFileFree(). */
{
struct edwFile *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
safecpy(ret->licensePlate, sizeof(ret->licensePlate), row[1]);
ret->submitId = sqlUnsigned(row[2]);
ret->submitDirId = sqlUnsigned(row[3]);
ret->submitFileName = cloneString(row[4]);
ret->edwFileName = cloneString(row[5]);
ret->startUploadTime = sqlLongLong(row[6]);
ret->endUploadTime = sqlLongLong(row[7]);
ret->updateTime = sqlLongLong(row[8]);
ret->size = sqlLongLong(row[9]);
safecpy(ret->md5, sizeof(ret->md5), row[10]);
ret->tags = cloneString(row[11]);
ret->errorMessage = cloneString(row[12]);
return ret;
}

struct edwFile *edwFileLoadAll(char *fileName) 
/* Load all edwFile from a whitespace-separated file.
 * Dispose of this with edwFileFreeList(). */
{
struct edwFile *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[13];

while (lineFileRow(lf, row))
    {
    el = edwFileLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwFile *edwFileLoadAllByChar(char *fileName, char chopper) 
/* Load all edwFile from a chopper separated file.
 * Dispose of this with edwFileFreeList(). */
{
struct edwFile *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[13];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = edwFileLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwFile *edwFileCommaIn(char **pS, struct edwFile *ret)
/* Create a edwFile out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwFile */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
sqlFixedStringComma(&s, ret->licensePlate, sizeof(ret->licensePlate));
ret->submitId = sqlUnsignedComma(&s);
ret->submitDirId = sqlUnsignedComma(&s);
ret->submitFileName = sqlStringComma(&s);
ret->edwFileName = sqlStringComma(&s);
ret->startUploadTime = sqlLongLongComma(&s);
ret->endUploadTime = sqlLongLongComma(&s);
ret->updateTime = sqlLongLongComma(&s);
ret->size = sqlLongLongComma(&s);
sqlFixedStringComma(&s, ret->md5, sizeof(ret->md5));
ret->tags = sqlStringComma(&s);
ret->errorMessage = sqlStringComma(&s);
*pS = s;
return ret;
}

void edwFileFree(struct edwFile **pEl)
/* Free a single dynamically allocated edwFile such as created
 * with edwFileLoad(). */
{
struct edwFile *el;

if ((el = *pEl) == NULL) return;
freeMem(el->submitFileName);
freeMem(el->edwFileName);
freeMem(el->tags);
freeMem(el->errorMessage);
freez(pEl);
}

void edwFileFreeList(struct edwFile **pList)
/* Free a list of dynamically allocated edwFile's */
{
struct edwFile *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    edwFileFree(&el);
    }
*pList = NULL;
}

void edwFileOutput(struct edwFile *el, FILE *f, char sep, char lastSep) 
/* Print out edwFile.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->licensePlate);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%u", el->submitId);
fputc(sep,f);
fprintf(f, "%u", el->submitDirId);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->submitFileName);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->edwFileName);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%lld", el->startUploadTime);
fputc(sep,f);
fprintf(f, "%lld", el->endUploadTime);
fputc(sep,f);
fprintf(f, "%lld", el->updateTime);
fputc(sep,f);
fprintf(f, "%lld", el->size);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->md5);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->tags);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->errorMessage);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void edwSubmitStaticLoad(char **row, struct edwSubmit *ret)
/* Load a row from edwSubmit table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->url = row[1];
ret->startUploadTime = sqlLongLong(row[2]);
ret->endUploadTime = sqlLongLong(row[3]);
ret->userId = sqlUnsigned(row[4]);
ret->submitFileId = sqlUnsigned(row[5]);
ret->submitDirId = sqlUnsigned(row[6]);
ret->fileCount = sqlUnsigned(row[7]);
ret->oldFiles = sqlUnsigned(row[8]);
ret->newFiles = sqlUnsigned(row[9]);
ret->errorMessage = row[10];
}

struct edwSubmit *edwSubmitLoad(char **row)
/* Load a edwSubmit from row fetched with select * from edwSubmit
 * from database.  Dispose of this with edwSubmitFree(). */
{
struct edwSubmit *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->url = cloneString(row[1]);
ret->startUploadTime = sqlLongLong(row[2]);
ret->endUploadTime = sqlLongLong(row[3]);
ret->userId = sqlUnsigned(row[4]);
ret->submitFileId = sqlUnsigned(row[5]);
ret->submitDirId = sqlUnsigned(row[6]);
ret->fileCount = sqlUnsigned(row[7]);
ret->oldFiles = sqlUnsigned(row[8]);
ret->newFiles = sqlUnsigned(row[9]);
ret->errorMessage = cloneString(row[10]);
return ret;
}

struct edwSubmit *edwSubmitLoadAll(char *fileName) 
/* Load all edwSubmit from a whitespace-separated file.
 * Dispose of this with edwSubmitFreeList(). */
{
struct edwSubmit *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[11];

while (lineFileRow(lf, row))
    {
    el = edwSubmitLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwSubmit *edwSubmitLoadAllByChar(char *fileName, char chopper) 
/* Load all edwSubmit from a chopper separated file.
 * Dispose of this with edwSubmitFreeList(). */
{
struct edwSubmit *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[11];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = edwSubmitLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwSubmit *edwSubmitCommaIn(char **pS, struct edwSubmit *ret)
/* Create a edwSubmit out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwSubmit */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->url = sqlStringComma(&s);
ret->startUploadTime = sqlLongLongComma(&s);
ret->endUploadTime = sqlLongLongComma(&s);
ret->userId = sqlUnsignedComma(&s);
ret->submitFileId = sqlUnsignedComma(&s);
ret->submitDirId = sqlUnsignedComma(&s);
ret->fileCount = sqlUnsignedComma(&s);
ret->oldFiles = sqlUnsignedComma(&s);
ret->newFiles = sqlUnsignedComma(&s);
ret->errorMessage = sqlStringComma(&s);
*pS = s;
return ret;
}

void edwSubmitFree(struct edwSubmit **pEl)
/* Free a single dynamically allocated edwSubmit such as created
 * with edwSubmitLoad(). */
{
struct edwSubmit *el;

if ((el = *pEl) == NULL) return;
freeMem(el->url);
freeMem(el->errorMessage);
freez(pEl);
}

void edwSubmitFreeList(struct edwSubmit **pList)
/* Free a list of dynamically allocated edwSubmit's */
{
struct edwSubmit *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    edwSubmitFree(&el);
    }
*pList = NULL;
}

void edwSubmitOutput(struct edwSubmit *el, FILE *f, char sep, char lastSep) 
/* Print out edwSubmit.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->url);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%lld", el->startUploadTime);
fputc(sep,f);
fprintf(f, "%lld", el->endUploadTime);
fputc(sep,f);
fprintf(f, "%u", el->userId);
fputc(sep,f);
fprintf(f, "%u", el->submitFileId);
fputc(sep,f);
fprintf(f, "%u", el->submitDirId);
fputc(sep,f);
fprintf(f, "%u", el->fileCount);
fputc(sep,f);
fprintf(f, "%u", el->oldFiles);
fputc(sep,f);
fprintf(f, "%u", el->newFiles);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->errorMessage);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void edwSubscriberStaticLoad(char **row, struct edwSubscriber *ret)
/* Load a row from edwSubscriber table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->name = row[1];
ret->runOrder = sqlDouble(row[2]);
ret->filePattern = row[3];
ret->dirPattern = row[4];
ret->onFileStartUpload = row[5];
ret->onFileEndUpload = row[6];
ret->onSubmitStartUpload = row[7];
ret->onSubmitEndUpload = row[8];
}

struct edwSubscriber *edwSubscriberLoad(char **row)
/* Load a edwSubscriber from row fetched with select * from edwSubscriber
 * from database.  Dispose of this with edwSubscriberFree(). */
{
struct edwSubscriber *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->name = cloneString(row[1]);
ret->runOrder = sqlDouble(row[2]);
ret->filePattern = cloneString(row[3]);
ret->dirPattern = cloneString(row[4]);
ret->onFileStartUpload = cloneString(row[5]);
ret->onFileEndUpload = cloneString(row[6]);
ret->onSubmitStartUpload = cloneString(row[7]);
ret->onSubmitEndUpload = cloneString(row[8]);
return ret;
}

struct edwSubscriber *edwSubscriberLoadAll(char *fileName) 
/* Load all edwSubscriber from a whitespace-separated file.
 * Dispose of this with edwSubscriberFreeList(). */
{
struct edwSubscriber *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[9];

while (lineFileRow(lf, row))
    {
    el = edwSubscriberLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwSubscriber *edwSubscriberLoadAllByChar(char *fileName, char chopper) 
/* Load all edwSubscriber from a chopper separated file.
 * Dispose of this with edwSubscriberFreeList(). */
{
struct edwSubscriber *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[9];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = edwSubscriberLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwSubscriber *edwSubscriberCommaIn(char **pS, struct edwSubscriber *ret)
/* Create a edwSubscriber out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwSubscriber */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->name = sqlStringComma(&s);
ret->runOrder = sqlDoubleComma(&s);
ret->filePattern = sqlStringComma(&s);
ret->dirPattern = sqlStringComma(&s);
ret->onFileStartUpload = sqlStringComma(&s);
ret->onFileEndUpload = sqlStringComma(&s);
ret->onSubmitStartUpload = sqlStringComma(&s);
ret->onSubmitEndUpload = sqlStringComma(&s);
*pS = s;
return ret;
}

void edwSubscriberFree(struct edwSubscriber **pEl)
/* Free a single dynamically allocated edwSubscriber such as created
 * with edwSubscriberLoad(). */
{
struct edwSubscriber *el;

if ((el = *pEl) == NULL) return;
freeMem(el->name);
freeMem(el->filePattern);
freeMem(el->dirPattern);
freeMem(el->onFileStartUpload);
freeMem(el->onFileEndUpload);
freeMem(el->onSubmitStartUpload);
freeMem(el->onSubmitEndUpload);
freez(pEl);
}

void edwSubscriberFreeList(struct edwSubscriber **pList)
/* Free a list of dynamically allocated edwSubscriber's */
{
struct edwSubscriber *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    edwSubscriberFree(&el);
    }
*pList = NULL;
}

void edwSubscriberOutput(struct edwSubscriber *el, FILE *f, char sep, char lastSep) 
/* Print out edwSubscriber.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->name);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%g", el->runOrder);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->filePattern);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->dirPattern);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->onFileStartUpload);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->onFileEndUpload);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->onSubmitStartUpload);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->onSubmitEndUpload);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

/* -------------------------------- End autoSql Generated Code -------------------------------- */

