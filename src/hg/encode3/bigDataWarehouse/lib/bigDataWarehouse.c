/* bigDataWarehouse.c was originally generated by the autoSql program, which also 
 * generated bigDataWarehouse.h and bigDataWarehouse.sql.  This module links the database and
 * the RAM representation of objects. */

#include "common.h"
#include "linefile.h"
#include "dystring.h"
#include "jksql.h"
#include "bigDataWarehouse.h"


void bdwUserStaticLoad(char **row, struct bdwUser *ret)
/* Load a row from bdwUser table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

safecpy(ret->sid, sizeof(ret->sid), row[0]);
safecpy(ret->access, sizeof(ret->access), row[1]);
ret->email = row[2];
}

struct bdwUser *bdwUserLoad(char **row)
/* Load a bdwUser from row fetched with select * from bdwUser
 * from database.  Dispose of this with bdwUserFree(). */
{
struct bdwUser *ret;

AllocVar(ret);
safecpy(ret->sid, sizeof(ret->sid), row[0]);
safecpy(ret->access, sizeof(ret->access), row[1]);
ret->email = cloneString(row[2]);
return ret;
}

struct bdwUser *bdwUserLoadAll(char *fileName) 
/* Load all bdwUser from a whitespace-separated file.
 * Dispose of this with bdwUserFreeList(). */
{
struct bdwUser *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[3];

while (lineFileRow(lf, row))
    {
    el = bdwUserLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct bdwUser *bdwUserLoadAllByChar(char *fileName, char chopper) 
/* Load all bdwUser from a chopper separated file.
 * Dispose of this with bdwUserFreeList(). */
{
struct bdwUser *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[3];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = bdwUserLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct bdwUser *bdwUserCommaIn(char **pS, struct bdwUser *ret)
/* Create a bdwUser out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new bdwUser */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
sqlFixedStringComma(&s, ret->sid, sizeof(ret->sid));
sqlFixedStringComma(&s, ret->access, sizeof(ret->access));
ret->email = sqlStringComma(&s);
*pS = s;
return ret;
}

void bdwUserFree(struct bdwUser **pEl)
/* Free a single dynamically allocated bdwUser such as created
 * with bdwUserLoad(). */
{
struct bdwUser *el;

if ((el = *pEl) == NULL) return;
freeMem(el->email);
freez(pEl);
}

void bdwUserFreeList(struct bdwUser **pList)
/* Free a list of dynamically allocated bdwUser's */
{
struct bdwUser *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    bdwUserFree(&el);
    }
*pList = NULL;
}

void bdwUserOutput(struct bdwUser *el, FILE *f, char sep, char lastSep) 
/* Print out bdwUser.  Separate fields with sep. Follow last field with lastSep. */
{
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->sid);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->access);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->email);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void bdwHostStaticLoad(char **row, struct bdwHost *ret)
/* Load a row from bdwHost table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->name = row[1];
ret->lastOkTime = sqlLongLong(row[2]);
ret->lastNotOkTime = sqlLongLong(row[3]);
ret->firstAdded = sqlLongLong(row[4]);
ret->errorMessage = row[5];
ret->uploadCount = sqlLongLong(row[6]);
ret->historyBits = sqlLongLong(row[7]);
}

struct bdwHost *bdwHostLoad(char **row)
/* Load a bdwHost from row fetched with select * from bdwHost
 * from database.  Dispose of this with bdwHostFree(). */
{
struct bdwHost *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->name = cloneString(row[1]);
ret->lastOkTime = sqlLongLong(row[2]);
ret->lastNotOkTime = sqlLongLong(row[3]);
ret->firstAdded = sqlLongLong(row[4]);
ret->errorMessage = cloneString(row[5]);
ret->uploadCount = sqlLongLong(row[6]);
ret->historyBits = sqlLongLong(row[7]);
return ret;
}

struct bdwHost *bdwHostLoadAll(char *fileName) 
/* Load all bdwHost from a whitespace-separated file.
 * Dispose of this with bdwHostFreeList(). */
{
struct bdwHost *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[8];

while (lineFileRow(lf, row))
    {
    el = bdwHostLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct bdwHost *bdwHostLoadAllByChar(char *fileName, char chopper) 
/* Load all bdwHost from a chopper separated file.
 * Dispose of this with bdwHostFreeList(). */
{
struct bdwHost *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[8];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = bdwHostLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct bdwHost *bdwHostCommaIn(char **pS, struct bdwHost *ret)
/* Create a bdwHost out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new bdwHost */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->name = sqlStringComma(&s);
ret->lastOkTime = sqlLongLongComma(&s);
ret->lastNotOkTime = sqlLongLongComma(&s);
ret->firstAdded = sqlLongLongComma(&s);
ret->errorMessage = sqlStringComma(&s);
ret->uploadCount = sqlLongLongComma(&s);
ret->historyBits = sqlLongLongComma(&s);
*pS = s;
return ret;
}

void bdwHostFree(struct bdwHost **pEl)
/* Free a single dynamically allocated bdwHost such as created
 * with bdwHostLoad(). */
{
struct bdwHost *el;

if ((el = *pEl) == NULL) return;
freeMem(el->name);
freeMem(el->errorMessage);
freez(pEl);
}

void bdwHostFreeList(struct bdwHost **pList)
/* Free a list of dynamically allocated bdwHost's */
{
struct bdwHost *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    bdwHostFree(&el);
    }
*pList = NULL;
}

void bdwHostOutput(struct bdwHost *el, FILE *f, char sep, char lastSep) 
/* Print out bdwHost.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->name);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%lld", el->lastOkTime);
fputc(sep,f);
fprintf(f, "%lld", el->lastNotOkTime);
fputc(sep,f);
fprintf(f, "%lld", el->firstAdded);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->errorMessage);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%lld", el->uploadCount);
fputc(sep,f);
fprintf(f, "%lld", el->historyBits);
fputc(lastSep,f);
}

void bdwSubmissionDirStaticLoad(char **row, struct bdwSubmissionDir *ret)
/* Load a row from bdwSubmissionDir table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->url = row[1];
ret->hostId = sqlUnsigned(row[2]);
ret->lastOkTime = sqlLongLong(row[3]);
ret->lastNotOkTime = sqlLongLong(row[4]);
ret->firstAdded = sqlLongLong(row[5]);
ret->errorMessage = row[6];
ret->uploadAttempts = sqlLongLong(row[7]);
ret->historyBits = sqlLongLong(row[8]);
}

struct bdwSubmissionDir *bdwSubmissionDirLoad(char **row)
/* Load a bdwSubmissionDir from row fetched with select * from bdwSubmissionDir
 * from database.  Dispose of this with bdwSubmissionDirFree(). */
{
struct bdwSubmissionDir *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->url = cloneString(row[1]);
ret->hostId = sqlUnsigned(row[2]);
ret->lastOkTime = sqlLongLong(row[3]);
ret->lastNotOkTime = sqlLongLong(row[4]);
ret->firstAdded = sqlLongLong(row[5]);
ret->errorMessage = cloneString(row[6]);
ret->uploadAttempts = sqlLongLong(row[7]);
ret->historyBits = sqlLongLong(row[8]);
return ret;
}

struct bdwSubmissionDir *bdwSubmissionDirLoadAll(char *fileName) 
/* Load all bdwSubmissionDir from a whitespace-separated file.
 * Dispose of this with bdwSubmissionDirFreeList(). */
{
struct bdwSubmissionDir *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[9];

while (lineFileRow(lf, row))
    {
    el = bdwSubmissionDirLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct bdwSubmissionDir *bdwSubmissionDirLoadAllByChar(char *fileName, char chopper) 
/* Load all bdwSubmissionDir from a chopper separated file.
 * Dispose of this with bdwSubmissionDirFreeList(). */
{
struct bdwSubmissionDir *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[9];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = bdwSubmissionDirLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct bdwSubmissionDir *bdwSubmissionDirCommaIn(char **pS, struct bdwSubmissionDir *ret)
/* Create a bdwSubmissionDir out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new bdwSubmissionDir */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->url = sqlStringComma(&s);
ret->hostId = sqlUnsignedComma(&s);
ret->lastOkTime = sqlLongLongComma(&s);
ret->lastNotOkTime = sqlLongLongComma(&s);
ret->firstAdded = sqlLongLongComma(&s);
ret->errorMessage = sqlStringComma(&s);
ret->uploadAttempts = sqlLongLongComma(&s);
ret->historyBits = sqlLongLongComma(&s);
*pS = s;
return ret;
}

void bdwSubmissionDirFree(struct bdwSubmissionDir **pEl)
/* Free a single dynamically allocated bdwSubmissionDir such as created
 * with bdwSubmissionDirLoad(). */
{
struct bdwSubmissionDir *el;

if ((el = *pEl) == NULL) return;
freeMem(el->url);
freeMem(el->errorMessage);
freez(pEl);
}

void bdwSubmissionDirFreeList(struct bdwSubmissionDir **pList)
/* Free a list of dynamically allocated bdwSubmissionDir's */
{
struct bdwSubmissionDir *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    bdwSubmissionDirFree(&el);
    }
*pList = NULL;
}

void bdwSubmissionDirOutput(struct bdwSubmissionDir *el, FILE *f, char sep, char lastSep) 
/* Print out bdwSubmissionDir.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->url);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%u", el->hostId);
fputc(sep,f);
fprintf(f, "%lld", el->lastOkTime);
fputc(sep,f);
fprintf(f, "%lld", el->lastNotOkTime);
fputc(sep,f);
fprintf(f, "%lld", el->firstAdded);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->errorMessage);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%lld", el->uploadAttempts);
fputc(sep,f);
fprintf(f, "%lld", el->historyBits);
fputc(lastSep,f);
}

void bdwFileStaticLoad(char **row, struct bdwFile *ret)
/* Load a row from bdwFile table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
safecpy(ret->licensePlate, sizeof(ret->licensePlate), row[1]);
ret->submissionId = sqlUnsigned(row[2]);
ret->submitFileName = row[3];
ret->bdwFileName = row[4];
ret->startUploadTime = sqlLongLong(row[5]);
ret->endUploadTime = sqlLongLong(row[6]);
ret->updateTime = sqlLongLong(row[7]);
ret->size = sqlLongLong(row[8]);
safecpy(ret->md5, sizeof(ret->md5), row[9]);
ret->tags = row[10];
ret->errorMessage = row[11];
ret->uploadAttempts = sqlLongLong(row[12]);
ret->historyBits = sqlLongLong(row[13]);
}

struct bdwFile *bdwFileLoad(char **row)
/* Load a bdwFile from row fetched with select * from bdwFile
 * from database.  Dispose of this with bdwFileFree(). */
{
struct bdwFile *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
safecpy(ret->licensePlate, sizeof(ret->licensePlate), row[1]);
ret->submissionId = sqlUnsigned(row[2]);
ret->submitFileName = cloneString(row[3]);
ret->bdwFileName = cloneString(row[4]);
ret->startUploadTime = sqlLongLong(row[5]);
ret->endUploadTime = sqlLongLong(row[6]);
ret->updateTime = sqlLongLong(row[7]);
ret->size = sqlLongLong(row[8]);
safecpy(ret->md5, sizeof(ret->md5), row[9]);
ret->tags = cloneString(row[10]);
ret->errorMessage = cloneString(row[11]);
ret->uploadAttempts = sqlLongLong(row[12]);
ret->historyBits = sqlLongLong(row[13]);
return ret;
}

struct bdwFile *bdwFileLoadAll(char *fileName) 
/* Load all bdwFile from a whitespace-separated file.
 * Dispose of this with bdwFileFreeList(). */
{
struct bdwFile *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[14];

while (lineFileRow(lf, row))
    {
    el = bdwFileLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct bdwFile *bdwFileLoadAllByChar(char *fileName, char chopper) 
/* Load all bdwFile from a chopper separated file.
 * Dispose of this with bdwFileFreeList(). */
{
struct bdwFile *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[14];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = bdwFileLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct bdwFile *bdwFileCommaIn(char **pS, struct bdwFile *ret)
/* Create a bdwFile out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new bdwFile */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
sqlFixedStringComma(&s, ret->licensePlate, sizeof(ret->licensePlate));
ret->submissionId = sqlUnsignedComma(&s);
ret->submitFileName = sqlStringComma(&s);
ret->bdwFileName = sqlStringComma(&s);
ret->startUploadTime = sqlLongLongComma(&s);
ret->endUploadTime = sqlLongLongComma(&s);
ret->updateTime = sqlLongLongComma(&s);
ret->size = sqlLongLongComma(&s);
sqlFixedStringComma(&s, ret->md5, sizeof(ret->md5));
ret->tags = sqlStringComma(&s);
ret->errorMessage = sqlStringComma(&s);
ret->uploadAttempts = sqlLongLongComma(&s);
ret->historyBits = sqlLongLongComma(&s);
*pS = s;
return ret;
}

void bdwFileFree(struct bdwFile **pEl)
/* Free a single dynamically allocated bdwFile such as created
 * with bdwFileLoad(). */
{
struct bdwFile *el;

if ((el = *pEl) == NULL) return;
freeMem(el->submitFileName);
freeMem(el->bdwFileName);
freeMem(el->tags);
freeMem(el->errorMessage);
freez(pEl);
}

void bdwFileFreeList(struct bdwFile **pList)
/* Free a list of dynamically allocated bdwFile's */
{
struct bdwFile *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    bdwFileFree(&el);
    }
*pList = NULL;
}

void bdwFileOutput(struct bdwFile *el, FILE *f, char sep, char lastSep) 
/* Print out bdwFile.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->licensePlate);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%u", el->submissionId);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->submitFileName);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->bdwFileName);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%lld", el->startUploadTime);
fputc(sep,f);
fprintf(f, "%lld", el->endUploadTime);
fputc(sep,f);
fprintf(f, "%lld", el->updateTime);
fputc(sep,f);
fprintf(f, "%lld", el->size);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->md5);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->tags);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->errorMessage);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%lld", el->uploadAttempts);
fputc(sep,f);
fprintf(f, "%lld", el->historyBits);
fputc(lastSep,f);
}

void bdwSubmissionStaticLoad(char **row, struct bdwSubmission *ret)
/* Load a row from bdwSubmission table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->url = row[1];
ret->startUploadTime = sqlLongLong(row[2]);
ret->endUploadTime = sqlLongLong(row[3]);
safecpy(ret->userSid, sizeof(ret->userSid), row[4]);
ret->submitFileId = sqlUnsigned(row[5]);
ret->errorMessage = row[6];
}

struct bdwSubmission *bdwSubmissionLoad(char **row)
/* Load a bdwSubmission from row fetched with select * from bdwSubmission
 * from database.  Dispose of this with bdwSubmissionFree(). */
{
struct bdwSubmission *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->url = cloneString(row[1]);
ret->startUploadTime = sqlLongLong(row[2]);
ret->endUploadTime = sqlLongLong(row[3]);
safecpy(ret->userSid, sizeof(ret->userSid), row[4]);
ret->submitFileId = sqlUnsigned(row[5]);
ret->errorMessage = cloneString(row[6]);
return ret;
}

struct bdwSubmission *bdwSubmissionLoadAll(char *fileName) 
/* Load all bdwSubmission from a whitespace-separated file.
 * Dispose of this with bdwSubmissionFreeList(). */
{
struct bdwSubmission *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[7];

while (lineFileRow(lf, row))
    {
    el = bdwSubmissionLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct bdwSubmission *bdwSubmissionLoadAllByChar(char *fileName, char chopper) 
/* Load all bdwSubmission from a chopper separated file.
 * Dispose of this with bdwSubmissionFreeList(). */
{
struct bdwSubmission *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[7];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = bdwSubmissionLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct bdwSubmission *bdwSubmissionCommaIn(char **pS, struct bdwSubmission *ret)
/* Create a bdwSubmission out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new bdwSubmission */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->url = sqlStringComma(&s);
ret->startUploadTime = sqlLongLongComma(&s);
ret->endUploadTime = sqlLongLongComma(&s);
sqlFixedStringComma(&s, ret->userSid, sizeof(ret->userSid));
ret->submitFileId = sqlUnsignedComma(&s);
ret->errorMessage = sqlStringComma(&s);
*pS = s;
return ret;
}

void bdwSubmissionFree(struct bdwSubmission **pEl)
/* Free a single dynamically allocated bdwSubmission such as created
 * with bdwSubmissionLoad(). */
{
struct bdwSubmission *el;

if ((el = *pEl) == NULL) return;
freeMem(el->url);
freeMem(el->errorMessage);
freez(pEl);
}

void bdwSubmissionFreeList(struct bdwSubmission **pList)
/* Free a list of dynamically allocated bdwSubmission's */
{
struct bdwSubmission *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    bdwSubmissionFree(&el);
    }
*pList = NULL;
}

void bdwSubmissionOutput(struct bdwSubmission *el, FILE *f, char sep, char lastSep) 
/* Print out bdwSubmission.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->url);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%lld", el->startUploadTime);
fputc(sep,f);
fprintf(f, "%lld", el->endUploadTime);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->userSid);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%u", el->submitFileId);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->errorMessage);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void bdwSubmissionLogStaticLoad(char **row, struct bdwSubmissionLog *ret)
/* Load a row from bdwSubmissionLog table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->submissionId = sqlUnsigned(row[1]);
ret->message = row[2];
}

struct bdwSubmissionLog *bdwSubmissionLogLoad(char **row)
/* Load a bdwSubmissionLog from row fetched with select * from bdwSubmissionLog
 * from database.  Dispose of this with bdwSubmissionLogFree(). */
{
struct bdwSubmissionLog *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->submissionId = sqlUnsigned(row[1]);
ret->message = cloneString(row[2]);
return ret;
}

struct bdwSubmissionLog *bdwSubmissionLogLoadAll(char *fileName) 
/* Load all bdwSubmissionLog from a whitespace-separated file.
 * Dispose of this with bdwSubmissionLogFreeList(). */
{
struct bdwSubmissionLog *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[3];

while (lineFileRow(lf, row))
    {
    el = bdwSubmissionLogLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct bdwSubmissionLog *bdwSubmissionLogLoadAllByChar(char *fileName, char chopper) 
/* Load all bdwSubmissionLog from a chopper separated file.
 * Dispose of this with bdwSubmissionLogFreeList(). */
{
struct bdwSubmissionLog *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[3];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = bdwSubmissionLogLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct bdwSubmissionLog *bdwSubmissionLogCommaIn(char **pS, struct bdwSubmissionLog *ret)
/* Create a bdwSubmissionLog out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new bdwSubmissionLog */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->submissionId = sqlUnsignedComma(&s);
ret->message = sqlStringComma(&s);
*pS = s;
return ret;
}

void bdwSubmissionLogFree(struct bdwSubmissionLog **pEl)
/* Free a single dynamically allocated bdwSubmissionLog such as created
 * with bdwSubmissionLogLoad(). */
{
struct bdwSubmissionLog *el;

if ((el = *pEl) == NULL) return;
freeMem(el->message);
freez(pEl);
}

void bdwSubmissionLogFreeList(struct bdwSubmissionLog **pList)
/* Free a list of dynamically allocated bdwSubmissionLog's */
{
struct bdwSubmissionLog *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    bdwSubmissionLogFree(&el);
    }
*pList = NULL;
}

void bdwSubmissionLogOutput(struct bdwSubmissionLog *el, FILE *f, char sep, char lastSep) 
/* Print out bdwSubmissionLog.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
fprintf(f, "%u", el->submissionId);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->message);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void bdwSubscribingProgramStaticLoad(char **row, struct bdwSubscribingProgram *ret)
/* Load a row from bdwSubscribingProgram table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->runOrder = sqlDouble(row[1]);
ret->filePattern = row[2];
ret->hubPattern = row[3];
ret->tagPattern = row[4];
ret->onFileStartUpload = row[5];
ret->onFileEndUpload = row[6];
ret->onSubmissionStartUpload = row[7];
ret->onSubmissionEndUpload = row[8];
}

struct bdwSubscribingProgram *bdwSubscribingProgramLoad(char **row)
/* Load a bdwSubscribingProgram from row fetched with select * from bdwSubscribingProgram
 * from database.  Dispose of this with bdwSubscribingProgramFree(). */
{
struct bdwSubscribingProgram *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->runOrder = sqlDouble(row[1]);
ret->filePattern = cloneString(row[2]);
ret->hubPattern = cloneString(row[3]);
ret->tagPattern = cloneString(row[4]);
ret->onFileStartUpload = cloneString(row[5]);
ret->onFileEndUpload = cloneString(row[6]);
ret->onSubmissionStartUpload = cloneString(row[7]);
ret->onSubmissionEndUpload = cloneString(row[8]);
return ret;
}

struct bdwSubscribingProgram *bdwSubscribingProgramLoadAll(char *fileName) 
/* Load all bdwSubscribingProgram from a whitespace-separated file.
 * Dispose of this with bdwSubscribingProgramFreeList(). */
{
struct bdwSubscribingProgram *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[9];

while (lineFileRow(lf, row))
    {
    el = bdwSubscribingProgramLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct bdwSubscribingProgram *bdwSubscribingProgramLoadAllByChar(char *fileName, char chopper) 
/* Load all bdwSubscribingProgram from a chopper separated file.
 * Dispose of this with bdwSubscribingProgramFreeList(). */
{
struct bdwSubscribingProgram *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[9];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = bdwSubscribingProgramLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct bdwSubscribingProgram *bdwSubscribingProgramCommaIn(char **pS, struct bdwSubscribingProgram *ret)
/* Create a bdwSubscribingProgram out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new bdwSubscribingProgram */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->runOrder = sqlDoubleComma(&s);
ret->filePattern = sqlStringComma(&s);
ret->hubPattern = sqlStringComma(&s);
ret->tagPattern = sqlStringComma(&s);
ret->onFileStartUpload = sqlStringComma(&s);
ret->onFileEndUpload = sqlStringComma(&s);
ret->onSubmissionStartUpload = sqlStringComma(&s);
ret->onSubmissionEndUpload = sqlStringComma(&s);
*pS = s;
return ret;
}

void bdwSubscribingProgramFree(struct bdwSubscribingProgram **pEl)
/* Free a single dynamically allocated bdwSubscribingProgram such as created
 * with bdwSubscribingProgramLoad(). */
{
struct bdwSubscribingProgram *el;

if ((el = *pEl) == NULL) return;
freeMem(el->filePattern);
freeMem(el->hubPattern);
freeMem(el->tagPattern);
freeMem(el->onFileStartUpload);
freeMem(el->onFileEndUpload);
freeMem(el->onSubmissionStartUpload);
freeMem(el->onSubmissionEndUpload);
freez(pEl);
}

void bdwSubscribingProgramFreeList(struct bdwSubscribingProgram **pList)
/* Free a list of dynamically allocated bdwSubscribingProgram's */
{
struct bdwSubscribingProgram *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    bdwSubscribingProgramFree(&el);
    }
*pList = NULL;
}

void bdwSubscribingProgramOutput(struct bdwSubscribingProgram *el, FILE *f, char sep, char lastSep) 
/* Print out bdwSubscribingProgram.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
fprintf(f, "%g", el->runOrder);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->filePattern);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->hubPattern);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->tagPattern);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->onFileStartUpload);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->onFileEndUpload);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->onSubmissionStartUpload);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->onSubmissionEndUpload);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

/* -------------------------------- End autoSql Generated Code -------------------------------- */

