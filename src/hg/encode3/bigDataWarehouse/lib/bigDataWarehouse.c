/* bigDataWarehouse.c was originally generated by the autoSql program, which also 
 * generated bigDataWarehouse.h and bigDataWarehouse.sql.  This module links the database and
 * the RAM representation of objects. */

#include "common.h"
#include "linefile.h"
#include "dystring.h"
#include "jksql.h"
#include "bigDataWarehouse.h"


void bdwUserStaticLoad(char **row, struct bdwUser *ret)
/* Load a row from bdwUser table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

safecpy(ret->sid, sizeof(ret->sid), row[0]);
safecpy(ret->access, sizeof(ret->access), row[1]);
ret->email = row[2];
}

struct bdwUser *bdwUserLoad(char **row)
/* Load a bdwUser from row fetched with select * from bdwUser
 * from database.  Dispose of this with bdwUserFree(). */
{
struct bdwUser *ret;

AllocVar(ret);
safecpy(ret->sid, sizeof(ret->sid), row[0]);
safecpy(ret->access, sizeof(ret->access), row[1]);
ret->email = cloneString(row[2]);
return ret;
}

struct bdwUser *bdwUserLoadAll(char *fileName) 
/* Load all bdwUser from a whitespace-separated file.
 * Dispose of this with bdwUserFreeList(). */
{
struct bdwUser *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[3];

while (lineFileRow(lf, row))
    {
    el = bdwUserLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct bdwUser *bdwUserLoadAllByChar(char *fileName, char chopper) 
/* Load all bdwUser from a chopper separated file.
 * Dispose of this with bdwUserFreeList(). */
{
struct bdwUser *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[3];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = bdwUserLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct bdwUser *bdwUserCommaIn(char **pS, struct bdwUser *ret)
/* Create a bdwUser out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new bdwUser */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
sqlFixedStringComma(&s, ret->sid, sizeof(ret->sid));
sqlFixedStringComma(&s, ret->access, sizeof(ret->access));
ret->email = sqlStringComma(&s);
*pS = s;
return ret;
}

void bdwUserFree(struct bdwUser **pEl)
/* Free a single dynamically allocated bdwUser such as created
 * with bdwUserLoad(). */
{
struct bdwUser *el;

if ((el = *pEl) == NULL) return;
freeMem(el->email);
freez(pEl);
}

void bdwUserFreeList(struct bdwUser **pList)
/* Free a list of dynamically allocated bdwUser's */
{
struct bdwUser *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    bdwUserFree(&el);
    }
*pList = NULL;
}

void bdwUserOutput(struct bdwUser *el, FILE *f, char sep, char lastSep) 
/* Print out bdwUser.  Separate fields with sep. Follow last field with lastSep. */
{
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->sid);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->access);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->email);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void bdwHubStaticLoad(char **row, struct bdwHub *ret)
/* Load a row from bdwHub table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->url = row[1];
ret->shortLabel = row[2];
ret->longLabel = row[3];
ret->lastOkTime = sqlLongLong(row[4]);
ret->lastNotOkTime = sqlLongLong(row[5]);
ret->firstAdded = sqlLongLong(row[6]);
ret->errorMessage = row[7];
}

struct bdwHub *bdwHubLoad(char **row)
/* Load a bdwHub from row fetched with select * from bdwHub
 * from database.  Dispose of this with bdwHubFree(). */
{
struct bdwHub *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->url = cloneString(row[1]);
ret->shortLabel = cloneString(row[2]);
ret->longLabel = cloneString(row[3]);
ret->lastOkTime = sqlLongLong(row[4]);
ret->lastNotOkTime = sqlLongLong(row[5]);
ret->firstAdded = sqlLongLong(row[6]);
ret->errorMessage = cloneString(row[7]);
return ret;
}

struct bdwHub *bdwHubLoadAll(char *fileName) 
/* Load all bdwHub from a whitespace-separated file.
 * Dispose of this with bdwHubFreeList(). */
{
struct bdwHub *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[8];

while (lineFileRow(lf, row))
    {
    el = bdwHubLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct bdwHub *bdwHubLoadAllByChar(char *fileName, char chopper) 
/* Load all bdwHub from a chopper separated file.
 * Dispose of this with bdwHubFreeList(). */
{
struct bdwHub *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[8];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = bdwHubLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct bdwHub *bdwHubCommaIn(char **pS, struct bdwHub *ret)
/* Create a bdwHub out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new bdwHub */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->url = sqlStringComma(&s);
ret->shortLabel = sqlStringComma(&s);
ret->longLabel = sqlStringComma(&s);
ret->lastOkTime = sqlLongLongComma(&s);
ret->lastNotOkTime = sqlLongLongComma(&s);
ret->firstAdded = sqlLongLongComma(&s);
ret->errorMessage = sqlStringComma(&s);
*pS = s;
return ret;
}

void bdwHubFree(struct bdwHub **pEl)
/* Free a single dynamically allocated bdwHub such as created
 * with bdwHubLoad(). */
{
struct bdwHub *el;

if ((el = *pEl) == NULL) return;
freeMem(el->url);
freeMem(el->shortLabel);
freeMem(el->longLabel);
freeMem(el->errorMessage);
freez(pEl);
}

void bdwHubFreeList(struct bdwHub **pList)
/* Free a list of dynamically allocated bdwHub's */
{
struct bdwHub *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    bdwHubFree(&el);
    }
*pList = NULL;
}

void bdwHubOutput(struct bdwHub *el, FILE *f, char sep, char lastSep) 
/* Print out bdwHub.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->url);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->shortLabel);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->longLabel);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%lld", el->lastOkTime);
fputc(sep,f);
fprintf(f, "%lld", el->lastNotOkTime);
fputc(sep,f);
fprintf(f, "%lld", el->firstAdded);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->errorMessage);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void bdwHostStaticLoad(char **row, struct bdwHost *ret)
/* Load a row from bdwHost table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->name = row[1];
ret->lastOkTime = sqlLongLong(row[2]);
ret->lastNotOkTime = sqlLongLong(row[3]);
ret->firstAdded = sqlLongLong(row[4]);
ret->errorMessage = row[5];
}

struct bdwHost *bdwHostLoad(char **row)
/* Load a bdwHost from row fetched with select * from bdwHost
 * from database.  Dispose of this with bdwHostFree(). */
{
struct bdwHost *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->name = cloneString(row[1]);
ret->lastOkTime = sqlLongLong(row[2]);
ret->lastNotOkTime = sqlLongLong(row[3]);
ret->firstAdded = sqlLongLong(row[4]);
ret->errorMessage = cloneString(row[5]);
return ret;
}

struct bdwHost *bdwHostLoadAll(char *fileName) 
/* Load all bdwHost from a whitespace-separated file.
 * Dispose of this with bdwHostFreeList(). */
{
struct bdwHost *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[6];

while (lineFileRow(lf, row))
    {
    el = bdwHostLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct bdwHost *bdwHostLoadAllByChar(char *fileName, char chopper) 
/* Load all bdwHost from a chopper separated file.
 * Dispose of this with bdwHostFreeList(). */
{
struct bdwHost *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[6];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = bdwHostLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct bdwHost *bdwHostCommaIn(char **pS, struct bdwHost *ret)
/* Create a bdwHost out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new bdwHost */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->name = sqlStringComma(&s);
ret->lastOkTime = sqlLongLongComma(&s);
ret->lastNotOkTime = sqlLongLongComma(&s);
ret->firstAdded = sqlLongLongComma(&s);
ret->errorMessage = sqlStringComma(&s);
*pS = s;
return ret;
}

void bdwHostFree(struct bdwHost **pEl)
/* Free a single dynamically allocated bdwHost such as created
 * with bdwHostLoad(). */
{
struct bdwHost *el;

if ((el = *pEl) == NULL) return;
freeMem(el->name);
freeMem(el->errorMessage);
freez(pEl);
}

void bdwHostFreeList(struct bdwHost **pList)
/* Free a list of dynamically allocated bdwHost's */
{
struct bdwHost *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    bdwHostFree(&el);
    }
*pList = NULL;
}

void bdwHostOutput(struct bdwHost *el, FILE *f, char sep, char lastSep) 
/* Print out bdwHost.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->name);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%lld", el->lastOkTime);
fputc(sep,f);
fprintf(f, "%lld", el->lastNotOkTime);
fputc(sep,f);
fprintf(f, "%lld", el->firstAdded);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->errorMessage);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void bdwSubmissionStaticLoad(char **row, struct bdwSubmission *ret)
/* Load a row from bdwSubmission table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->startUploadTime = sqlLongLong(row[1]);
ret->endUploadTime = sqlLongLong(row[2]);
safecpy(ret->userSid, sizeof(ret->userSid), row[3]);
ret->hubId = sqlUnsigned(row[4]);
ret->errorMessage = row[5];
}

struct bdwSubmission *bdwSubmissionLoad(char **row)
/* Load a bdwSubmission from row fetched with select * from bdwSubmission
 * from database.  Dispose of this with bdwSubmissionFree(). */
{
struct bdwSubmission *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->startUploadTime = sqlLongLong(row[1]);
ret->endUploadTime = sqlLongLong(row[2]);
safecpy(ret->userSid, sizeof(ret->userSid), row[3]);
ret->hubId = sqlUnsigned(row[4]);
ret->errorMessage = cloneString(row[5]);
return ret;
}

struct bdwSubmission *bdwSubmissionLoadAll(char *fileName) 
/* Load all bdwSubmission from a whitespace-separated file.
 * Dispose of this with bdwSubmissionFreeList(). */
{
struct bdwSubmission *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[6];

while (lineFileRow(lf, row))
    {
    el = bdwSubmissionLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct bdwSubmission *bdwSubmissionLoadAllByChar(char *fileName, char chopper) 
/* Load all bdwSubmission from a chopper separated file.
 * Dispose of this with bdwSubmissionFreeList(). */
{
struct bdwSubmission *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[6];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = bdwSubmissionLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct bdwSubmission *bdwSubmissionCommaIn(char **pS, struct bdwSubmission *ret)
/* Create a bdwSubmission out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new bdwSubmission */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->startUploadTime = sqlLongLongComma(&s);
ret->endUploadTime = sqlLongLongComma(&s);
sqlFixedStringComma(&s, ret->userSid, sizeof(ret->userSid));
ret->hubId = sqlUnsignedComma(&s);
ret->errorMessage = sqlStringComma(&s);
*pS = s;
return ret;
}

void bdwSubmissionFree(struct bdwSubmission **pEl)
/* Free a single dynamically allocated bdwSubmission such as created
 * with bdwSubmissionLoad(). */
{
struct bdwSubmission *el;

if ((el = *pEl) == NULL) return;
freeMem(el->errorMessage);
freez(pEl);
}

void bdwSubmissionFreeList(struct bdwSubmission **pList)
/* Free a list of dynamically allocated bdwSubmission's */
{
struct bdwSubmission *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    bdwSubmissionFree(&el);
    }
*pList = NULL;
}

void bdwSubmissionOutput(struct bdwSubmission *el, FILE *f, char sep, char lastSep) 
/* Print out bdwSubmission.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
fprintf(f, "%lld", el->startUploadTime);
fputc(sep,f);
fprintf(f, "%lld", el->endUploadTime);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->userSid);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%u", el->hubId);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->errorMessage);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void bdwFileStaticLoad(char **row, struct bdwFile *ret)
/* Load a row from bdwFile table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->submission = sqlUnsigned(row[1]);
ret->hubFileName = row[2];
ret->bdwName = row[3][0];
ret->bdwFileName = row[4];
ret->startUploadTime = sqlLongLong(row[5]);
ret->endUploadTime = sqlLongLong(row[6]);
ret->updateTime = sqlLongLong(row[7]);
ret->size = sqlLongLong(row[8]);
safecpy(ret->md5, sizeof(ret->md5), row[9]);
ret->tags = row[10];
}

struct bdwFile *bdwFileLoad(char **row)
/* Load a bdwFile from row fetched with select * from bdwFile
 * from database.  Dispose of this with bdwFileFree(). */
{
struct bdwFile *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->submission = sqlUnsigned(row[1]);
ret->hubFileName = cloneString(row[2]);
ret->bdwName = row[3][0];
ret->bdwFileName = cloneString(row[4]);
ret->startUploadTime = sqlLongLong(row[5]);
ret->endUploadTime = sqlLongLong(row[6]);
ret->updateTime = sqlLongLong(row[7]);
ret->size = sqlLongLong(row[8]);
safecpy(ret->md5, sizeof(ret->md5), row[9]);
ret->tags = cloneString(row[10]);
return ret;
}

struct bdwFile *bdwFileLoadAll(char *fileName) 
/* Load all bdwFile from a whitespace-separated file.
 * Dispose of this with bdwFileFreeList(). */
{
struct bdwFile *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[11];

while (lineFileRow(lf, row))
    {
    el = bdwFileLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct bdwFile *bdwFileLoadAllByChar(char *fileName, char chopper) 
/* Load all bdwFile from a chopper separated file.
 * Dispose of this with bdwFileFreeList(). */
{
struct bdwFile *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[11];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = bdwFileLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct bdwFile *bdwFileCommaIn(char **pS, struct bdwFile *ret)
/* Create a bdwFile out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new bdwFile */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->submission = sqlUnsignedComma(&s);
ret->hubFileName = sqlStringComma(&s);
sqlFixedStringComma(&s, &(ret->bdwName), sizeof(ret->bdwName));
ret->bdwFileName = sqlStringComma(&s);
ret->startUploadTime = sqlLongLongComma(&s);
ret->endUploadTime = sqlLongLongComma(&s);
ret->updateTime = sqlLongLongComma(&s);
ret->size = sqlLongLongComma(&s);
sqlFixedStringComma(&s, ret->md5, sizeof(ret->md5));
ret->tags = sqlStringComma(&s);
*pS = s;
return ret;
}

void bdwFileFree(struct bdwFile **pEl)
/* Free a single dynamically allocated bdwFile such as created
 * with bdwFileLoad(). */
{
struct bdwFile *el;

if ((el = *pEl) == NULL) return;
freeMem(el->hubFileName);
freeMem(el->bdwFileName);
freeMem(el->tags);
freez(pEl);
}

void bdwFileFreeList(struct bdwFile **pList)
/* Free a list of dynamically allocated bdwFile's */
{
struct bdwFile *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    bdwFileFree(&el);
    }
*pList = NULL;
}

void bdwFileOutput(struct bdwFile *el, FILE *f, char sep, char lastSep) 
/* Print out bdwFile.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
fprintf(f, "%u", el->submission);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->hubFileName);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%c", el->bdwName);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->bdwFileName);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%lld", el->startUploadTime);
fputc(sep,f);
fprintf(f, "%lld", el->endUploadTime);
fputc(sep,f);
fprintf(f, "%lld", el->updateTime);
fputc(sep,f);
fprintf(f, "%lld", el->size);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->md5);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->tags);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void bdwSubscribingProgramStaticLoad(char **row, struct bdwSubscribingProgram *ret)
/* Load a row from bdwSubscribingProgram table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->filePattern = row[1];
ret->hubPattern = row[2];
ret->tagPattern = row[3];
ret->onFileStartUpload = row[4];
ret->onFileEndUpload = row[5];
ret->onSubmissionStartUpload = row[6];
ret->onSubmissionEndUpload = row[7];
}

struct bdwSubscribingProgram *bdwSubscribingProgramLoad(char **row)
/* Load a bdwSubscribingProgram from row fetched with select * from bdwSubscribingProgram
 * from database.  Dispose of this with bdwSubscribingProgramFree(). */
{
struct bdwSubscribingProgram *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->filePattern = cloneString(row[1]);
ret->hubPattern = cloneString(row[2]);
ret->tagPattern = cloneString(row[3]);
ret->onFileStartUpload = cloneString(row[4]);
ret->onFileEndUpload = cloneString(row[5]);
ret->onSubmissionStartUpload = cloneString(row[6]);
ret->onSubmissionEndUpload = cloneString(row[7]);
return ret;
}

struct bdwSubscribingProgram *bdwSubscribingProgramLoadAll(char *fileName) 
/* Load all bdwSubscribingProgram from a whitespace-separated file.
 * Dispose of this with bdwSubscribingProgramFreeList(). */
{
struct bdwSubscribingProgram *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[8];

while (lineFileRow(lf, row))
    {
    el = bdwSubscribingProgramLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct bdwSubscribingProgram *bdwSubscribingProgramLoadAllByChar(char *fileName, char chopper) 
/* Load all bdwSubscribingProgram from a chopper separated file.
 * Dispose of this with bdwSubscribingProgramFreeList(). */
{
struct bdwSubscribingProgram *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[8];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = bdwSubscribingProgramLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct bdwSubscribingProgram *bdwSubscribingProgramCommaIn(char **pS, struct bdwSubscribingProgram *ret)
/* Create a bdwSubscribingProgram out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new bdwSubscribingProgram */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->filePattern = sqlStringComma(&s);
ret->hubPattern = sqlStringComma(&s);
ret->tagPattern = sqlStringComma(&s);
ret->onFileStartUpload = sqlStringComma(&s);
ret->onFileEndUpload = sqlStringComma(&s);
ret->onSubmissionStartUpload = sqlStringComma(&s);
ret->onSubmissionEndUpload = sqlStringComma(&s);
*pS = s;
return ret;
}

void bdwSubscribingProgramFree(struct bdwSubscribingProgram **pEl)
/* Free a single dynamically allocated bdwSubscribingProgram such as created
 * with bdwSubscribingProgramLoad(). */
{
struct bdwSubscribingProgram *el;

if ((el = *pEl) == NULL) return;
freeMem(el->filePattern);
freeMem(el->hubPattern);
freeMem(el->tagPattern);
freeMem(el->onFileStartUpload);
freeMem(el->onFileEndUpload);
freeMem(el->onSubmissionStartUpload);
freeMem(el->onSubmissionEndUpload);
freez(pEl);
}

void bdwSubscribingProgramFreeList(struct bdwSubscribingProgram **pList)
/* Free a list of dynamically allocated bdwSubscribingProgram's */
{
struct bdwSubscribingProgram *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    bdwSubscribingProgramFree(&el);
    }
*pList = NULL;
}

void bdwSubscribingProgramOutput(struct bdwSubscribingProgram *el, FILE *f, char sep, char lastSep) 
/* Print out bdwSubscribingProgram.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->filePattern);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->hubPattern);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->tagPattern);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->onFileStartUpload);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->onFileEndUpload);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->onSubmissionStartUpload);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->onSubmissionEndUpload);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

/* -------------------------------- End autoSql Generated Code -------------------------------- */

