/* userSettings - pages and control sets for loading/saving
 * user settings. */

#include "common.h"
#include "linefile.h"
#include "hash.h"
#include "cart.h"
#include "obscure.h"
#include "cheapcgi.h"
#include "jksql.h"
#include "hgNear.h"

static char const rcsid[] = "$Id: userSettings.c,v 1.1 2003/09/06 23:16:09 kent Exp $";

static char *catAndClone(char *a, char *b)
/* Return concatenation of a and b in dynamic memory. */
{
int aLen = strlen(a);
int bLen = strlen(b);
char *buf = needMem(aLen + bLen + 1);
memcpy(buf, a, aLen);
memcpy(buf+aLen, b, bLen);
return buf;
}

static void spaceToUnderbar(char *s)
/* Convert white space to underbars. */
{
char c;
while ((c = *s) != 0)
    {
    if (isspace(c))
        *s = '_';
    ++s;
    }
}

static char *settingsVarName(char *prefix, char *label)
/* Given user readable label construct var name */
{
char *symName = cloneString(label);
char *varName;
spaceToUnderbar(symName);
varName = catAndClone(prefix, label);
freez(&symName);
return varName;
}

struct userSettings *userSettingsNew(
	struct cart *cart,
	char *settingsPrefix, 
	char *formVar,
	char *localVarPrefix) 
/* Make new object to help manage sets of user settings. 
 * The settingsPrefix determines which user settings will
 * be saved.  The form variable is the name of the control
 * for the submit buttons generated by this system.  
 * The localVarPrefix defines a name space that the
 * form controls this object manages can use. When the
 * formVar is present in the cart then the application
 * needs to call userSettingsProcessForm.
 */
{
struct userSettings *us;
AllocVar(us);
us->cart = cart;
us->settingsPrefix = cloneString(settingsPrefix);
us->formVar = cloneString(formVar);
us->savePrefix = catAndClone(localVarPrefix, "named.");
us->nameVar = catAndClone(localVarPrefix, "name");
us->listDisplayVar = catAndClone(localVarPrefix, "displayList");
return us;
}

boolean userSettingsAnySaved(struct userSettings *us)
/* Return TRUE if any user settings are saved. */
{
struct hashEl *list = cartFindPrefix(us->cart, us->savePrefix);
boolean any = (list != NULL);
slFreeList(&list);
return any;
}

void userSettingsUseNamed(struct userSettings *us, char *setName)
/* Use named collection of settings. */
{
struct cart *cart = us->cart;
char *varName = settingsVarName(us->savePrefix, setName);
char *settings = cartOptionalString(cart, varName);
if (settings != NULL)
    {
    struct hash *hash = hashVarLine(settings, 1);
    struct hashEl *list = hashElListHash(hash);
    struct hashEl *el;
    for (el = list; el != NULL; el = el->next)
	cartSetString(cart, el->name, el->val);
    slFreeList(&list);
    hashFree(&hash);
    }
freez(&varName);
}

void userSettingsUseSelected(struct userSettings *us)
/* Use currently selected user settings. */
{
char *setName = cartOptionalString(us->cart, us->nameVar);
if (setName != NULL)
    {
    userSettingsUseNamed(us, setName);
    }
}


void userSettingsSaveForm(struct userSettings *us, char *title, ...)
/* Put up controls that let user name and save the current
 * set. */
{
/* Start form/save session. */
    hPrintf("<FORM ACTION=\"../cgi-bin/hgNear\" METHOD=GET>\n");
    cartSaveSession(us->cart);

/* Put up printf formatted title */
    {
    va_list(args);
    va_start(args, title);
    hPrintf("<H2>");
    hvPrintf(title, args);
    hPrintf("</H2>\n");
    va_end(args);
    }

/* Put up controls. */
    {
    hPrintf("Please name this setup:\n");
    cartMakeTextVar(us->cart, us->nameVar, "", 16);
    hPrintf(" ");
    cgiMakeButton(us->formVar, "Cancel");
    hPrintf(" ");
    cgiMakeButton(us->formVar, "Submit");
    }

/* End form. */
    hPrintf("</FORM>\n");
}

static void dyStringAppendQuoted(struct dyString *dy, char *s)
/* Append s to dyString, surrounding with quotes and escaping
 * internal quotes. */
{
char c;
dyStringAppendC(dy, '"');
while ((c = *s++) != 0)
    {
    if (c == '"')
       dyStringAppendC(dy, '\\');
    dyStringAppendC(dy, c);
    }
dyStringAppendC(dy, '"');
dyStringAppendC(dy, ' ');
}

static struct dyString *hashElsToSettings(struct hashEl *list)
/* Convert string valued hash elements to settings string. 
 * That is a string of var="val" pairs. */
{
struct dyString *dy = dyStringNew(1024);
struct hashEl *el;

for (el = list; el != NULL; el = el->next)
    {
    dyStringPrintf(dy, "%s=", el->name);
    dyStringAppendQuoted(dy, el->val);
    }
return dy;
}

static void saveSettings(struct cart *cart, char *varName, char *prefix)
/* Save settings that start with prefix to varName. */
{
struct hashEl *colVars;
struct dyString *dy;
colVars = cartFindPrefix(cart, prefix);
dy = hashElsToSettings(colVars);
cartSetString(cart, varName, dy->string);
dyStringFree(&dy);
slFreeList(&colVars);
}

void userSettingsProcessForm(struct userSettings *us)
/* Handle button press in userSettings form. */
{
struct cart *cart = us->cart;
char *command = cartString(cart, us->formVar);
char *name = cartNonemptyString(cart, us->nameVar);

if (name != NULL)
    {
    if (!sameWord(command, "cancel"))
	{
	char *varName = settingsVarName(us->savePrefix, name);
	saveSettings(cart, varName, us->settingsPrefix);
	freez(&varName);
	}
   }
cartRemove(cart, us->formVar);
}

void userSettingsDropDown(struct userSettings *us)
/* Display list of available saved settings . */
{
struct hashEl *el, *list = cartFindPrefix(us->cart, us->savePrefix);
if (list != NULL)
    {
    char *curSetting = cartUsualString(us->cart, us->nameVar, "");
    hPrintf("<SELECT NAME=\"%s\">\n", us->nameVar);
    slSort(&list, hashElCmp);
    for (el = list; el != NULL; el = el->next)
        {
	char *spacedString = cloneString(el->name + strlen(us->savePrefix));
	subChar(spacedString, '_', ' ');
	hPrintf("<OPTION%s VALUE=\"%s\">%s</OPTION>\n", 
		(sameString(curSetting, spacedString) ? " SELECTED" : ""),
		spacedString, spacedString);
	freez(&spacedString);
	}
    slFreeList(&list);
    hPrintf("</SELECT>");
    }
}

