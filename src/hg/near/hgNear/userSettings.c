/* userSettings - pages and control sets for loading/saving
 * user settings. */

#include "common.h"
#include "linefile.h"
#include "hash.h"
#include "cart.h"
#include "obscure.h"
#include "cheapcgi.h"
#include "htmshell.h"
#include "jksql.h"
#include "hgNear.h"

static char const rcsid[] = "$Id: userSettings.c,v 1.2 2003/09/07 02:08:19 kent Exp $";

static char *catAndClone(char *a, char *b)
/* Return concatenation of a and b in dynamic memory. */
{
int aLen = strlen(a);
int bLen = strlen(b);
char *buf = needMem(aLen + bLen + 1);
memcpy(buf, a, aLen);
memcpy(buf+aLen, b, bLen);
return buf;
}

static void spaceToUnderbar(char *s)
/* Convert white space to underbars. */
{
char c;
while ((c = *s) != 0)
    {
    if (isspace(c))
        *s = '_';
    ++s;
    }
}

static char *settingsVarName(char *prefix, char *label)
/* Given user readable label construct var name */
{
char *symName = cloneString(label);
char *varName;
spaceToUnderbar(symName);
varName = catAndClone(prefix, label);
freez(&symName);
return varName;
}

static char *settingsLabel(struct userSettings *us, char *varName)
/* Given varName return corresponding label. */
{
char *spacedString = cloneString(varName + strlen(us->savePrefix));
subChar(spacedString, '_', ' ');
return spacedString;
}

struct userSettings *userSettingsNew(
	struct cart *cart,
	char *settingsPrefix, 
	char *formVar,
	char *localVarPrefix) 
/* Make new object to help manage sets of user settings. 
 * The settingsPrefix determines which user settings will
 * be saved.  The form variable is the name of the control
 * for the submit buttons generated by this system.  
 * The localVarPrefix defines a name space that the
 * form controls this object manages can use. When the
 * formVar is present in the cart then the application
 * needs to call userSettingsProcessForm.
 */
{
struct userSettings *us;
AllocVar(us);
us->cart = cart;
us->settingsPrefix = cloneString(settingsPrefix);
us->formVar = cloneString(formVar);
us->savePrefix = catAndClone(localVarPrefix, "named_");
us->nameVar = catAndClone(localVarPrefix, "name");
us->listDisplayVar = catAndClone(localVarPrefix, "displayList");
return us;
}

boolean userSettingsAnySaved(struct userSettings *us)
/* Return TRUE if any user settings are saved. */
{
struct hashEl *list = cartFindPrefix(us->cart, us->savePrefix);
boolean any = (list != NULL);
slFreeList(&list);
return any;
}

void userSettingsUseNamed(struct userSettings *us, char *setName)
/* Use named collection of settings. */
{
struct cart *cart = us->cart;
char *varName = settingsVarName(us->savePrefix, setName);
char *settings = cartOptionalString(cart, varName);
if (settings != NULL)
    {
    struct hash *hash = hashVarLine(settings, 1);
    struct hashEl *list = hashElListHash(hash);
    struct hashEl *el;
    for (el = list; el != NULL; el = el->next)
	cartSetString(cart, el->name, el->val);
    slFreeList(&list);
    hashFree(&hash);
    }
freez(&varName);
}

void userSettingsUseSelected(struct userSettings *us)
/* Use currently selected user settings. */
{
char *setName = cartOptionalString(us->cart, us->nameVar);
if (setName != NULL)
    {
    userSettingsUseNamed(us, setName);
    }
}

static void printLabelList(struct userSettings *us, struct hashEl *list)
/* Print list of available settings as options. */
{
struct hashEl *el;
char *curSetting = cartUsualString(us->cart, us->nameVar, "");
for (el = list; el != NULL; el = el->next)
    {
    char *label = settingsLabel(us, el->name);
    hPrintf("<OPTION%s VALUE=\"%s\">%s</OPTION>\n", 
	    (sameString(curSetting, label) ? " SELECTED" : ""),
	    label, label);
    freez(&label);
    }
}


void userSettingsSaveForm(struct userSettings *us, char *title, ...)
/* Put up controls that let user name and save the current
 * set. */
{
struct hashEl *el, *list = cartFindPrefix(us->cart, us->savePrefix);

/* Start form/save session. */
    hPrintf("<FORM ACTION=\"../cgi-bin/hgNear\" NAME=\"usForm\" METHOD=GET>\n");
    cartSaveSession(us->cart);

/* Put up printf formatted title */
    {
    va_list(args);
    va_start(args, title);
    hPrintf("<H2>");
    hvPrintf(title, args);
    hPrintf("</H2>\n");
    va_end(args);
    }

    {
    /* Put up simple controls. */
    hPrintf("Please name this setup:\n");
    cartMakeTextVar(us->cart, us->nameVar, "", 16);
    hPrintf(" ");
    cgiMakeButton(us->formVar, "Submit");
    hPrintf(" ");
    cgiMakeButton(us->formVar, "Cancel");
    }
if (list != NULL)
    {
    struct dyString *js = newDyString(0);

    htmlHorizontalLine();
    slSort(&list, hashElCmp);
    hPrintf("Existing Setups:");
    dyStringPrintf(js, "document.usForm.%s.value=", us->nameVar);
    dyStringPrintf(js, "document.usForm.%s.options", us->listDisplayVar);
    dyStringPrintf(js, "[document.usForm.%s.selectedIndex].value;", us->listDisplayVar);

    hPrintf("<SELECT NAME=\"%s\" SIZE=%d onchange=\"%s\">",
    	us->listDisplayVar, slCount(list), js->string);
    printLabelList(us, list);
    hPrintf("</SELECT>\n");

    /* Put up other controls. */
    cgiMakeButton(us->formVar, "Delete Existing Setup");
    }

/* End form. */
    hPrintf("</FORM>\n");
    slFreeList(&list);
}

static void dyStringAppendQuoted(struct dyString *dy, char *s)
/* Append s to dyString, surrounding with quotes and escaping
 * internal quotes. */
{
char c;
dyStringAppendC(dy, '"');
while ((c = *s++) != 0)
    {
    if (c == '"')
       dyStringAppendC(dy, '\\');
    dyStringAppendC(dy, c);
    }
dyStringAppendC(dy, '"');
dyStringAppendC(dy, ' ');
}

static struct dyString *hashElsToSettings(struct hashEl *list)
/* Convert string valued hash elements to settings string. 
 * That is a string of var="val" pairs. */
{
struct dyString *dy = dyStringNew(1024);
struct hashEl *el;

for (el = list; el != NULL; el = el->next)
    {
    dyStringPrintf(dy, "%s=", el->name);
    dyStringAppendQuoted(dy, el->val);
    }
return dy;
}

static void saveSettings(struct cart *cart, char *varName, char *prefix)
/* Save settings that start with prefix to varName. */
{
struct hashEl *colVars;
struct dyString *dy;
colVars = cartFindPrefix(cart, prefix);
dy = hashElsToSettings(colVars);
cartSetString(cart, varName, dy->string);
dyStringFree(&dy);
slFreeList(&colVars);
}

boolean userSettingsProcessForm(struct userSettings *us)
/* Handle button press in userSettings form. 
 * If this returns TRUE then form is finished processing 
 * and you can call something to make the next page. */
{
struct cart *cart = us->cart;
char *command = cartString(cart, us->formVar);
boolean retVal = TRUE;
char *name = cartNonemptyString(cart, us->nameVar);

if (sameWord(command, "submit") && name != NULL)
    {
    char *varName = settingsVarName(us->savePrefix, name);
    saveSettings(cart, varName, us->settingsPrefix);
    freez(&varName);
    }
else if (startsWith("Delete", command))
    {
    char *which = cartOptionalString(cart, us->listDisplayVar);
    if (which != NULL)
        {
	char *varName = settingsVarName(us->savePrefix, which);
	cartRemove(cart, varName);
	userSettingsSaveForm(us, "After the Delete");
	retVal = FALSE;
	}
    }
cartRemove(cart, us->formVar);
return retVal;
}

void userSettingsDropDown(struct userSettings *us)
/* Display list of available saved settings . */
{
struct hashEl *el, *list = cartFindPrefix(us->cart, us->savePrefix);
if (list != NULL)
    {
    hPrintf("<SELECT NAME=\"%s\">\n", us->nameVar);
    slSort(&list, hashElCmp);
    printLabelList(us, list);
    slFreeList(&list);
    hPrintf("</SELECT>");
    }
}

