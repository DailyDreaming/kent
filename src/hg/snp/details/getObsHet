#!/usr/bin/perl -W

# takes dbSnp XML files as stdin and prints condensed information
# to stdout in one line per SNP in tab delimited format as the 
# first step of parsing the dbSnp data for loading into the fixed
# browser table hgFixed.dbSnpRS (supplemental details)

$rs=$a1=$a2=$seq5=$seq3=$valid=$seq5rc=$seq3rc="";
$het=$hetSE=0;

while (<>)
{
    if (/<NSE-rs>/) # start of new SNP
    {
      RS: while (<>)
      {
	  if (/<\/NSE-rs>/) # end of current SNP
	  {
	      if (!($a1 =~ /\//)) # print output if not triallelic
	      {   # alleles should be read into hash for compatibility with triallelic polymorphisms
		  if ($seq5  eq "") {$seq5="nnnnnnnn";       } # reset 5' flank region if null
		  if ($seq3  eq "") {$seq3="nnnnnnnn";       } # reset 3' flank region if null
		  if ($valid eq "") {$valid="no-information";} # initialize valid if null
		  if ($a1    eq "") {$a1 = "?";              } # initialize allele 1 if null
		  if ($a2    eq "") {$a2 = "?";              } # initialize allele 2 if null
		  print "rs$rs\t$het\t$hetSE\t$valid\t$a1\t$a2\t";
		  print substr($seq5,-20)."\t".substr($seq3,0,20)."\n";
	      }
	      # reinitialize
	      $rs=$a1=$a2=$seq5=$seq3=$valid=$seq5rc=$seq3rc="";
	      $het=$hetSE=0.0;
	      last RS;
	  }
	  if (/<(NSE-rs_refsnp-id)>(\S+)<\/\1>/)                  {$rs     = $2;}
	  elsif (/<(NSE-rs_observed)>(\S+)\/(\S+)<\/\1>/)         {$a1=$2; $a2=$3;}
	  elsif (/<(NSE-rs_seq-5_E)>(\S+)<\/\1>/)                 {$seq5  .= $2;}
	  elsif (/<(NSE-rs_seq-3_E)>(\S+)<\/\1>/)                 {$seq3  .= $2;}
	  elsif (/<(NSE-rs_het)>(\S+)<\/\1>/)                     {$het   += $2;}
	  elsif (/<(NSE-rs_het-SE)>(\S+)<\/\1>/ && ($2 ne "NaN")) {$hetSE += $2;}
	  elsif (/<(NSE-rs_validated-)(\S+) value=\"true\"\/>/)   {$valid .= $2;}
#	  print "rs$rs\t$het\t$hetSE\t$valid\t$a1\t$a2\t".substr($seq5,-20)."\t".substr($seq3,0,20)."\n";
      }
    }
}


