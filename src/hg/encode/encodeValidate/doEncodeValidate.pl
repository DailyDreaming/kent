#!/usr/bin/env perl

# encodeValidate.pl - validate an ENCODE data submission generated by the
#                       automated submission pipeline
# Verifies that all files and metadata are present and of correct formats
# Creates a load script (load.csh) and track configuration (trackDb.ra) 
#               for the datasets
# Writes error or log information to STDOUT
# Returns 0 if validation succeeds.

# DO NOT EDIT the /cluster/bin/scripts copy of this file -- 
# edit the CVS'ed source at:
# $Header: /projects/compbio/cvsroot/kent/src/hg/encode/encodeValidate/doEncodeValidate.pl,v 1.2 2007/12/18 00:28:48 kate Exp $

use warnings;
use strict;
use lib "/cluster/bin/scripts";
use HgAutomate;
use File::stat;

sub usage {
    die "usage: encodeValidate.pl <project submission dir>\n";
}

# Global constants
our $encodeConfigDir = '../config'; # change to /gbdb/encode before deployment
our $fieldConfigFile = $encodeConfigDir . "/fields.ra";
our $vocabConfigFile = $encodeConfigDir . "/cv.ra";
our $trackFile = 'trackDb.ra';
our $loadFile = 'load.csh';

# Global variables
our $submitDir;
our $opt_verbose = 1;

############################################################################
sub newestFile {
  # Get the most recently modified file from a list
    my @files = @_;
    my $newestTime = 0;
    my $newestFile = "";
    my $file = "";
    foreach $file (@files) {
        my $fileTime = (stat($file))->mtime;
        if ($fileTime > $newestTime) {
            $newestTime = $fileTime;
            $newestFile = $file;
        }
    }
    return $newestFile;
}

sub getPif {
    # Read info from Project Information File.  Verify required fields
    # are present and that the project is marked active.
    my %pif = ();
    my $pifFile = &newestFile(glob "*.PIF");
    &HgAutomate::verbose(1, "Using newest PIF file: $pifFile\n");
    open(IN, $pifFile) || die "ERROR: Can't open PIF file: $pifFile\n";
    while (my $line = <IN>) {
        # ignore empty lines and comments
        next if $line =~ /^$/;
        next if $line =~ /^\s*#/;
        chomp $line;
        my ($key, $val) = split(/\t/, $line);
        $pif{$key} = $val;
    }
    close(IN);
    # Validate fields
    if (!defined($pif{'project'})) { die "ERROR: project not defined\n"; }
    if (!defined($pif{'tracks'})) { die "ERROR: tracks not defined for project\n"};
    if ($pif{'active'} !~ "yes") { die "ERROR: project not yet active\n"; }
    return %pif;
}

sub readRaFile {
    # Read records from a .ra file into a hash of hashes and return it.
    my ($file, $type) = @_;
    open(IN, $file) ||
        die "ERROR: Can't open file: $fieldConfigFile\n";
    my @lines = <IN>;
    my %ra = ();
    my $raKey = undef;
    foreach my $line (@lines) {
        if ($line =~ /^$/) {
            $raKey = undef;
            next;
        }
        $line =~ s/^\s+//;
        next if $line =~ /^#/;
        $line =~ s/\s+$//;
        if ($line =~ m/^$type\s+(.*)/) {
            $raKey = $1;
        } else {
            if (!defined($raKey)) { 
                die "ERROR: missing $type before $line\n";
            }
            my ($key, $val) = split('\s+', $line, 2);
            $ra{$raKey}->{$key} = $val;
        }
    }
    close(IN);
    return %ra;
}

############################################################################
# Main

my $line;
my @ddfHeader;
my %ddfFields = ();

# Change dir to submission directory obtained from command-line
if (scalar(@ARGV) < 1) { usage(); }
$submitDir = $ARGV[0];
&HgAutomate::verbose(1, "Validating submission in directory \'$submitDir\'\n");
chdir $submitDir;

# Locate project information (PIF) file and verify that project is
#  ready for submission
my %pif = &getPif();

# Gather fields defined for DDF file. File is in 
# ra format:  field <name>, required <true|false>
my %fields = &readRaFile($fieldConfigFile, "field");

# Gather controlled vocabulary from ra file
my %cv = &readRaFile($vocabConfigFile, "term");

# Validate DDF
my $ddfFile = &newestFile(glob "*.DDF");
&HgAutomate::verbose(1, "Using newest DDF file: $ddfFile\n");
open(IN, $ddfFile) || die "ERROR: Can't open DDF file: $ddfFile\n";

# Get DDF header containing column names
while ($line = <IN>) {
    # ignore empty lines and comments
    next if $line =~ /^$/;
    next if $line =~ /^\s*#/;
    # remove trailing whitespace and newline
    $line =~ s/\s*$//;
    @ddfHeader = split(/\t/, $line);
    last;
}
close(IN);

exit 0;
