#!/usr/bin/env perl

# encodeLoad.pl - load ENCODE data submission generated by the
#                       automated submission pipeline
# Reads load.ra for information about what to do

# Writes error or log information to STDOUT
# Returns 0 if load succeeds and sends email to wrangler for given lab.

# DO NOT EDIT the /cluster/bin/scripts copy of this file -- 
# edit the CVS'ed source at:
# ~/kent/src/hg/encode/encodeLoad/doEncodeLoad.pl

# Usage:
# 
# ./doEncodeLoad.pl unused /cluster/data/encode/pipeline/encpipeline_kate/83

use warnings;
use strict;

use Getopt::Long;
use Cwd;
use File::Temp;
use File::Basename;

use lib "/cluster/bin/scripts";
use Encode;
use RAFile;

use vars qw/$opt_configDir $opt_noEmail $opt_outDir $opt_verbose/;

my $loadRa = "out/load.ra";
my $unloadRa = "out/unload.ra";
my $submitDir = "";
my $submitFQP;
my $submitType = "";
my $tempDir = "/data/tmp";
my $encodeDb = "hg18";
my $encInstance = "";
my $encProject = "";
my $sqlCreate = "/cluster/bin/sqlCreate";

my $debug = 0;

sub usage
{
    die <<END
usage: doEncodeLoad.pl submission_type project_submission_dir

Assumes existence of a file called: project_submission_dir/$loadRa
END
}

sub dieFile
{
    my ($file) = @_;
    open(FILE, $file);
    die join("", <FILE>);
}

sub loadGene
{
    my ($tableName, $fileList) = @_;

    if(system("cat $fileList | egrep -v '^track|browser' | ldHgGene -genePredExt $encodeDb $tableName stdin > out/loadGene.out 2>&1")) {
        print STDERR "ERROR: File(s) '$fileList' failed gene load.\n";
        dieFile("out/loadGene.out");
    } else {
        print "$fileList Loaded into $tableName\n";
        # debug restore: File.delete "genePred.tab";
    }
}

sub loadWig
{
    my ($tableName, $fileList) = @_;

    if(system( "cat $fileList | wigEncode stdin stdout $tableName.wib | hgLoadWiggle -pathPrefix=/gbdb/$encodeDb/wib -tmpDir=$tempDir $encodeDb $tableName stdin > out/loadWig.out 2>&1") ||
       system( "rm -f /gbdb/$encodeDb/wib/$tableName.wib") ||
       system( "ln -s $tableName.wib /gbdb/$encodeDb/wib")) {
       print STDERR "ERROR: File(s) $fileList failed wiggle load.\n";
       dieFile("out/loadWig.out")
   } else {
       print "$fileList Loaded into $tableName\n";
   }
}

sub loadBed
{
    my ($tableName, $fileList) = @_;
    #TEST by replacing "cat" with  "head -1000 -q"
    my $cmd = "cat $fileList | egrep -v '^track|browser' | hgLoadBed $encodeDb $tableName stdin -tmpDir=out > out/loadBed.out 2>&1";

    print STDERR "loadBed: cmd: $cmd\n" if($debug);

    if(system($cmd)) {
        print STDERR "ERROR: File(s) $fileList failed bed load.\n";
        dieFile("out/loadBed.out");
    } else {
        print "$fileList Loaded into $tableName\n";
        #debug restore: File.delete "out/bed.tab";
    }
}


sub loadBed5Plus
{
    my ($tableName, $fileList, $sqlTable) = @_;

    if(!(open(SQL, "$sqlCreate/${sqlTable}.sql"))) {
        die "$sqlCreate/${sqlTable}.sql not found; error: $!";
    }

    my $sql = join("", <SQL>);
    if(!($sql =~ s/$sqlTable/$tableName/g)) {
        die "sql names do not match for substitution: $sqlTable $tableName";
    }

    print STDERR "loadBed5Plus: $sql\n" if($debug);

    my ($fh, $tempFile) = File::Temp::tempfile("sqlXXXX", UNLINK => 1);
    print STDERR "tempFile: $tempFile\n" if($debug);
    $fh->print($sql);

    #TEST by replacing "cat" with  "head -1000 -q"
    
    my $cmd = "cat $fileList | egrep -v '^track|browser' | hgLoadBed $encodeDb $tableName stdin -tmpDir=out -sqlTable=$tempFile > out/loadBed.out 2>&1";

    print STDERR "cmd: $cmd\n" if($debug);

    if(system($cmd)) {
        print STDERR "ERROR: File(s) $fileList failed bed load.\n";
        dieFile("out/loadBed.out");
    } else {
        print "$fileList Loaded into $tableName\n";
        #debug restore: File.delete "out/bed.tab"
    }
    $fh->close();
    unlink($tempFile);
    close(SQL);
}


############################################################################
# Main

my $wd = cwd();

GetOptions("configDir=s", "noEmail", "outDir=s", "verbose=i") || usage();
$opt_verbose = 1 if (!defined $opt_verbose);
$opt_noEmail = 0 if (!defined $opt_noEmail);

# Change dir to submission directory obtained from command-line

if(@ARGV != 2) {
    usage();
}

$submitType = $ARGV[0];	# currently not used
$submitDir = $ARGV[1];
if ($submitDir =~ /^\//) {
    $submitFQP = $submitDir;
} else {
    $submitFQP = "$wd/$submitDir";
}

my $configPath;
if (defined $opt_configDir) {
    if ($opt_configDir =~ /^\//) {
        $configPath = $opt_configDir;
    } else {
        $configPath = "$wd/$opt_configDir";
    }
} else {
    $configPath = "$submitDir/../config"
}

my %labs = Encode::getLabs($configPath);
my %fields = Encode::getFields($configPath);
my %pif = Encode::getPif($submitDir, \%labs, \%fields);

$encInstance = dirname($submitDir);
$encProject = basename($submitDir);

# XXXX what is this for?
if($encInstance =~ /(_.*)/) {
    $encInstance = $1;
}

chdir($submitDir);

# clean out any stuff from previous load
# We assume unload program is in the same location as loader (fixes problem with misconfigured qateam environment).

my $programDir = dirname($0);
# XXXX change to "doEncodeUnload.pl" when ready
if(system("$programDir/doEncodeUnload.pl $submitType $submitDir")) {
    die "expected error running $programDir/doEncodeUnload.pl cleanup script";
}

if(!(-e $loadRa)) {
    die "unexpected error: load.ra not found\n";
}

#TODO change to : FileUtils.cp $loadRa, $unloadRa
# XXXX shouldn't we do the cp AFTER we finish everything else successfully?
if(system("cp $loadRa $unloadRa")) {
    die "Cannot: cp $loadRa $unloadRa";
}

print STDERR "Loading project in directory $submitDir\n" if($debug);

# Load files listed in load.ra

my %ra = RAFile::readRaFile($loadRa, 'tablename');

print STDERR "$loadRa has: " . scalar(keys %ra) . " records\n" if($debug);

print STDERR "\n" if($debug);

for my $key (keys %ra) {
    my $h = $ra{$key};
    my $tablenameExt = $h->{tablename} . "${encInstance}_$encProject";

    my $str = "\nkeyword: $key\n";
    for my $field (qw(tablename type tableType assembly files tablenameExt)) {
        if($h->{$field}) {
            $str .= "$field: " . $h->{$field} . "\n";
        }
    }
    $str .= "\n";
    HgAutomate::verbose(3, $str);

    # temporary work-around (XXXX, galt why is this "temporary?").
    $encodeDb = $h->{assembly};

    my $type = $h->{type};
    if($type eq "genePred") {
        loadGene($tablenameExt, $h->{files});
    } elsif ($type eq "wig") {
        loadWig($tablenameExt, $h->{files});
    } elsif ($type eq "bed 5 +") {
        loadBed5Plus($tablenameExt, $h->{files}, $h->{tableType});
    } elsif (($type eq "bed 3") || ($type eq "bed 4") || ($type eq "bed 4") || ($type eq "bed 5") || ($type eq "bed 6")) {
        loadBed($tablenameExt, $h->{files});
    } else {
        die "ERROR: unknown type: $type in load.ra\n";
    }
    print STDERR "\n" if($debug);
}

# Send "data is ready" email to email contact assigned to $pif{lab}

if($labs{$pif{lab}} && $labs{$pif{lab}}->{wranglerEmail} && !$opt_noEmail) {
    my $email = $labs{$pif{lab}}->{wranglerEmail};
    `echo "dir: $submitFQP" | /bin/mail -s "ENCODE data from $pif{lab} lab is ready" $email`;
}

exit(0);
