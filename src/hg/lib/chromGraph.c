/* chromGraph.c was originally generated by the autoSql program, which also 
 * generated chromGraph.h and chromGraph.sql.  This module links the database and
 * the RAM representation of objects. */

#include "common.h"
#include "linefile.h"
#include "dystring.h"
#include "obscure.h"
#include "jksql.h"
#include "chromGraph.h"

static char const rcsid[] = "$Id: chromGraph.c,v 1.3 2006/06/13 03:03:17 kent Exp $";

void chromGraphStaticLoad(char **row, struct chromGraph *ret)
/* Load a row from chromGraph table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->chrom = row[0];
ret->chromStart = sqlSigned(row[1]);
ret->val = atof(row[2]);
}

struct chromGraph *chromGraphLoad(char **row)
/* Load a chromGraph from row fetched with select * from chromGraph
 * from database.  Dispose of this with chromGraphFree(). */
{
struct chromGraph *ret;

AllocVar(ret);
ret->chrom = cloneString(row[0]);
ret->chromStart = sqlSigned(row[1]);
ret->val = atof(row[2]);
return ret;
}

struct chromGraph *chromGraphLoadAll(char *fileName) 
/* Load all chromGraph from a whitespace-separated file.
 * Dispose of this with chromGraphFreeList(). */
{
struct chromGraph *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[3];

while (lineFileRow(lf, row))
    {
    el = chromGraphLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct chromGraph *chromGraphLoadAllByChar(char *fileName, char chopper) 
/* Load all chromGraph from a chopper separated file.
 * Dispose of this with chromGraphFreeList(). */
{
struct chromGraph *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[3];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = chromGraphLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct chromGraph *chromGraphCommaIn(char **pS, struct chromGraph *ret)
/* Create a chromGraph out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new chromGraph */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->chrom = sqlStringComma(&s);
ret->chromStart = sqlSignedComma(&s);
ret->val = sqlFloatComma(&s);
*pS = s;
return ret;
}

void chromGraphFree(struct chromGraph **pEl)
/* Free a single dynamically allocated chromGraph such as created
 * with chromGraphLoad(). */
{
struct chromGraph *el;

if ((el = *pEl) == NULL) return;
freeMem(el->chrom);
freez(pEl);
}

void chromGraphFreeList(struct chromGraph **pList)
/* Free a list of dynamically allocated chromGraph's */
{
struct chromGraph *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    chromGraphFree(&el);
    }
*pList = NULL;
}

void chromGraphOutput(struct chromGraph *el, FILE *f, char sep, char lastSep) 
/* Print out chromGraph.  Separate fields with sep. Follow last field with lastSep. */
{
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->chrom);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%d", el->chromStart);
fputc(sep,f);
fprintf(f, "%g", el->val);
fputc(lastSep,f);
}

/* -------------------------------- End autoSql Generated Code -------------------------------- */

int chromGraphCmp(const void *va, const void *vb)
/* Compare to sort based on query chromStart. */
{
const struct chromGraph *a = *((struct chromGraph **)va);
const struct chromGraph *b = *((struct chromGraph **)vb);
int dif;
dif = strcmp(a->chrom, b->chrom);
if (dif == 0)
    dif = a->chromStart - b->chromStart;
return dif;
}

void chromGraphVarName(char *track, char *var, 
	char output[chromGraphVarNameMaxSize])
/* Fill in output with name of cart variable. */
{
safef(output, chromGraphVarNameMaxSize, "%s_%s_%s", "cgs", track, var);
}

void chromGraphDataRange(char *trackName, struct sqlConnection *conn,
	double *retMin, double *retMax)
/* Get min/max values observed from metaChromGraph table */
{
char query[256];
struct sqlResult *sr;
char **row;
safef(query, sizeof(query), 
    "select minVal,maxVal from metaChromGraph where name='%s'",
    trackName);
sr = sqlGetResult(conn, query);
row = sqlNextRow(sr);
if (row == NULL)
    errAbort("%s is not in metaChromGraph", trackName);
*retMin = atof(row[0]);
*retMax = atof(row[1]);
sqlFreeResult(&sr);
}

struct chromGraphSettings *chromGraphSettingsGet(char *trackName,
	struct sqlConnection *conn, struct trackDb *tdb, struct cart *cart)
/* Get settings for chromGraph track.  If you pass in all NULLs
 * you'll get a reasonable default. */
{
struct chromGraphSettings *cgs;

/* Allocate in memory with default settings */
AllocVar(cgs);
cgs->maxGapToFill = 25000;
cgs->minVal = 0;
cgs->maxVal = 100;
cgs->minPixels = 8;
cgs->pixels = 32;
cgs->maxPixels = 128;

/* Try and fill in max/min from database. */
if (conn != NULL)
    {
    chromGraphDataRange(trackName, conn, &cgs->minVal, &cgs->maxVal);
    }

/* Try and fill in settings from tdb */
if (tdb != NULL)
    {
    char *setting;
    if ((setting = trackDbSetting(tdb, "maxGapToFill")) != NULL)
        cgs->maxGapToFill = sqlUnsigned(setting);
    if ((setting = trackDbSetting(tdb, "minMax")) != NULL)
	{
	struct slName *list = commaSepToSlNames(setting);
	if (slCount(list) != 2)
	    errAbort("minMax must have two values in %s", trackName);
	cgs->minVal = atof(list->name);
	cgs->maxVal = atof(list->next->name);
	slFreeList(&list);
	}
    if ((setting = trackDbSetting(tdb, "linesAt")) != NULL)
	{
	struct slName *el, *list = commaSepToSlNames(setting);
	int i;
	cgs->linesAtCount = slCount(list);
	if (cgs->linesAtCount <= 0)
	    errAbort("Missing linesAt data in %s", trackName);
	AllocArray(cgs->linesAt, cgs->linesAtCount);
	for (i=0,el=list; el!=NULL; ++i,el=el->next)
	    cgs->linesAt[i] = atof(el->name);
	slFreeList(&list);
	}
    if ((setting = trackDbSetting(tdb, "maxHeightPixels")) != NULL)
        {
	struct slName *list = charSepToSlNames(setting, ':');
	if (slCount(list) != 3)
	    errAbort("maxHeightPixels in %s must have 3 : separated fields", 
	    	trackName);
	cgs->maxPixels = sqlUnsigned(list->name);
	cgs->pixels = sqlUnsigned(list->next->name);
	cgs->minPixels = sqlUnsigned(list->next->next->name);
	}
    }

/* Finally try and fill in settings from cart */
if (cart != NULL)
    {
    char varName[chromGraphVarNameMaxSize];
    chromGraphVarName(trackName, "maxGapToFill", varName);
    cgs->maxGapToFill = cartUsualInt(cart, varName, cgs->maxGapToFill);
    chromGraphVarName(trackName, "minVal", varName);
    cgs->minVal = cartUsualDouble(cart, varName, cgs->minVal);
    chromGraphVarName(trackName, "maxVal", varName);
    cgs->maxVal = cartUsualDouble(cart, varName, cgs->maxVal);
    chromGraphVarName(trackName, "pixels", varName);
    cgs->pixels = cartUsualInt(cart, varName, cgs->pixels);
    if (cgs->pixels < cgs->minPixels)
        cgs->pixels = cgs->minPixels;
    if (cgs->pixels > cgs->maxPixels)
        cgs->pixels = cgs->maxPixels;
    }
return cgs;
}
