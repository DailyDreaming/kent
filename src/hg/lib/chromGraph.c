/* chromGraph.c was originally generated by the autoSql program, which also 
 * generated chromGraph.h and chromGraph.sql.  This module links the database and
 * the RAM representation of objects. */

#include "common.h"
#include "linefile.h"
#include "dystring.h"
#include "obscure.h"
#include "jksql.h"
#include "sig.h"
#include "chromGraph.h"

static char const rcsid[] = "$Id: chromGraph.c,v 1.5 2006/06/23 23:45:03 kent Exp $";

void chromGraphStaticLoad(char **row, struct chromGraph *ret)
/* Load a row from chromGraph table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->chrom = row[0];
ret->chromStart = sqlSigned(row[1]);
ret->val = atof(row[2]);
}

struct chromGraph *chromGraphLoad(char **row)
/* Load a chromGraph from row fetched with select * from chromGraph
 * from database.  Dispose of this with chromGraphFree(). */
{
struct chromGraph *ret;

AllocVar(ret);
ret->chrom = cloneString(row[0]);
ret->chromStart = sqlSigned(row[1]);
ret->val = atof(row[2]);
return ret;
}

struct chromGraph *chromGraphLoadAll(char *fileName) 
/* Load all chromGraph from a whitespace-separated file.
 * Dispose of this with chromGraphFreeList(). */
{
struct chromGraph *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[3];

while (lineFileRow(lf, row))
    {
    el = chromGraphLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct chromGraph *chromGraphLoadAllByChar(char *fileName, char chopper) 
/* Load all chromGraph from a chopper separated file.
 * Dispose of this with chromGraphFreeList(). */
{
struct chromGraph *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[3];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = chromGraphLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct chromGraph *chromGraphCommaIn(char **pS, struct chromGraph *ret)
/* Create a chromGraph out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new chromGraph */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->chrom = sqlStringComma(&s);
ret->chromStart = sqlSignedComma(&s);
ret->val = sqlFloatComma(&s);
*pS = s;
return ret;
}

void chromGraphFree(struct chromGraph **pEl)
/* Free a single dynamically allocated chromGraph such as created
 * with chromGraphLoad(). */
{
struct chromGraph *el;

if ((el = *pEl) == NULL) return;
freeMem(el->chrom);
freez(pEl);
}

void chromGraphFreeList(struct chromGraph **pList)
/* Free a list of dynamically allocated chromGraph's */
{
struct chromGraph *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    chromGraphFree(&el);
    }
*pList = NULL;
}

void chromGraphOutput(struct chromGraph *el, FILE *f, char sep, char lastSep) 
/* Print out chromGraph.  Separate fields with sep. Follow last field with lastSep. */
{
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->chrom);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%d", el->chromStart);
fputc(sep,f);
fprintf(f, "%g", el->val);
fputc(lastSep,f);
}

/* -------------------------------- End autoSql Generated Code -------------------------------- */

int chromGraphCmp(const void *va, const void *vb)
/* Compare to sort based on query chromStart. */
{
const struct chromGraph *a = *((struct chromGraph **)va);
const struct chromGraph *b = *((struct chromGraph **)vb);
int dif;
dif = strcmp(a->chrom, b->chrom);
if (dif == 0)
    dif = a->chromStart - b->chromStart;
return dif;
}

void chromGraphVarName(char *track, char *var, 
	char output[chromGraphVarNameMaxSize])
/* Fill in output with name of cart variable. */
{
safef(output, chromGraphVarNameMaxSize, "%s_%s_%s", "cgs", track, var);
}

void chromGraphDataRange(char *trackName, struct sqlConnection *conn,
	double *retMin, double *retMax)
/* Get min/max values observed from metaChromGraph table */
{
char query[256];
struct sqlResult *sr;
char **row;
safef(query, sizeof(query), 
    "select minVal,maxVal from metaChromGraph where name='%s'",
    trackName);
sr = sqlGetResult(conn, query);
row = sqlNextRow(sr);
if (row == NULL)
    errAbort("%s is not in metaChromGraph", trackName);
*retMin = atof(row[0]);
*retMax = atof(row[1]);
sqlFreeResult(&sr);
}

struct slName *chromGraphListAll(struct sqlConnection *conn)
/* Return list of all chrom graph tables. */
{
return sqlQuickList(conn, "select name from metaChromGraph");
}

char *chromGraphBinaryFileName(char *trackName, struct sqlConnection *conn)
/* Get binary file name associated with chromGraph track. Returns NULL
 * if no such file or track. FreeMem result when done. */
{
char query[256];
safef(query, sizeof(query), 
	"select binaryFile from metaChromGraph where name='%s'", trackName);
return sqlQuickString(conn, query);
}


struct chromGraphSettings *chromGraphSettingsGet(char *trackName,
	struct sqlConnection *conn, struct trackDb *tdb, struct cart *cart)
/* Get settings for chromGraph track.  If you pass in all NULLs
 * you'll get a reasonable default. */
{
struct chromGraphSettings *cgs;

/* Allocate in memory with default settings */
AllocVar(cgs);
cgs->maxGapToFill = 25000;
cgs->minVal = 0;
cgs->maxVal = 100;
cgs->minPixels = 8;
cgs->pixels = 32;
cgs->maxPixels = 128;

/* Try and fill in max/min from database. */
if (conn != NULL)
    {
    chromGraphDataRange(trackName, conn, &cgs->minVal, &cgs->maxVal);
    }

/* Try and fill in settings from tdb */
if (tdb != NULL)
    {
    char *setting;
    if ((setting = trackDbSetting(tdb, "maxGapToFill")) != NULL)
        cgs->maxGapToFill = sqlUnsigned(setting);
    if ((setting = trackDbSetting(tdb, "minMax")) != NULL)
	{
	struct slName *list = commaSepToSlNames(setting);
	if (slCount(list) != 2)
	    errAbort("minMax must have two values in %s", trackName);
	cgs->minVal = atof(list->name);
	cgs->maxVal = atof(list->next->name);
	slFreeList(&list);
	}
    if ((setting = trackDbSetting(tdb, "linesAt")) != NULL)
	{
	struct slName *el, *list = commaSepToSlNames(setting);
	int i;
	cgs->linesAtCount = slCount(list);
	if (cgs->linesAtCount <= 0)
	    errAbort("Missing linesAt data in %s", trackName);
	AllocArray(cgs->linesAt, cgs->linesAtCount);
	for (i=0,el=list; el!=NULL; ++i,el=el->next)
	    cgs->linesAt[i] = atof(el->name);
	slFreeList(&list);
	}
    if ((setting = trackDbSetting(tdb, "maxHeightPixels")) != NULL)
        {
	struct slName *list = charSepToSlNames(setting, ':');
	if (slCount(list) != 3)
	    errAbort("maxHeightPixels in %s must have 3 : separated fields", 
	    	trackName);
	cgs->maxPixels = sqlUnsigned(list->name);
	cgs->pixels = sqlUnsigned(list->next->name);
	cgs->minPixels = sqlUnsigned(list->next->next->name);
	}
    }

/* Finally try and fill in settings from cart */
if (cart != NULL)
    {
    char varName[chromGraphVarNameMaxSize];
    chromGraphVarName(trackName, "maxGapToFill", varName);
    cgs->maxGapToFill = cartUsualInt(cart, varName, cgs->maxGapToFill);
    chromGraphVarName(trackName, "minVal", varName);
    cgs->minVal = cartUsualDouble(cart, varName, cgs->minVal);
    chromGraphVarName(trackName, "maxVal", varName);
    cgs->maxVal = cartUsualDouble(cart, varName, cgs->maxVal);
    chromGraphVarName(trackName, "pixels", varName);
    cgs->pixels = cartUsualInt(cart, varName, cgs->pixels);
    if (cgs->pixels < cgs->minPixels)
        cgs->pixels = cgs->minPixels;
    if (cgs->pixels > cgs->maxPixels)
        cgs->pixels = cgs->maxPixels;
    }
return cgs;
}

void chromGraphToBin(struct chromGraph *list, char *fileName)
/* Create binary representation of chromGraph list, which should
 * be sorted. */
{
struct chromGraph *el;
char *lastChrom = "";
bits32 lastPos = 0;
FILE *f = mustOpen(fileName, "wb");
bits32 sig = chromGraphSig;
bits32 endMarker = (bits32)(-1);
writeOne(f, sig);
for (el = list; el != NULL; el = el->next)
    {
    bits32 pos = el->chromStart;
    if (!sameString(el->chrom, lastChrom))
        {
	int length = strlen(el->chrom);
	UBYTE len = length;
	if (el != list)
	    {
	    writeOne(f, endMarker);
	    }
	if (length > 255)
	    errAbort("Chrom name %s too long", el->chrom);
	writeOne(f, len);
	mustWrite(f, el->chrom, length);
	lastChrom = el->chrom;
	lastPos = 0;
	}
    if (lastPos > pos)
        errAbort("%s is not sorted", fileName);
    lastPos = pos;
    writeOne(f, pos);
    writeOne(f, el->val);
    }
writeOne(f, endMarker);
carefulClose(&f);
}
	  

struct chromGraphBin *chromGraphBinOpen(char *path)
/* Open up a chromGraphBin file */
{
struct chromGraphBin *cgb;
FILE *f = mustOpen(path, "rb");
bits32 sig;
AllocVar(cgb);
cgb->fileName = cloneString(path);
cgb->f = f;
if (!readOne(f, sig))
    errAbort("%s is empty", path);
if (sig == chromGraphSig)
    cgb->isSwapped = FALSE;
else if (sig == chromGraphSwapSig)
    cgb->isSwapped = TRUE;
else
    errAbort("%s is not a chromGraph binary file", path);
return cgb;
}

void chromGraphBinFree(struct chromGraphBin **pCgb)
/* Close down and free up chromGraphBin. */
{
struct chromGraphBin *cgb = *pCgb;
if (cgb != NULL)
     {
     freeMem(cgb->fileName);
     carefulClose(&cgb->f);
     freez(pCgb);
     }
}

boolean chromGraphBinNextChrom(struct chromGraphBin *cgb)
/* Fetch next chromosome, or FALSE if at end of file. */
{
UBYTE size;
FILE *f = cgb->f;
if (!readOne(f, size))
    return FALSE;
mustRead(f, cgb->chrom, size);
cgb->chrom[size] = 0;
return TRUE;
}

boolean chromGraphBinNextVal(struct chromGraphBin *cgb)
/* Fetch next chromStart/val or FALSE if at end of chromosome. */
{
FILE *f = cgb->f;
mustReadOne(f, cgb->chromStart);
if (cgb->isSwapped)
    cgb->chromStart = byteSwap32(cgb->chromStart);
if (cgb->chromStart == (bits32)(-1))
    return FALSE;
mustReadOne(f, cgb->val);
return TRUE;
}

