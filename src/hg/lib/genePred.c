/* genePred.c was originally generated by the autoSql program, which also 
 * generated genePred.h and genePred.sql.  This module links the database and the RAM 
 * representation of objects. */

#include "common.h"
#include "jksql.h"
#include "gff.h"
#include "psl.h"
#include "linefile.h"
#include "genePred.h"
#include "hdb.h"

static char const rcsid[] = "$Id: genePred.c,v 1.21 2003/12/31 22:50:22 weber Exp $";

/* SQL to create a genePred table */
static char *createSql = 
"CREATE TABLE %s ("
"   name varchar(255) not null,"	/* mrna accession of gene */
"   chrom varchar(255) not null,"	/* Chromosome name */
"   strand char(1) not null,"		/* + or - for strand */
"   txStart int unsigned not null,"	/* Transcription start position */
"   txEnd int unsigned not null,"	/* Transcription end position */
"   cdsStart int unsigned not null,"	/* Coding region start */
"   cdsEnd int unsigned not null,"	/* Coding region end */
"   exonCount int unsigned not null,"	/* Number of exons */
"   exonStarts longblob not null,"	/* Exon start positions */
"   exonEnds longblob not null,"	/* Exon end positions */
"   INDEX(name(10)),"
"   INDEX(chrom(12),txStart),"
"   INDEX(chrom(12),txEnd)"
")";


struct genePred *genePredLoad(char **row)
/* Load a genePred from row fetched with select * from genePred
 * from database.  Dispose of this with genePredFree(). */
{
struct genePred *ret;
int sizeOne,i;
char *s;

AllocVar(ret);
ret->exonCount = sqlUnsigned(row[7]);
ret->name = cloneString(row[0]);
ret->chrom = cloneString(row[1]);
strcpy(ret->strand, row[2]);
ret->txStart = sqlUnsigned(row[3]);
ret->txEnd = sqlUnsigned(row[4]);
ret->cdsStart = sqlUnsigned(row[5]);
ret->cdsEnd = sqlUnsigned(row[6]);
sqlUnsignedDynamicArray(row[8], &ret->exonStarts, &sizeOne);
assert(sizeOne == ret->exonCount);
sqlUnsignedDynamicArray(row[9], &ret->exonEnds, &sizeOne);
assert(sizeOne == ret->exonCount);
return ret;
}

struct genePred *genePredCommaIn(char **pS, struct genePred *ret)
/* Create a genePred out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new genePred */
{
char *s = *pS;
int i;

if (ret == NULL)
    AllocVar(ret);
ret->name = sqlStringComma(&s);
ret->chrom = sqlStringComma(&s);
sqlFixedStringComma(&s, ret->strand, sizeof(ret->strand));
ret->txStart = sqlUnsignedComma(&s);
ret->txEnd = sqlUnsignedComma(&s);
ret->cdsStart = sqlUnsignedComma(&s);
ret->cdsEnd = sqlUnsignedComma(&s);
ret->exonCount = sqlUnsignedComma(&s);
s = sqlEatChar(s, '{');
AllocArray(ret->exonStarts, ret->exonCount);
for (i=0; i<ret->exonCount; ++i)
    {
    ret->exonStarts[i] = sqlUnsignedComma(&s);
    }
s = sqlEatChar(s, '}');
s = sqlEatChar(s, ',');
s = sqlEatChar(s, '{');
AllocArray(ret->exonEnds, ret->exonCount);
for (i=0; i<ret->exonCount; ++i)
    {
    ret->exonEnds[i] = sqlUnsignedComma(&s);
    }
s = sqlEatChar(s, '}');
s = sqlEatChar(s, ',');
*pS = s;
return ret;
}

void genePredFree(struct genePred **pEl)
/* Free a single dynamically allocated genePred such as created
 * with genePredLoad(). */
{
struct genePred *el;

if ((el = *pEl) == NULL) return;
freeMem(el->name);
freeMem(el->chrom);
freeMem(el->exonStarts);
freeMem(el->exonEnds);
freez(pEl);
}

void genePredFreeList(struct genePred **pList)
/* Free a list of dynamically allocated genePred's */
{
struct genePred *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    genePredFree(&el);
    }
*pList = NULL;
}

void genePredOutput(struct genePred *el, FILE *f, char sep, char lastSep) 
/* Print out genePred.  Separate fields with sep. Follow last field with lastSep. */
{
int i;
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->name);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->chrom);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->strand);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%u", el->txStart);
fputc(sep,f);
fprintf(f, "%u", el->txEnd);
fputc(sep,f);
fprintf(f, "%u", el->cdsStart);
fputc(sep,f);
fprintf(f, "%u", el->cdsEnd);
fputc(sep,f);
fprintf(f, "%u", el->exonCount);
fputc(sep,f);
if (sep == ',') fputc('{',f);
for (i=0; i<el->exonCount; ++i)
    {
    fprintf(f, "%u", el->exonStarts[i]);
    fputc(',', f);
    }
if (sep == ',') fputc('}',f);
fputc(sep,f);
if (sep == ',') fputc('{',f);
for (i=0; i<el->exonCount; ++i)
    {
    fprintf(f, "%u", el->exonEnds[i]);
    fputc(',', f);
    }
if (sep == ',') fputc('}',f);
fputc(lastSep,f);
}

/* ---------  Start of hand generated code. ---------------------------- */

struct genePred *genePredLoadAll(char *fileName) 
/* Load all genePred from a tab-separated file.
 * Dispose of this with genePredFreeList(). */
{
struct genePred *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[10];

while (lineFileRow(lf, row))
    {
    el = genePredLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

int genePredCmp(const void *va, const void *vb)
/* Compare to sort based on chromosome, txStart. */
{
const struct genePred *a = *((struct genePred **)va);
const struct genePred *b = *((struct genePred **)vb);
int dif;
dif = strcmp(a->chrom, b->chrom);
if (dif == 0)
    dif = a->txStart - b->txStart;
return dif;
}


struct genePred *genePredFromGroupedGff(struct gffFile *gff, struct gffGroup *group, char *name,
	char *exonSelectWord)
/* Convert gff->groupList to genePred list. */
{
struct genePred *gp;
int cdsStart = BIGNUM, cdsEnd = -BIGNUM;
int exonCount = 0;
struct gffLine *gl;
unsigned *eStarts, *eEnds;
int i;
boolean anyExon = FALSE;

/* Look to see if any exons.  If not allow CDS to be
 * used instead. */
if (exonSelectWord)
    {
    for (gl = group->lineList; gl != NULL; gl = gl->next)
	{
	if (sameWord(gl->feature, exonSelectWord))
	    {
	    anyExon = TRUE;
	    break;
	    }
	}
    }
else
    anyExon = TRUE;
if (!anyExon)
    exonSelectWord = "CDS";

/* Count up exons and figure out cdsStart and cdsEnd. */
for (gl = group->lineList; gl != NULL; gl = gl->next)
    {
    char *feat = gl->feature;
    if (exonSelectWord == NULL || sameWord(feat, exonSelectWord))
        {
	++exonCount;
	}
    if (sameWord(feat, "CDS") || sameWord(feat, "start_codon") 
        || sameWord(feat, "stop_codon"))
	{
	if (gl->start < cdsStart) cdsStart = gl->start;
	if (gl->end > cdsEnd) cdsEnd = gl->end;
	}
    }
if (cdsStart > cdsEnd)
    {
    cdsStart = group->start;
    cdsEnd = group->end;
    }
if (exonCount == 0)
    return NULL;

/* Allocate genePred and fill in values. */
AllocVar(gp);
gp->name = cloneString(name);
gp->chrom = cloneString(group->seq);
gp->strand[0] = group->strand;
gp->txStart = group->start;
gp->txEnd = group->end;
gp->cdsStart = cdsStart;
gp->cdsEnd = cdsEnd;
gp->exonCount = exonCount;
gp->exonStarts = AllocArray(eStarts, exonCount);
gp->exonEnds = AllocArray(eEnds, exonCount);
i = 0;
for (gl = group->lineList; gl != NULL; gl = gl->next)
    {
    if (exonSelectWord == NULL || sameWord(gl->feature, exonSelectWord))
        {
	eStarts[i] = gl->start;
	eEnds[i] = gl->end;
	++i;
	}
    }
return gp;
}


struct genePred *genePredFromGroupedGtf(struct gffFile *gff, struct gffGroup *group, char *name)
/* Convert gff->groupList to genePred list, using GTF feature conventions;
 * including the stop codon in the 3' UTR, not the CDS (grr).  Assumes
 * gffGroup is sorted in assending coords, with overlaping starts sorted by
 * end coords, which is true if it was created by gffGroupLines(). */
{
struct genePred *gp;
int stopCodonStart = -1, stopCodonEnd = -1;
int cdsStart = BIGNUM, cdsEnd = -BIGNUM;
int exonCount = 0;
struct gffLine *gl;
unsigned *eStarts, *eEnds;
int i;
boolean anyExon = FALSE;

/* Count up exons and figure out cdsStart and cdsEnd. */
for (gl = group->lineList; gl != NULL; gl = gl->next)
    {
    char *feat = gl->feature;
    if (sameWord(feat, "CDS") || sameWord(feat, "exon"))
        {
	++exonCount;
	}
    if (sameWord(feat, "CDS"))
	{
	if (gl->start < cdsStart) cdsStart = gl->start;
	if (gl->end > cdsEnd) cdsEnd = gl->end;
	}
    if (sameWord(feat, "stop_codon"))
        {
        stopCodonStart = gl->start;
        stopCodonEnd = gl->end;
        }
    }
if (exonCount == 0)
    return NULL;
if (cdsStart > cdsEnd)
    {
    cdsStart = group->start;
    cdsEnd = group->end;
    }
/* adjust CDS to include stop codon */
if (stopCodonStart >= 0)
    {
    if (group->strand == '+')
        cdsEnd = stopCodonEnd;
    else
        cdsStart = stopCodonStart;
    }

/* Allocate genePred and fill in values. */
AllocVar(gp);
gp->name = cloneString(name);
gp->chrom = cloneString(group->seq);
gp->strand[0] = group->strand;
gp->txStart = group->start;
gp->txEnd = group->end;
gp->cdsStart = cdsStart;
gp->cdsEnd = cdsEnd;
gp->exonStarts = AllocArray(eStarts, exonCount);
gp->exonEnds = AllocArray(eEnds, exonCount);

/* adjust tx range to include stop codon */
if ((group->strand == '+') && (gp->txEnd == stopCodonStart))
     gp->txEnd = stopCodonEnd;
else if ((group->strand == '-') && (gp->txStart == stopCodonEnd))
    gp->txStart = stopCodonStart;

i = 0;
/* fill in exons, merging overlaping and adjacent exons */
for (gl = group->lineList; gl != NULL; gl = gl->next)
    {
    if (sameWord(gl->feature, "CDS") || sameWord(gl->feature, "exon"))
        {
        if ((i == 0) || (gl->start > eEnds[i-1]))
            {
            eStarts[i] = gl->start;
            eEnds[i] = gl->end;
            ++i;
            }
        else
            {
            /* overlap, extend exon */
            assert(gl->start >= eStarts[i-1]);
            eEnds[i-1] = gl->end;
            }
        /* extend exon for stop codon if needed */
        if ((group->strand == '+') && (eEnds[i-1] == stopCodonStart))
            eEnds[i-1] = stopCodonEnd;
        else if ((group->strand == '-') && (eStarts[i-1] == stopCodonEnd))
            eStarts[i-1] = stopCodonStart;
        }
    }
gp->exonCount= i;
return gp;
}

void findCdsStartEndInGenome(struct psl *psl,
                                    int rnaCdsStart, int rnaCdsEnd,
                                    int *retCdsStart, int *retCdsEnd,
                                    boolean haveRefSeqInfo)
/* Convert cdsStart/End from mrna to genomic coordinates. */
{
int startOffset, endOffset;
int cdsStart = -1, cdsEnd = -1;
int i;

/* get CDS offsets in portion of query that aligned */
if (psl->strand[0] == '-')
    {
    endOffset = rnaCdsStart - psl->qStart;
    startOffset =  psl->qEnd - rnaCdsEnd;
    }
else
    {
    startOffset = rnaCdsStart - psl->qStart;
    endOffset =  psl->qEnd - rnaCdsEnd;
    }

/* Adjust starting pos. */
for (i=0; i<psl->blockCount; ++i)
    {
    int blockSize = psl->blockSizes[i];
    if (startOffset < 0) startOffset = 0;
    if (startOffset < blockSize)
	{
        cdsStart = psl->tStarts[i] + startOffset;
	break;
	}

    /* Adjust start offset for this block.  Also adjust for
     * query sequence between blocks that doesn't align. */
    startOffset -= blockSize;
    if (i != psl->blockCount - 1)
	{
	int skip =  psl->qStarts[i+1] - (psl->qStarts[i] + blockSize);
	startOffset -= skip;
	}
    }

/* Adjust end pos. */
for (i=psl->blockCount-1; i >= 0; --i)
    {
    int blockSize = psl->blockSizes[i];
    if (endOffset < 0) endOffset = 0;
    if (endOffset < blockSize)
        {
	cdsEnd = psl->tStarts[i] + blockSize - endOffset;
	break;
	}
    /* Adjust start offset for this block.  Also adjust for
     * query sequence between blocks that doesn't align. */
    endOffset -= blockSize;
    if (i != 0)
        {
	int skip =  psl->qStarts[i] - (psl->qStarts[i-1] + psl->blockSizes[i-1]);
	endOffset -= skip;

    if (haveRefSeqInfo && endOffset < 0)  /* CDS end was in gap, ugh! */
        {       
        cdsEnd = psl->tStarts[i] + blockSize;
        break;  
        }
	}
    }

/* one or both not found, mark as no CDS annotation */ 
if ((cdsStart == -1) || (cdsEnd == -1))
    cdsEnd = cdsStart = psl->tEnd;
else if(!haveRefSeqInfo)
    {
    if (psl->strand[1] == '-')
        reverseIntRange(&cdsStart, &cdsEnd, psl->tSize);
    }
*retCdsStart = cdsStart;
*retCdsEnd = cdsEnd;
}

static void pslToExons(struct psl *psl, struct genePred *gene,
                       int insertMergeSize)
/* Convert psl alignment blocks to genePred exons, merging together blocks
 * separated by small inserts as necessary. */
{
int iBlk, iExon = -1;
int startIdx, stopIdx, idxIncr;

gene->exonStarts = needMem(psl->blockCount*sizeof(unsigned));
gene->exonEnds = needMem(psl->blockCount*sizeof(unsigned));

if (psl->strand[1] == '-')
    {
    startIdx = psl->blockCount-1;
    stopIdx = -1;
    idxIncr = -1;
    }
else
    {
    startIdx = 0;
    stopIdx = psl->blockCount;
    idxIncr = 1;
    }

for (iBlk = startIdx; iBlk != stopIdx; iBlk += idxIncr)
    {
    unsigned tStart = psl->tStarts[iBlk];
    unsigned tEnd = tStart + psl->blockSizes[iBlk];
    if (psl->strand[1] == '-')
        reverseIntRange(&tStart, &tEnd, psl->tSize);
    if ((iExon < 0) || ((int)(tStart - gene->exonEnds[iExon]) > insertMergeSize))
        {
        iExon++;
        gene->exonStarts[iExon] = tStart;
	}
    gene->exonEnds[iExon] = tEnd;
    }
gene->exonCount = iExon+1;
}

struct genePred *genePredFromPsl(struct psl *psl, int cdsStart, int cdsEnd,
                                 int insertMergeSize)
/* Convert a PSL of an RNA alignment to a genePred, converting a genbank CDS
 * specification string to genomic coordinates. Small inserts, no more
 * than insertMergeSize, will be dropped and the blocks merged.  CDS start or
 * end of -1 creates without CDS annotation*/
{
struct genePred *gene;
AllocVar(gene);
gene->name = cloneString(psl->qName);
gene->chrom = cloneString(psl->tName);
gene->txStart = psl->tStart;
gene->txEnd = psl->tEnd;

/* get strand in genome that the positive version mRNA aligns to */
if (psl->strand[1] == '\0')
    {
    /* assumed pos target strand, so neg query would be pos target */
    gene->strand[0] = psl->strand[0];
    }
else 
    {
    /* query and target strand are different; will be neg when query pos */
    gene->strand[0] = ((psl->strand[0] != psl->strand[1]) ? '-' : '+');
    }

if ((cdsStart == -1) || (cdsEnd == -1))
    {
    gene->cdsStart = psl->tEnd;
    gene->cdsEnd = psl->tEnd;
    }
else
    findCdsStartEndInGenome(psl, cdsStart, cdsEnd,
                            &gene->cdsStart, &gene->cdsEnd,FALSE);
pslToExons(psl, gene, insertMergeSize);
return gene;
}

char* genePredGetCreateSql(char* table, unsigned options)
/* Get SQL required to create a genePred table.  No options defined yet,
 * specify 0. */
{
char sqlCmd[1024];

safef(sqlCmd, sizeof(sqlCmd), createSql, table);

return cloneString(sqlCmd);
}
struct genePred *getOverlappingGene(struct genePred **list, char *table, char *chrom, int cStart, int cEnd, int *retOverlap)
{
/* read all genes from a table find the gene with the biggest overlap. 
   Cache the list of genes to so we only read it once */

char query[256];
struct genePred *gene;
struct sqlConnection *conn;
struct sqlResult *sr;
boolean hasBin = 0;
char **row;
struct genePred *el = NULL, *bestMatch = NULL, *gp = NULL;
int overlap = 0 , bestOverlap = 0, i;
struct psl *psl;


if (*list == NULL)
    {
    printf("Loading Predictions from %s\n",table);
    AllocVar(*list);
    conn = hAllocConn();
    AllocVar(gene);
    sprintf(query, "select * from %s \n",table);
    sr = sqlGetResult(conn, query);
    while ((row = sqlNextRow(sr)) != NULL){
        if (!sameString(table,"all_mrna"))
            {
            el = genePredLoad(row);
            }
        else
            {
            psl = pslLoad(row);
            el = genePredFromPsl(psl, psl->tStart, psl->tEnd, 10);
            }
        slAddHead(list, el);
        }
    slReverse(list);
    sqlFreeResult(&sr);
    hFreeConn(&conn);
    }
for (el = *list; el != NULL; el = el->next)
    {
    if (chrom != NULL && el->chrom != NULL)
        {
        overlap = 0;
        if ( sameString(chrom, el->chrom))
            {
            for (i = 0 ; i<(el->exonCount); i++)
                {
                overlap += positiveRangeIntersection(cStart,cEnd, el->exonStarts[i], el->exonEnds[i]) ;
                }
            if (overlap > bestOverlap)
                {
                bestMatch = el;
                bestOverlap = overlap;
                *retOverlap = bestOverlap;
                }
            }
        }
    }
if (bestMatch != NULL)
    {
    /* Allocate genePred and fill in values. */
    AllocVar(gp);
    gp->name = cloneString(bestMatch->name);
    gp->chrom = cloneString(bestMatch->chrom);
    gp->strand[1] = bestMatch->strand[1];
    gp->strand[0] = bestMatch->strand[0];
    gp->txStart = bestMatch->txStart;
    gp->txEnd = bestMatch->txEnd;
    gp->cdsStart = bestMatch->cdsStart;
    gp->cdsEnd = bestMatch->cdsEnd;
    gp->exonCount = bestMatch->exonCount;
    AllocArray(gp->exonStarts, bestMatch->exonCount);
    AllocArray(gp->exonEnds, bestMatch->exonCount);
    for (i=0; i<bestMatch->exonCount; ++i)
        {
        gp->exonStarts[i] = bestMatch->exonStarts[i] ;
        gp->exonEnds[i] = bestMatch->exonEnds[i] ;
        }
    }
return gp;
}
int genePredBases(struct genePred *gp)
/* count coding and utr bases in a gene prediction */
{
int count = 0, i;

if (gp == NULL) return 0;

for (i=0; i<gp->exonCount; i++)
    {
    count += gp->exonEnds[i] - gp->exonStarts[i] ;
    }
return count;
}

int genePredCodingBases(struct genePred *gp)
/* Count up the number of coding bases in gene prediction. */
{
int i, exonCount = gp->exonCount;
int cdsStart = gp->cdsStart, cdsEnd = gp->cdsEnd;
int baseCount = 0;
for (i=0; i<exonCount; ++i)
    {
    baseCount += positiveRangeIntersection(cdsStart,cdsEnd,
    	gp->exonStarts[i], gp->exonEnds[i]);
    }
return baseCount;
}

