/* genomeVar.c was originally generated by the autoSql program, which also 
 * generated genomeVar.h and genomeVar.sql.  This module links the database and
 * the RAM representation of objects. */

#include "common.h"
#include "linefile.h"
#include "dystring.h"
#include "jksql.h"
#include "genomeVar.h"

static char const rcsid[] = "$Id: genomeVar.c,v 1.1 2006/06/22 22:06:42 giardine Exp $";

void genomeVarStaticLoad(char **row, struct genomeVar *ret)
/* Load a row from genomeVar table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->bin = sqlUnsigned(row[0]);
ret->chrom = row[1];
ret->chromStart = sqlUnsigned(row[2]);
ret->chromEnd = sqlUnsigned(row[3]);
ret->name = row[4];
ret->mutId = row[5];
ret->srcId = sqlUnsigned(row[6]);
ret->baseChangeType = row[7];
ret->location = row[8];
ret->coordinateAccuracy = sqlUnsigned(row[9]);
}

struct genomeVar *genomeVarLoad(char **row)
/* Load a genomeVar from row fetched with select * from genomeVar
 * from database.  Dispose of this with genomeVarFree(). */
{
struct genomeVar *ret;

AllocVar(ret);
ret->bin = sqlUnsigned(row[0]);
ret->chrom = cloneString(row[1]);
ret->chromStart = sqlUnsigned(row[2]);
ret->chromEnd = sqlUnsigned(row[3]);
ret->name = cloneString(row[4]);
ret->mutId = cloneString(row[5]);
ret->srcId = sqlUnsigned(row[6]);
ret->baseChangeType = cloneString(row[7]);
ret->location = cloneString(row[8]);
ret->coordinateAccuracy = sqlUnsigned(row[9]);
return ret;
}

struct genomeVar *genomeVarLoadAll(char *fileName) 
/* Load all genomeVar from a whitespace-separated file.
 * Dispose of this with genomeVarFreeList(). */
{
struct genomeVar *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[10];

while (lineFileRow(lf, row))
    {
    el = genomeVarLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct genomeVar *genomeVarLoadAllByChar(char *fileName, char chopper) 
/* Load all genomeVar from a chopper separated file.
 * Dispose of this with genomeVarFreeList(). */
{
struct genomeVar *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[10];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = genomeVarLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct genomeVar *genomeVarLoadByQuery(struct sqlConnection *conn, char *query)
/* Load all genomeVar from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with genomeVarFreeList(). */
{
struct genomeVar *list = NULL, *el;
struct sqlResult *sr;
char **row;

sr = sqlGetResult(conn, query);
while ((row = sqlNextRow(sr)) != NULL)
    {
    el = genomeVarLoad(row);
    slAddHead(&list, el);
    }
slReverse(&list);
sqlFreeResult(&sr);
return list;
}

void genomeVarSaveToDb(struct sqlConnection *conn, struct genomeVar *el, char *tableName, int updateSize)
/* Save genomeVar as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use genomeVarSaveToDbEscaped() */
{
struct dyString *update = newDyString(updateSize);
dyStringPrintf(update, "insert into %s values ( %u,'%s',%u,%u,'%s','%s',%u,'%s','%s',%u)", 
	tableName,  el->bin,  el->chrom,  el->chromStart,  el->chromEnd,  el->name,  el->mutId,  el->srcId,  el->baseChangeType,  el->location,  el->coordinateAccuracy);
sqlUpdate(conn, update->string);
freeDyString(&update);
}

void genomeVarSaveToDbEscaped(struct sqlConnection *conn, struct genomeVar *el, char *tableName, int updateSize)
/* Save genomeVar as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than genomeVarSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 
{
struct dyString *update = newDyString(updateSize);
char  *chrom, *name, *mutId, *baseChangeType, *location;
chrom = sqlEscapeString(el->chrom);
name = sqlEscapeString(el->name);
mutId = sqlEscapeString(el->mutId);
baseChangeType = sqlEscapeString(el->baseChangeType);
location = sqlEscapeString(el->location);

dyStringPrintf(update, "insert into %s values ( %u,'%s',%u,%u,'%s','%s',%u,'%s','%s',%u)", 
	tableName, el->bin ,  chrom, el->chromStart , el->chromEnd ,  name,  mutId, el->srcId ,  baseChangeType,  location, el->coordinateAccuracy );
sqlUpdate(conn, update->string);
freeDyString(&update);
freez(&chrom);
freez(&name);
freez(&mutId);
freez(&baseChangeType);
freez(&location);
}

struct genomeVar *genomeVarCommaIn(char **pS, struct genomeVar *ret)
/* Create a genomeVar out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new genomeVar */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->bin = sqlUnsignedComma(&s);
ret->chrom = sqlStringComma(&s);
ret->chromStart = sqlUnsignedComma(&s);
ret->chromEnd = sqlUnsignedComma(&s);
ret->name = sqlStringComma(&s);
ret->mutId = sqlStringComma(&s);
ret->srcId = sqlUnsignedComma(&s);
ret->baseChangeType = sqlStringComma(&s);
ret->location = sqlStringComma(&s);
ret->coordinateAccuracy = sqlUnsignedComma(&s);
*pS = s;
return ret;
}

void genomeVarFree(struct genomeVar **pEl)
/* Free a single dynamically allocated genomeVar such as created
 * with genomeVarLoad(). */
{
struct genomeVar *el;

if ((el = *pEl) == NULL) return;
freeMem(el->chrom);
freeMem(el->name);
freeMem(el->mutId);
freeMem(el->baseChangeType);
freeMem(el->location);
freez(pEl);
}

void genomeVarFreeList(struct genomeVar **pList)
/* Free a list of dynamically allocated genomeVar's */
{
struct genomeVar *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    genomeVarFree(&el);
    }
*pList = NULL;
}

void genomeVarOutput(struct genomeVar *el, FILE *f, char sep, char lastSep) 
/* Print out genomeVar.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->bin);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->chrom);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%u", el->chromStart);
fputc(sep,f);
fprintf(f, "%u", el->chromEnd);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->name);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->mutId);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%u", el->srcId);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->baseChangeType);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->location);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%u", el->coordinateAccuracy);
fputc(lastSep,f);
}

void genomeVarSrcStaticLoad(char **row, struct genomeVarSrc *ret)
/* Load a row from genomeVarSrc table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->srcId = sqlUnsigned(row[0]);
ret->src = row[1];
ret->lsdb = row[2];
ret->lsdbAbrev = row[3];
}

struct genomeVarSrc *genomeVarSrcLoad(char **row)
/* Load a genomeVarSrc from row fetched with select * from genomeVarSrc
 * from database.  Dispose of this with genomeVarSrcFree(). */
{
struct genomeVarSrc *ret;

AllocVar(ret);
ret->srcId = sqlUnsigned(row[0]);
ret->src = cloneString(row[1]);
ret->lsdb = cloneString(row[2]);
ret->lsdbAbrev = cloneString(row[3]);
return ret;
}

struct genomeVarSrc *genomeVarSrcLoadAll(char *fileName) 
/* Load all genomeVarSrc from a whitespace-separated file.
 * Dispose of this with genomeVarSrcFreeList(). */
{
struct genomeVarSrc *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileRow(lf, row))
    {
    el = genomeVarSrcLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct genomeVarSrc *genomeVarSrcLoadAllByChar(char *fileName, char chopper) 
/* Load all genomeVarSrc from a chopper separated file.
 * Dispose of this with genomeVarSrcFreeList(). */
{
struct genomeVarSrc *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = genomeVarSrcLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct genomeVarSrc *genomeVarSrcLoadByQuery(struct sqlConnection *conn, char *query)
/* Load all genomeVarSrc from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with genomeVarSrcFreeList(). */
{
struct genomeVarSrc *list = NULL, *el;
struct sqlResult *sr;
char **row;

sr = sqlGetResult(conn, query);
while ((row = sqlNextRow(sr)) != NULL)
    {
    el = genomeVarSrcLoad(row);
    slAddHead(&list, el);
    }
slReverse(&list);
sqlFreeResult(&sr);
return list;
}

void genomeVarSrcSaveToDb(struct sqlConnection *conn, struct genomeVarSrc *el, char *tableName, int updateSize)
/* Save genomeVarSrc as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use genomeVarSrcSaveToDbEscaped() */
{
struct dyString *update = newDyString(updateSize);
dyStringPrintf(update, "insert into %s values ( %u,'%s','%s','%s')", 
	tableName,  el->srcId,  el->src,  el->lsdb,  el->lsdbAbrev);
sqlUpdate(conn, update->string);
freeDyString(&update);
}

void genomeVarSrcSaveToDbEscaped(struct sqlConnection *conn, struct genomeVarSrc *el, char *tableName, int updateSize)
/* Save genomeVarSrc as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than genomeVarSrcSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 
{
struct dyString *update = newDyString(updateSize);
char  *src, *lsdb, *lsdbAbrev;
src = sqlEscapeString(el->src);
lsdb = sqlEscapeString(el->lsdb);
lsdbAbrev = sqlEscapeString(el->lsdbAbrev);

dyStringPrintf(update, "insert into %s values ( %u,'%s','%s','%s')", 
	tableName, el->srcId ,  src,  lsdb,  lsdbAbrev);
sqlUpdate(conn, update->string);
freeDyString(&update);
freez(&src);
freez(&lsdb);
freez(&lsdbAbrev);
}

struct genomeVarSrc *genomeVarSrcCommaIn(char **pS, struct genomeVarSrc *ret)
/* Create a genomeVarSrc out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new genomeVarSrc */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->srcId = sqlUnsignedComma(&s);
ret->src = sqlStringComma(&s);
ret->lsdb = sqlStringComma(&s);
ret->lsdbAbrev = sqlStringComma(&s);
*pS = s;
return ret;
}

void genomeVarSrcFree(struct genomeVarSrc **pEl)
/* Free a single dynamically allocated genomeVarSrc such as created
 * with genomeVarSrcLoad(). */
{
struct genomeVarSrc *el;

if ((el = *pEl) == NULL) return;
freeMem(el->src);
freeMem(el->lsdb);
freeMem(el->lsdbAbrev);
freez(pEl);
}

void genomeVarSrcFreeList(struct genomeVarSrc **pList)
/* Free a list of dynamically allocated genomeVarSrc's */
{
struct genomeVarSrc *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    genomeVarSrcFree(&el);
    }
*pList = NULL;
}

void genomeVarSrcOutput(struct genomeVarSrc *el, FILE *f, char sep, char lastSep) 
/* Print out genomeVarSrc.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->srcId);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->src);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->lsdb);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->lsdbAbrev);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void genomeVarAliasStaticLoad(char **row, struct genomeVarAlias *ret)
/* Load a row from genomeVarAlias table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->mutId = row[0];
ret->name = row[1];
ret->nameType = row[2];
}

struct genomeVarAlias *genomeVarAliasLoad(char **row)
/* Load a genomeVarAlias from row fetched with select * from genomeVarAlias
 * from database.  Dispose of this with genomeVarAliasFree(). */
{
struct genomeVarAlias *ret;

AllocVar(ret);
ret->mutId = cloneString(row[0]);
ret->name = cloneString(row[1]);
ret->nameType = cloneString(row[2]);
return ret;
}

struct genomeVarAlias *genomeVarAliasLoadAll(char *fileName) 
/* Load all genomeVarAlias from a whitespace-separated file.
 * Dispose of this with genomeVarAliasFreeList(). */
{
struct genomeVarAlias *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[3];

while (lineFileRow(lf, row))
    {
    el = genomeVarAliasLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct genomeVarAlias *genomeVarAliasLoadAllByChar(char *fileName, char chopper) 
/* Load all genomeVarAlias from a chopper separated file.
 * Dispose of this with genomeVarAliasFreeList(). */
{
struct genomeVarAlias *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[3];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = genomeVarAliasLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct genomeVarAlias *genomeVarAliasLoadByQuery(struct sqlConnection *conn, char *query)
/* Load all genomeVarAlias from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with genomeVarAliasFreeList(). */
{
struct genomeVarAlias *list = NULL, *el;
struct sqlResult *sr;
char **row;

sr = sqlGetResult(conn, query);
while ((row = sqlNextRow(sr)) != NULL)
    {
    el = genomeVarAliasLoad(row);
    slAddHead(&list, el);
    }
slReverse(&list);
sqlFreeResult(&sr);
return list;
}

void genomeVarAliasSaveToDb(struct sqlConnection *conn, struct genomeVarAlias *el, char *tableName, int updateSize)
/* Save genomeVarAlias as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use genomeVarAliasSaveToDbEscaped() */
{
struct dyString *update = newDyString(updateSize);
dyStringPrintf(update, "insert into %s values ( '%s',%s,'%s')", 
	tableName,  el->mutId,  el->name,  el->nameType);
sqlUpdate(conn, update->string);
freeDyString(&update);
}

void genomeVarAliasSaveToDbEscaped(struct sqlConnection *conn, struct genomeVarAlias *el, char *tableName, int updateSize)
/* Save genomeVarAlias as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than genomeVarAliasSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 
{
struct dyString *update = newDyString(updateSize);
char  *mutId, *name, *nameType;
mutId = sqlEscapeString(el->mutId);
name = sqlEscapeString(el->name);
nameType = sqlEscapeString(el->nameType);

dyStringPrintf(update, "insert into %s values ( '%s','%s','%s')", 
	tableName,  mutId,  name,  nameType);
sqlUpdate(conn, update->string);
freeDyString(&update);
freez(&mutId);
freez(&name);
freez(&nameType);
}

struct genomeVarAlias *genomeVarAliasCommaIn(char **pS, struct genomeVarAlias *ret)
/* Create a genomeVarAlias out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new genomeVarAlias */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->mutId = sqlStringComma(&s);
ret->name = sqlStringComma(&s);
ret->nameType = sqlStringComma(&s);
*pS = s;
return ret;
}

void genomeVarAliasFree(struct genomeVarAlias **pEl)
/* Free a single dynamically allocated genomeVarAlias such as created
 * with genomeVarAliasLoad(). */
{
struct genomeVarAlias *el;

if ((el = *pEl) == NULL) return;
freeMem(el->mutId);
freeMem(el->name);
freeMem(el->nameType);
freez(pEl);
}

void genomeVarAliasFreeList(struct genomeVarAlias **pList)
/* Free a list of dynamically allocated genomeVarAlias's */
{
struct genomeVarAlias *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    genomeVarAliasFree(&el);
    }
*pList = NULL;
}

void genomeVarAliasOutput(struct genomeVarAlias *el, FILE *f, char sep, char lastSep) 
/* Print out genomeVarAlias.  Separate fields with sep. Follow last field with lastSep. */
{
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->mutId);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->name);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->nameType);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void genomeVarAttrStaticLoad(char **row, struct genomeVarAttr *ret)
/* Load a row from genomeVarAttr table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->mutId = row[0];
ret->attrKey = row[1];
ret->linkId = row[2];
ret->attrVal = row[3];
}

struct genomeVarAttr *genomeVarAttrLoad(char **row)
/* Load a genomeVarAttr from row fetched with select * from genomeVarAttr
 * from database.  Dispose of this with genomeVarAttrFree(). */
{
struct genomeVarAttr *ret;

AllocVar(ret);
ret->mutId = cloneString(row[0]);
ret->attrKey = cloneString(row[1]);
ret->linkId = cloneString(row[2]);
ret->attrVal = cloneString(row[3]);
return ret;
}

struct genomeVarAttr *genomeVarAttrLoadAll(char *fileName) 
/* Load all genomeVarAttr from a whitespace-separated file.
 * Dispose of this with genomeVarAttrFreeList(). */
{
struct genomeVarAttr *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileRow(lf, row))
    {
    el = genomeVarAttrLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct genomeVarAttr *genomeVarAttrLoadAllByChar(char *fileName, char chopper) 
/* Load all genomeVarAttr from a chopper separated file.
 * Dispose of this with genomeVarAttrFreeList(). */
{
struct genomeVarAttr *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = genomeVarAttrLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct genomeVarAttr *genomeVarAttrLoadByQuery(struct sqlConnection *conn, char *query)
/* Load all genomeVarAttr from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with genomeVarAttrFreeList(). */
{
struct genomeVarAttr *list = NULL, *el;
struct sqlResult *sr;
char **row;

sr = sqlGetResult(conn, query);
while ((row = sqlNextRow(sr)) != NULL)
    {
    el = genomeVarAttrLoad(row);
    slAddHead(&list, el);
    }
slReverse(&list);
sqlFreeResult(&sr);
return list;
}

void genomeVarAttrSaveToDb(struct sqlConnection *conn, struct genomeVarAttr *el, char *tableName, int updateSize)
/* Save genomeVarAttr as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use genomeVarAttrSaveToDbEscaped() */
{
struct dyString *update = newDyString(updateSize);
dyStringPrintf(update, "insert into %s values ( '%s','%s','%s','%s')", 
	tableName,  el->mutId,  el->attrKey,  el->linkId,  el->attrVal);
sqlUpdate(conn, update->string);
freeDyString(&update);
}

void genomeVarAttrSaveToDbEscaped(struct sqlConnection *conn, struct genomeVarAttr *el, char *tableName, int updateSize)
/* Save genomeVarAttr as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than genomeVarAttrSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 
{
struct dyString *update = newDyString(updateSize);
char  *mutId, *attrKey, *linkId, *attrVal;
mutId = sqlEscapeString(el->mutId);
attrKey = sqlEscapeString(el->attrKey);
linkId = sqlEscapeString(el->linkId);
attrVal = sqlEscapeString(el->attrVal);

dyStringPrintf(update, "insert into %s values ( '%s','%s','%s','%s')", 
	tableName,  mutId,  attrKey,  linkId,  attrVal);
sqlUpdate(conn, update->string);
freeDyString(&update);
freez(&mutId);
freez(&attrKey);
freez(&linkId);
freez(&attrVal);
}

struct genomeVarAttr *genomeVarAttrCommaIn(char **pS, struct genomeVarAttr *ret)
/* Create a genomeVarAttr out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new genomeVarAttr */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->mutId = sqlStringComma(&s);
ret->attrKey = sqlStringComma(&s);
ret->linkId = sqlStringComma(&s);
ret->attrVal = sqlStringComma(&s);
*pS = s;
return ret;
}

void genomeVarAttrFree(struct genomeVarAttr **pEl)
/* Free a single dynamically allocated genomeVarAttr such as created
 * with genomeVarAttrLoad(). */
{
struct genomeVarAttr *el;

if ((el = *pEl) == NULL) return;
freeMem(el->mutId);
freeMem(el->attrKey);
freeMem(el->linkId);
freeMem(el->attrVal);
freez(pEl);
}

void genomeVarAttrFreeList(struct genomeVarAttr **pList)
/* Free a list of dynamically allocated genomeVarAttr's */
{
struct genomeVarAttr *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    genomeVarAttrFree(&el);
    }
*pList = NULL;
}

void genomeVarAttrOutput(struct genomeVarAttr *el, FILE *f, char sep, char lastSep) 
/* Print out genomeVarAttr.  Separate fields with sep. Follow last field with lastSep. */
{
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->mutId);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->attrKey);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->linkId);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->attrVal);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void genomeVarAttrLinkStaticLoad(char **row, struct genomeVarAttrLink *ret)
/* Load a row from genomeVarAttrLink table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->linkId = row[0];
ret->raKey = row[1];
ret->acc = row[2];
ret->displayVal = row[3];
}

struct genomeVarAttrLink *genomeVarAttrLinkLoad(char **row)
/* Load a genomeVarAttrLink from row fetched with select * from genomeVarAttrLink
 * from database.  Dispose of this with genomeVarAttrLinkFree(). */
{
struct genomeVarAttrLink *ret;

AllocVar(ret);
ret->linkId = cloneString(row[0]);
ret->raKey = cloneString(row[1]);
ret->acc = cloneString(row[2]);
ret->displayVal = cloneString(row[3]);
return ret;
}

struct genomeVarAttrLink *genomeVarAttrLinkLoadAll(char *fileName) 
/* Load all genomeVarAttrLink from a whitespace-separated file.
 * Dispose of this with genomeVarAttrLinkFreeList(). */
{
struct genomeVarAttrLink *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileRow(lf, row))
    {
    el = genomeVarAttrLinkLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct genomeVarAttrLink *genomeVarAttrLinkLoadAllByChar(char *fileName, char chopper) 
/* Load all genomeVarAttrLink from a chopper separated file.
 * Dispose of this with genomeVarAttrLinkFreeList(). */
{
struct genomeVarAttrLink *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = genomeVarAttrLinkLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct genomeVarAttrLink *genomeVarAttrLinkLoadByQuery(struct sqlConnection *conn, char *query)
/* Load all genomeVarAttrLink from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with genomeVarAttrLinkFreeList(). */
{
struct genomeVarAttrLink *list = NULL, *el;
struct sqlResult *sr;
char **row;

sr = sqlGetResult(conn, query);
while ((row = sqlNextRow(sr)) != NULL)
    {
    el = genomeVarAttrLinkLoad(row);
    slAddHead(&list, el);
    }
slReverse(&list);
sqlFreeResult(&sr);
return list;
}

void genomeVarAttrLinkSaveToDb(struct sqlConnection *conn, struct genomeVarAttrLink *el, char *tableName, int updateSize)
/* Save genomeVarAttrLink as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use genomeVarAttrLinkSaveToDbEscaped() */
{
struct dyString *update = newDyString(updateSize);
dyStringPrintf(update, "insert into %s values ( '%s','%s','%s','%s')", 
	tableName,  el->linkId,  el->raKey,  el->acc,  el->displayVal);
sqlUpdate(conn, update->string);
freeDyString(&update);
}

void genomeVarAttrLinkSaveToDbEscaped(struct sqlConnection *conn, struct genomeVarAttrLink *el, char *tableName, int updateSize)
/* Save genomeVarAttrLink as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than genomeVarAttrLinkSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 
{
struct dyString *update = newDyString(updateSize);
char  *linkId, *raKey, *acc, *displayVal;
linkId = sqlEscapeString(el->linkId);
raKey = sqlEscapeString(el->raKey);
acc = sqlEscapeString(el->acc);
displayVal = sqlEscapeString(el->displayVal);

dyStringPrintf(update, "insert into %s values ( '%s','%s','%s','%s')", 
	tableName,  linkId,  raKey,  acc,  displayVal);
sqlUpdate(conn, update->string);
freeDyString(&update);
freez(&linkId);
freez(&raKey);
freez(&acc);
freez(&displayVal);
}

struct genomeVarAttrLink *genomeVarAttrLinkCommaIn(char **pS, struct genomeVarAttrLink *ret)
/* Create a genomeVarAttrLink out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new genomeVarAttrLink */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->linkId = sqlStringComma(&s);
ret->raKey = sqlStringComma(&s);
ret->acc = sqlStringComma(&s);
ret->displayVal = sqlStringComma(&s);
*pS = s;
return ret;
}

void genomeVarAttrLinkFree(struct genomeVarAttrLink **pEl)
/* Free a single dynamically allocated genomeVarAttrLink such as created
 * with genomeVarAttrLinkLoad(). */
{
struct genomeVarAttrLink *el;

if ((el = *pEl) == NULL) return;
freeMem(el->linkId);
freeMem(el->raKey);
freeMem(el->acc);
freeMem(el->displayVal);
freez(pEl);
}

void genomeVarAttrLinkFreeList(struct genomeVarAttrLink **pList)
/* Free a list of dynamically allocated genomeVarAttrLink's */
{
struct genomeVarAttrLink *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    genomeVarAttrLinkFree(&el);
    }
*pList = NULL;
}

void genomeVarAttrLinkOutput(struct genomeVarAttrLink *el, FILE *f, char sep, char lastSep) 
/* Print out genomeVarAttrLink.  Separate fields with sep. Follow last field with lastSep. */
{
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->linkId);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->raKey);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->acc);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->displayVal);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

/* -------------------------------- End autoSql Generated Code -------------------------------- */

