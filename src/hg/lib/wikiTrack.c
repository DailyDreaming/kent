/* wikiTrack.c was originally generated by the autoSql program, which also 
 * generated wikiTrack.h and wikiTrack.sql.  This module links the database and
 * the RAM representation of objects. */

#include "common.h"
#include "linefile.h"
#include "dystring.h"
#include "jksql.h"
#include "wikiTrack.h"

static char const rcsid[] = "$Id: wikiTrack.c,v 1.4 2007/06/21 21:04:00 hiram Exp $";

void wikiTrackStaticLoad(char **row, struct wikiTrack *ret)
/* Load a row from wikiTrack table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->bin = sqlUnsigned(row[0]);
ret->chrom = row[1];
ret->chromStart = sqlUnsigned(row[2]);
ret->chromEnd = sqlUnsigned(row[3]);
ret->name = row[4];
ret->score = sqlUnsigned(row[5]);
safecpy(ret->strand, sizeof(ret->strand), row[6]);
ret->db = row[7];
ret->owner = row[8];
ret->color = row[9];
ret->class = row[10];
ret->creationDate = row[11];
ret->lastModifiedDate = row[12];
ret->descriptionKey = row[13];
ret->id = sqlUnsigned(row[14]);
ret->alignID = row[15];
}

struct wikiTrack *wikiTrackLoad(char **row)
/* Load a wikiTrack from row fetched with select * from wikiTrack
 * from database.  Dispose of this with wikiTrackFree(). */
{
struct wikiTrack *ret;

AllocVar(ret);
ret->bin = sqlUnsigned(row[0]);
ret->chrom = cloneString(row[1]);
ret->chromStart = sqlUnsigned(row[2]);
ret->chromEnd = sqlUnsigned(row[3]);
ret->name = cloneString(row[4]);
ret->score = sqlUnsigned(row[5]);
safecpy(ret->strand, sizeof(ret->strand), row[6]);
ret->db = cloneString(row[7]);
ret->owner = cloneString(row[8]);
ret->color = cloneString(row[9]);
ret->class = cloneString(row[10]);
ret->creationDate = cloneString(row[11]);
ret->lastModifiedDate = cloneString(row[12]);
ret->descriptionKey = cloneString(row[13]);
ret->id = sqlUnsigned(row[14]);
ret->alignID = cloneString(row[15]);
return ret;
}

struct wikiTrack *wikiTrackLoadAll(char *fileName) 
/* Load all wikiTrack from a whitespace-separated file.
 * Dispose of this with wikiTrackFreeList(). */
{
struct wikiTrack *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[16];

while (lineFileRow(lf, row))
    {
    el = wikiTrackLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct wikiTrack *wikiTrackLoadAllByChar(char *fileName, char chopper) 
/* Load all wikiTrack from a chopper separated file.
 * Dispose of this with wikiTrackFreeList(). */
{
struct wikiTrack *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[16];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = wikiTrackLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct wikiTrack *wikiTrackLoadByQuery(struct sqlConnection *conn, char *query)
/* Load all wikiTrack from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with wikiTrackFreeList(). */
{
struct wikiTrack *list = NULL, *el;
struct sqlResult *sr;
char **row;

sr = sqlGetResult(conn, query);
while ((row = sqlNextRow(sr)) != NULL)
    {
    el = wikiTrackLoad(row);
    slAddHead(&list, el);
    }
slReverse(&list);
sqlFreeResult(&sr);
return list;
}

void wikiTrackSaveToDb(struct sqlConnection *conn, struct wikiTrack *el, char *tableName, int updateSize)
/* Save wikiTrack as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use wikiTrackSaveToDbEscaped() */
{
struct dyString *update = newDyString(updateSize);
dyStringPrintf(update, "insert into %s values ( %u,'%s',%u,%u,'%s',%u,'%s','%s','%s','%s','%s','%s','%s','%s',%u,'%s')", 
	tableName,  el->bin,  el->chrom,  el->chromStart,  el->chromEnd,  el->name,  el->score,  el->strand,  el->db,  el->owner,  el->color,  el->class,  el->creationDate,  el->lastModifiedDate,  el->descriptionKey,  el->id,  el->alignID);
sqlUpdate(conn, update->string);
freeDyString(&update);
}

void wikiTrackSaveToDbEscaped(struct sqlConnection *conn, struct wikiTrack *el, char *tableName, int updateSize)
/* Save wikiTrack as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than wikiTrackSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 
{
struct dyString *update = newDyString(updateSize);
char  *chrom, *name, *strand, *db, *owner, *color, *class, *creationDate, *lastModifiedDate, *descriptionKey, *alignID;
chrom = sqlEscapeString(el->chrom);
name = sqlEscapeString(el->name);
strand = sqlEscapeString(el->strand);
db = sqlEscapeString(el->db);
owner = sqlEscapeString(el->owner);
color = sqlEscapeString(el->color);
class = sqlEscapeString(el->class);
creationDate = sqlEscapeString(el->creationDate);
lastModifiedDate = sqlEscapeString(el->lastModifiedDate);
descriptionKey = sqlEscapeString(el->descriptionKey);
alignID = sqlEscapeString(el->alignID);

dyStringPrintf(update, "insert into %s values ( %u,'%s',%u,%u,'%s',%u,'%s','%s','%s','%s','%s','%s','%s','%s',%u,'%s')", 
	tableName, el->bin ,  chrom, el->chromStart , el->chromEnd ,  name, el->score ,  strand,  db,  owner,  color,  class,  creationDate,  lastModifiedDate,  descriptionKey, el->id ,  alignID);
sqlUpdate(conn, update->string);
freeDyString(&update);
freez(&chrom);
freez(&name);
freez(&strand);
freez(&db);
freez(&owner);
freez(&color);
freez(&class);
freez(&creationDate);
freez(&lastModifiedDate);
freez(&descriptionKey);
freez(&alignID);
}

struct wikiTrack *wikiTrackCommaIn(char **pS, struct wikiTrack *ret)
/* Create a wikiTrack out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new wikiTrack */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->bin = sqlUnsignedComma(&s);
ret->chrom = sqlStringComma(&s);
ret->chromStart = sqlUnsignedComma(&s);
ret->chromEnd = sqlUnsignedComma(&s);
ret->name = sqlStringComma(&s);
ret->score = sqlUnsignedComma(&s);
sqlFixedStringComma(&s, ret->strand, sizeof(ret->strand));
ret->db = sqlStringComma(&s);
ret->owner = sqlStringComma(&s);
ret->color = sqlStringComma(&s);
ret->class = sqlStringComma(&s);
ret->creationDate = sqlStringComma(&s);
ret->lastModifiedDate = sqlStringComma(&s);
ret->descriptionKey = sqlStringComma(&s);
ret->id = sqlUnsignedComma(&s);
ret->alignID = sqlStringComma(&s);
*pS = s;
return ret;
}

void wikiTrackFree(struct wikiTrack **pEl)
/* Free a single dynamically allocated wikiTrack such as created
 * with wikiTrackLoad(). */
{
struct wikiTrack *el;

if ((el = *pEl) == NULL) return;
freeMem(el->chrom);
freeMem(el->name);
freeMem(el->db);
freeMem(el->owner);
freeMem(el->color);
freeMem(el->class);
freeMem(el->creationDate);
freeMem(el->lastModifiedDate);
freeMem(el->descriptionKey);
freeMem(el->alignID);
freez(pEl);
}

void wikiTrackFreeList(struct wikiTrack **pList)
/* Free a list of dynamically allocated wikiTrack's */
{
struct wikiTrack *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    wikiTrackFree(&el);
    }
*pList = NULL;
}

void wikiTrackOutput(struct wikiTrack *el, FILE *f, char sep, char lastSep) 
/* Print out wikiTrack.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->bin);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->chrom);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%u", el->chromStart);
fputc(sep,f);
fprintf(f, "%u", el->chromEnd);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->name);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%u", el->score);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->strand);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->db);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->owner);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->color);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->class);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->creationDate);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->lastModifiedDate);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->descriptionKey);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%u", el->id);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->alignID);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

/* -------------------------------- End autoSql Generated Code -------------------------------- */

#include "hgConfig.h"
#include "wikiLink.h"
#include "cheapcgi.h"
#include "hdb.h"
#include "hui.h"
#include "net.h"
#include "cart.h"
#include "hPrint.h"
#include "grp.h"
#include "obscure.h"
#include "hCommon.h"
#include "web.h"
#include "hgColors.h"

#ifdef NOT
static void savePosInTextBox(char *chrom, int start, int end)
/* Save basic position/database info in text box and hidden var. 
   Positions becomes chrom:start-end*/
{
char position[128];
char *newPos;
snprintf(position, 128, "%s:%d-%d", chrom, start, end);
newPos = addCommasToPos(position);
cgiMakeTextVar("getDnaPos", newPos, strlen(newPos) + 2);
cgiContinueHiddenVar("db");
}
#endif

boolean wikiTrackEnabled(char **wikiUserName)
/*determine if wikiTrack can be used, and is this user logged into the wiki ?*/
{
if (wikiUserName)
    *wikiUserName = NULL;  /* assume not logged in until proven otherwise */

/* must have wiki login system enabled, and the new cfg options exist too. */
if (wikiLinkEnabled() &&
	(cfgOption(CFG_WIKI_SESSION_COOKIE) != NULL) &&
	(cfgOption(CFG_WIKI_BROWSER) != NULL) &&
	(cfgOption(CFG_WIKI_URL) != NULL))
    {
    char *wikiUser = wikiLinkUserName();
    if ( (wikiUser) &&
	(findCookieData(cfgOption(CFG_WIKI_SESSION_COOKIE)) != NULL) )
	{
	if (wikiUserName)
	    *wikiUserName = wikiUser;  /* returning name indicates logged in */
	}
    return TRUE; /* system is enabled */
    }
return FALSE;  /* system is not enabled */
}

/* from hg/lib/wikiTrack.sql */
static char *createString =
"CREATE TABLE %s (\n"
    "bin smallint unsigned not null,\n"
    "chrom varchar(255) not null,\n"
    "chromStart int unsigned not null,\n"
    "chromEnd int unsigned not null,\n"
    "name varchar(255) not null,\n"
    "score int unsigned not null,\n"
    "strand char(1) not null,\n"
    "db varchar(36) not null,\n"
    "owner varchar(255) not null,\n"
    "color varchar(255) not null,\n"
    "class varchar(255) not null,\n"
    "creationDate varchar(255) not null,\n"
    "lastModifiedDate varchar(255) not null,\n"
    "descriptionKey varchar(255) not null,\n"
    "id int unsigned not null auto_increment,\n"
    "alignID varchar(255) not null,\n"
    "PRIMARY KEY(id),\n"
    "INDEX chrom (db,bin,chrom),\n"
    "INDEX name (db,name),\n"
    "INDEX align (alignID)\n"
")\n";

char *wikiTrackGetCreateSql(char *tableName)
/* return sql create statement for wiki track with tableName */
{
struct dyString *createTable = dyStringNew(512);

dyStringPrintf(createTable, createString, tableName);

return (dyStringCannibalize(&createTable));
}

struct wikiTrack *findWikiItemId(char *wikiItemId)
/* given a wikiItemId return the row from the table */
{
struct wikiTrack *item;
char query[256];
struct sqlConnection *conn = hConnectCentral();

safef(query, ArraySize(query), "SELECT * FROM %s WHERE id='%s' limit 1",
	WIKI_TRACK_TABLE, wikiItemId);

item = wikiTrackLoadByQuery(conn, query);
if (NULL == item)
    errAbort("display wiki item: failed to load item '%s'", wikiItemId);
hDisconnectCentral(&conn);

return item;
}

struct wikiTrack *findWikiItemByAlignID(char *db, char *alignID)
/* given a db and UCSC known gene alignID, find the wiki item */
{
struct wikiTrack *item = NULL;

/* make sure neither of these arguments is NULL */
if (db && alignID)
    {
    char query[256];
    struct sqlConnection *conn = hConnectCentral();
    safef(query, ArraySize(query),
	"SELECT * FROM %s WHERE db='%s' AND alignID='%s' limit 1",
	    WIKI_TRACK_TABLE, db, alignID);

    item = wikiTrackLoadByQuery(conn, query);

    hDisconnectCentral(&conn);
    }

return item;
}

struct wikiTrack *findWikiItemByName(char *db, char *name)
/* given a db,name pair return the row from the table, can return NULL */
{
struct wikiTrack *item = NULL;

/* make sure neither of these arguments is NULL */
if (name && db)
    {
    char query[256];
    struct sqlConnection *conn = hConnectCentral();
    safef(query, ArraySize(query),
	"SELECT * FROM %s WHERE db='%s' AND name='%s' limit 1",
	    WIKI_TRACK_TABLE, db, name);

    item = wikiTrackLoadByQuery(conn, query);

    hDisconnectCentral(&conn);
    }

return item;
}

static char *stripEditURLs(char *rendered)
/* test for actual text, remove edit sections and any html comment strings */
{
char *stripped = cloneString(rendered);
char *found = NULL;
char *begin = "<div class=\"editsection\"";
char *end = "></a>";

/* XXXX is this response going to be language dependent ? */
if (stringIn(WIKI_NO_TEXT_RESPONSE,rendered))
	return NULL;

/* remove any edit sections */
while (NULL != (found = stringBetween(begin, end, stripped)) )
    {
    if (strlen(found) > 0)
	{
	struct dyString *rm = newDyString(1024);
	dyStringPrintf(rm, "%s%s%s", begin, found, end);
	stripString(stripped, rm->string);
	freeMem(found);
	freeDyString(&rm);
	}
    }

/* and remove comment strings from the wiki */
begin = "<!--";
end = "-->";
while (NULL != (found = stringBetween(begin, end, stripped)) )
    {
    if (strlen(found) > 0)
	{
	struct dyString *rm = newDyString(1024);
	dyStringPrintf(rm, "%s%s%s", begin, found, end);
	stripString(stripped, rm->string);
	freeMem(found);
	freeDyString(&rm);
	}
    }

return stripped;
}

void htmlCloneFormVarSet(struct htmlForm *parent,
	struct htmlForm *clone, char *name, char *val)
/* clone form variable from parent, with new value,
 * if *val is NULL, clone val from parent
 */
{
struct htmlFormVar *cloneVar;
struct htmlFormVar *var;
if (parent == NULL)
    errAbort("Null parent form passed to htmlCloneFormVarSet");
if (clone == NULL)
    errAbort("Null clone form passed to htmlCloneFormVarSet");
var = htmlFormVarGet(parent, name);
if (var == NULL)
    errAbort("Variable '%s' not found in parent in htmlCloneFormVarSet", name);

AllocVar(cloneVar);
cloneVar->name = cloneString(var->name);
cloneVar->tagName = cloneString(var->tagName);
cloneVar->type = cloneString(var->type);
if (NULL == val)
    cloneVar->curVal = cloneString(var->curVal);
else
    cloneVar->curVal = cloneString(val);
slAddHead(&clone->vars, cloneVar);

}

char *fetchWikiRawText(char *descriptionKey)
/* fetch page from wiki in raw form as it is in the edit form */
{
char wikiPageUrl[512];
safef(wikiPageUrl, sizeof(wikiPageUrl), "%s/index.php/%s?action=raw",
	cfgOptionDefault(CFG_WIKI_URL, NULL), descriptionKey);
struct lineFile *lf = netLineFileMayOpen(wikiPageUrl);

struct dyString *wikiPage = newDyString(1024);
if (lf)
    {
    char *line;
    int lineSize;
    while (lineFileNext(lf, &line, &lineSize))
	dyStringPrintf(wikiPage, "%s\n", line);
    lineFileClose(&lf);
    }

/* test for text, remove any edit sections and comment strings */
char *rawText = NULL;
if (wikiPage->string)
    {
    /* XXXX is this response going to be language dependent ? */
    if (stringIn(WIKI_NO_TEXT_RESPONSE,wikiPage->string))
	return NULL;
    rawText = dyStringCannibalize(&wikiPage);
    }
freeDyString(&wikiPage);

return rawText;
}

char *fetchWikiRenderedText(char *descriptionKey)
/* fetch page from wiki in rendered form, strip it of edit URLs,
 *	html comments, and test for actual proper return.
 *  returned string can be freed after use */
{
char wikiPageUrl[512];
safef(wikiPageUrl, sizeof(wikiPageUrl), "%s/index.php/%s?action=render",
	cfgOptionDefault(CFG_WIKI_URL, NULL), descriptionKey);
struct lineFile *lf = netLineFileMayOpen(wikiPageUrl);

struct dyString *wikiPage = newDyString(1024);
if (lf)
    {
    char *line;
    int lineSize;
    while (lineFileNext(lf, &line, &lineSize))
	dyStringPrintf(wikiPage, "%s\n", line);
    lineFileClose(&lf);
    }

/* test for text, remove any edit sections and comment strings */
char *strippedRender = NULL;
if (wikiPage->string)
    strippedRender = stripEditURLs(wikiPage->string);
freeDyString(&wikiPage);

return strippedRender;
}

void displayComments(struct wikiTrack *item)
/* display the rendered comments for this item */
{
char *url = cfgOptionDefault(CFG_WIKI_URL, NULL);
char *comments = fetchWikiRenderedText(item->descriptionKey);

hPrintf("<B>Description and comments from the "
  "<A HREF=\"%s/index.php/%s\" TARGET=_blank>wiki article:</A> %s:</B><BR />\n",
       url, item->descriptionKey, item->descriptionKey);

if (comments && (strlen(comments) > 2))
    {
    hPrintf("\n%s\n", comments);
    }
else
    hPrintf("\n(no comments for this item at the current time)<BR />\n");
}

void createPageHelp(char *pageFileName)
/* find the specified html help page and display it, or issue a missing
 *	page message so the site administrator can fix it.
 */
{
char helpName[PATH_LEN], *helpBuf;

hPrintf("<HR />\n");

safef(helpName, ArraySize(helpName), "%s%s/%s.html", hDocumentRoot(), HELP_DIR,
	pageFileName);
if (fileExists(helpName))
    readInGulp(helpName, &helpBuf, NULL);
else
    {
    char missingHelp[512];
    safef(missingHelp, ArraySize(missingHelp),
        "<P>(missing help text file in %s)</P>\n", helpName);
    helpBuf = cloneString(missingHelp);
    }
puts(helpBuf);
}

struct htmlPage *fetchEditPage(char *descriptionKey)
/* fetch edit page for descriptionKey page name in wiki */
{
struct htmlCookie *cookie;
char wikiPageUrl[512];

/* must pass the session cookie from the wiki in order to edit */
AllocVar(cookie);
cookie->name = cloneString(cfgOption(CFG_WIKI_SESSION_COOKIE));
cookie->value = cloneString(findCookieData(cookie->name));

/* fetch the edit page to get the wpEditToken, and current contents */
safef(wikiPageUrl, sizeof(wikiPageUrl), "%s/index.php/%s?action=edit",
	cfgOptionDefault(CFG_WIKI_URL, NULL), descriptionKey);

char *fullText = htmlSlurpWithCookies(wikiPageUrl,cookie);
struct htmlPage *page = htmlPageParseOk(wikiPageUrl, fullText);
/* fullText pointer is placed in page->fullText */

return (page);
}

#ifdef NOT
static char *colorMenuJS = "onchange=\"updateColorSelectBox();\" style=\"width:8em;\"";

static void colorMenuOutput()
/* the item color pull-down menu in the create item form */
{
hPrintf("<INPUT NAME=\"colorPullDown\" VALUE=\"\" SIZE=1 STYLE=\"display:none;\" >\n");

hPrintf("<SELECT NAME=\"itemColor\" style=\"width:8em; background-color:#000000;\" %s>\n", colorMenuJS);
hPrintf("<OPTION SELECTED VALUE = \"#000000\" style=\"background-color:#000000;\" >black</OPTION>\n");
hPrintf("<OPTION value = \"#0000ff\" style=\"background-color:#0000ff;\" >blue</OPTION>\n");
hPrintf("<OPTION VALUE = \"#9600c8\" style=\"background-color:#9600c8;\" >purple</OPTION>\n");
hPrintf("<OPTION VALUE = \"#ff0000\" style=\"background-color:#ff0000;\" >red</OPTION>\n");
hPrintf("<OPTION VALUE = \"#e67800\" style=\"background-color:#e67800;\" >orange</OPTION>\n");
hPrintf("<OPTION VALUE = \"#dcdc00\" style=\"background-color:#dcdc00;\" >yellow</OPTION>\n");
hPrintf("<OPTION VALUE = \"#00b400\" style=\"background-color:#00b400;\" >green</OPTION>\n");
hPrintf("<OPTION VALUE = \"#8c8c8c\" style=\"background-color:#8c8c8c;\" >gray</OPTION>\n");
hPrintf("</SELECT>\n");
}

static void outputJavaScript()
/* java script functions used in the create item form */
{
hPrintf("<SCRIPT TYPE=\"text/javascript\">\n");

hPrintf("function updateColorSelectBox() {\n"
" var form = document.getElementById(\"createItem\");\n"
" document.createItem.colorPullDown.style.display='inline';\n"
" document.createItem.colorPullDown.select();\n"
" document.createItem.colorPullDown.style.display='none';\n"
" form.itemColor.style.background = form.itemColor[form.itemColor.selectedIndex].value;\n"
" form.itemColor.style.color = form.itemColor[form.itemColor.selectedIndex].value;\n"
"}\n");
hPrintf("</SCRIPT>\n");
}

static void startForm(char *name, char *actionType, char *cgiName,
	struct cart *cart)
{
hPrintf("<FORM ID=\"%s\" NAME=\"%s\" ACTION=\"%s\">\n\n", name, name, cgiName);
cartSaveSession(cart);
cgiMakeHiddenVar("g", actionType);
cgiContinueHiddenVar("c");
cgiContinueHiddenVar("o");
hPrintf("\n");
cgiContinueHiddenVar("l");
cgiContinueHiddenVar("r");
hPrintf("\n");
}

void wikiItemCreateForm(char *userName, char *cgiName, struct cart *cart,
	int winStart, int winEnd, char *seqName)
/* put up the create new item form */
{
outputJavaScript();
startForm("createItem", G_CREATE_WIKI_ITEM, cgiName, cart);

webPrintLinkTableStart();
/* first row is a title line */
char label[256];
safef(label, ArraySize(label), "Create new item, owner: '%s'\n",
    userName);
webPrintWideLabelCell(label, 2);
webPrintLinkTableNewRow();
/* second row is group classification pull-down menu */
webPrintWideCellStart(2, HG_COL_TABLE);
puts("<B>classification group:&nbsp;</B>");
struct grp *group, *groupList = hLoadGrps();
int groupCount = 0;
for (group = groupList; group; group=group->next)
    ++groupCount;
char **classMenu = NULL;
classMenu = (char **)needMem((size_t)(groupCount * sizeof(char *)));
groupCount = 0;
classMenu[groupCount++] = cloneString(ITEM_NOT_CLASSIFIED);
for (group = groupList; group; group=group->next)
    {
    if (differentWord("Custom Tracks", group->label))
	classMenu[groupCount++] = cloneString(group->label);
    }
grpFreeList(&groupList);

cgiMakeDropList(NEW_ITEM_CLASS, classMenu, groupCount,
	cartUsualString(cart,NEW_ITEM_CLASS,ITEM_NOT_CLASSIFIED));
webPrintLinkCellEnd();
webPrintLinkTableNewRow();
/* third row is position entry box */
webPrintWideCellStart(2, HG_COL_TABLE);
puts("<B>position:&nbsp;</B>");
savePosInTextBox(seqName, winStart+1, winEnd);
hPrintf("&nbsp;(size: ");
printLongWithCommas(stdout, (long long)(winEnd - winStart));
hPrintf(")");
webPrintLinkCellEnd();
webPrintLinkTableNewRow();
/* fourth row is strand selection radio box */
webPrintWideCellStart(2, HG_COL_TABLE);
char *strand = cartUsualString(cart, NEW_ITEM_STRAND, "plus");
boolean plusStrand = sameWord("plus",strand) ? TRUE : FALSE;
hPrintf("<B>strand:&nbsp;");
cgiMakeRadioButton(NEW_ITEM_STRAND, "plus", plusStrand);
hPrintf("&nbsp;+&nbsp;&nbsp;");
cgiMakeRadioButton(NEW_ITEM_STRAND, "minus", ! plusStrand);
hPrintf("&nbsp;-</B>");
webPrintLinkCellEnd();
webPrintLinkTableNewRow();
/* fifth row is item name text entry */
webPrintWideCellStart(2, HG_COL_TABLE);
hPrintf("<B>item name:&nbsp;</B>");
cgiMakeTextVar("i", NEW_ITEM_NAME, 18);
webPrintLinkCellEnd();
#ifdef NOT
webPrintLinkTableNewRow();
/* sixth row is item score text entry */
webPrintWideCellStart(2, HG_COL_TABLE);
hPrintf("<B>item score:&nbsp;</B>");
cgiMakeTextVar(NEW_ITEM_SCORE, ITEM_SCORE_DEFAULT, 4);
hPrintf("&nbsp;(range:&nbsp;0&nbsp;to&nbsp;%s)", ITEM_SCORE_DEFAULT);
webPrintLinkCellEnd();
#endif
webPrintLinkTableNewRow();
/* seventh row is item color pull-down menu */
webPrintWideCellStart(2, HG_COL_TABLE);
hPrintf("<B>item color:&nbsp;</B>");
colorMenuOutput();
webPrintLinkCellEnd();
webPrintLinkTableNewRow();
/* seventh row is initial comment/description text entry */
webPrintWideCellStart(2, HG_COL_TABLE);
hPrintf("<B>initial comments/description:</B><BR />");
cgiMakeTextArea(NEW_ITEM_COMMENT, NEW_ITEM_COMMENT_DEFAULT, 5, 40);
webPrintLinkCellEnd();
webPrintLinkTableNewRow();
/* seventh row is the submit and cancel buttons */
/*webPrintLinkCellStart(); more careful explicit alignment */
hPrintf("<TD BGCOLOR=\"#%s\" ALIGN=\"CENTER\" VALIGN=\"TOP\">",
	HG_COL_TABLE);
cgiMakeButton("submit", "create new item");
hPrintf("\n</FORM>\n");
webPrintLinkCellEnd();
/*webPrintLinkCellStart(); doesn't valign center properly */
hPrintf("<TD BGCOLOR=\"#%s\" ALIGN=\"CENTER\" VALIGN=\"TOP\">",
	HG_COL_TABLE);
hPrintf("\n<FORM ID=\"cancel\" NAME=\"cancel\" ACTION=\"%s\">", hgTracksName());
cgiMakeButton("cancel", "cancel");
hPrintf("\n</FORM>\n");
webPrintLinkCellEnd();
webPrintLinkTableEnd();
createPageHelp("wikiTrackCreateItemHelp");
}
#endif
