/* wikiTrack.c was originally generated by the autoSql program, which also 
 * generated wikiTrack.h and wikiTrack.sql.  This module links the database and
 * the RAM representation of objects. */

#include "common.h"
#include "linefile.h"
#include "dystring.h"
#include "jksql.h"
#include "hgConfig.h"
#include "wikiLink.h"
#include "wikiTrack.h"

static char const rcsid[] = "$Id: wikiTrack.c,v 1.1 2007/05/22 22:15:25 hiram Exp $";

void wikiTrackStaticLoad(char **row, struct wikiTrack *ret)
/* Load a row from wikiTrack table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->bin = sqlUnsigned(row[0]);
ret->chrom = row[1];
ret->chromStart = sqlUnsigned(row[2]);
ret->chromEnd = sqlUnsigned(row[3]);
ret->name = row[4];
ret->score = sqlUnsigned(row[5]);
safecpy(ret->strand, sizeof(ret->strand), row[6]);
ret->db = row[7];
ret->owner = row[8];
ret->color = row[9];
ret->class = row[10];
ret->creationDate = row[11];
ret->lastModifiedDate = row[12];
ret->descriptionKey = row[13];
}

struct wikiTrack *wikiTrackLoad(char **row)
/* Load a wikiTrack from row fetched with select * from wikiTrack
 * from database.  Dispose of this with wikiTrackFree(). */
{
struct wikiTrack *ret;

AllocVar(ret);
ret->bin = sqlUnsigned(row[0]);
ret->chrom = cloneString(row[1]);
ret->chromStart = sqlUnsigned(row[2]);
ret->chromEnd = sqlUnsigned(row[3]);
ret->name = cloneString(row[4]);
ret->score = sqlUnsigned(row[5]);
safecpy(ret->strand, sizeof(ret->strand), row[6]);
ret->db = cloneString(row[7]);
ret->owner = cloneString(row[8]);
ret->color = cloneString(row[9]);
ret->class = cloneString(row[10]);
ret->creationDate = cloneString(row[11]);
ret->lastModifiedDate = cloneString(row[12]);
ret->descriptionKey = cloneString(row[13]);
return ret;
}

struct wikiTrack *wikiTrackLoadAll(char *fileName) 
/* Load all wikiTrack from a whitespace-separated file.
 * Dispose of this with wikiTrackFreeList(). */
{
struct wikiTrack *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[14];

while (lineFileRow(lf, row))
    {
    el = wikiTrackLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct wikiTrack *wikiTrackLoadAllByChar(char *fileName, char chopper) 
/* Load all wikiTrack from a chopper separated file.
 * Dispose of this with wikiTrackFreeList(). */
{
struct wikiTrack *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[14];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = wikiTrackLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct wikiTrack *wikiTrackLoadByQuery(struct sqlConnection *conn, char *query)
/* Load all wikiTrack from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with wikiTrackFreeList(). */
{
struct wikiTrack *list = NULL, *el;
struct sqlResult *sr;
char **row;

sr = sqlGetResult(conn, query);
while ((row = sqlNextRow(sr)) != NULL)
    {
    el = wikiTrackLoad(row);
    slAddHead(&list, el);
    }
slReverse(&list);
sqlFreeResult(&sr);
return list;
}

void wikiTrackSaveToDb(struct sqlConnection *conn, struct wikiTrack *el, char *tableName, int updateSize)
/* Save wikiTrack as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use wikiTrackSaveToDbEscaped() */
{
struct dyString *update = newDyString(updateSize);
dyStringPrintf(update, "insert into %s values ( %u,'%s',%u,%u,'%s',%u,'%s','%s','%s','%s','%s','%s','%s','%s')", 
	tableName,  el->bin,  el->chrom,  el->chromStart,  el->chromEnd,  el->name,  el->score,  el->strand,  el->db,  el->owner,  el->color,  el->class,  el->creationDate,  el->lastModifiedDate,  el->descriptionKey);
sqlUpdate(conn, update->string);
freeDyString(&update);
}

void wikiTrackSaveToDbEscaped(struct sqlConnection *conn, struct wikiTrack *el, char *tableName, int updateSize)
/* Save wikiTrack as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than wikiTrackSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 
{
struct dyString *update = newDyString(updateSize);
char  *chrom, *name, *strand, *db, *owner, *color, *class, *creationDate, *lastModifiedDate, *descriptionKey;
chrom = sqlEscapeString(el->chrom);
name = sqlEscapeString(el->name);
strand = sqlEscapeString(el->strand);
db = sqlEscapeString(el->db);
owner = sqlEscapeString(el->owner);
color = sqlEscapeString(el->color);
class = sqlEscapeString(el->class);
creationDate = sqlEscapeString(el->creationDate);
lastModifiedDate = sqlEscapeString(el->lastModifiedDate);
descriptionKey = sqlEscapeString(el->descriptionKey);

dyStringPrintf(update, "insert into %s values ( %u,'%s',%u,%u,'%s',%u,'%s','%s','%s','%s','%s','%s','%s','%s')", 
	tableName, el->bin ,  chrom, el->chromStart , el->chromEnd ,  name, el->score ,  strand,  db,  owner,  color,  class,  creationDate,  lastModifiedDate,  descriptionKey);
sqlUpdate(conn, update->string);
freeDyString(&update);
freez(&chrom);
freez(&name);
freez(&strand);
freez(&db);
freez(&owner);
freez(&color);
freez(&class);
freez(&creationDate);
freez(&lastModifiedDate);
freez(&descriptionKey);
}

struct wikiTrack *wikiTrackCommaIn(char **pS, struct wikiTrack *ret)
/* Create a wikiTrack out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new wikiTrack */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->bin = sqlUnsignedComma(&s);
ret->chrom = sqlStringComma(&s);
ret->chromStart = sqlUnsignedComma(&s);
ret->chromEnd = sqlUnsignedComma(&s);
ret->name = sqlStringComma(&s);
ret->score = sqlUnsignedComma(&s);
sqlFixedStringComma(&s, ret->strand, sizeof(ret->strand));
ret->db = sqlStringComma(&s);
ret->owner = sqlStringComma(&s);
ret->color = sqlStringComma(&s);
ret->class = sqlStringComma(&s);
ret->creationDate = sqlStringComma(&s);
ret->lastModifiedDate = sqlStringComma(&s);
ret->descriptionKey = sqlStringComma(&s);
*pS = s;
return ret;
}

void wikiTrackFree(struct wikiTrack **pEl)
/* Free a single dynamically allocated wikiTrack such as created
 * with wikiTrackLoad(). */
{
struct wikiTrack *el;

if ((el = *pEl) == NULL) return;
freeMem(el->chrom);
freeMem(el->name);
freeMem(el->db);
freeMem(el->owner);
freeMem(el->color);
freeMem(el->class);
freeMem(el->creationDate);
freeMem(el->lastModifiedDate);
freeMem(el->descriptionKey);
freez(pEl);
}

void wikiTrackFreeList(struct wikiTrack **pList)
/* Free a list of dynamically allocated wikiTrack's */
{
struct wikiTrack *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    wikiTrackFree(&el);
    }
*pList = NULL;
}

void wikiTrackOutput(struct wikiTrack *el, FILE *f, char sep, char lastSep) 
/* Print out wikiTrack.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->bin);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->chrom);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%u", el->chromStart);
fputc(sep,f);
fprintf(f, "%u", el->chromEnd);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->name);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%u", el->score);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->strand);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->db);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->owner);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->color);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->class);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->creationDate);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->lastModifiedDate);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->descriptionKey);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

/* -------------------------------- End autoSql Generated Code -------------------------------- */


boolean wikiTrackEnabled(char **wikiUserName)
/*determine if wikiTrack can be used, and is this user logged into the wiki ?*/
{
if (wikiUserName)
    *wikiUserName = NULL;  /* assume not logged in until proven otherwise */
if (wikiLinkEnabled())	/* must have wiki login system enabled */
    {
    char *wikiUser = wikiLinkUserName();
    if (wikiUser)
	{
	if (wikiUserName)
	    *wikiUserName = wikiUser;
	}
    if (cfgOption(CFG_WIKI_URL) != NULL)
	return TRUE;
    }
return FALSE;
}

/* from hg/lib/wikiTrack.sql */
static char *createString =
"CREATE TABLE %s (\n"
    "bin smallint unsigned not null,\n"
    "chrom varchar(255) not null,\n"
    "chromStart int unsigned not null,\n"
    "chromEnd int unsigned not null,\n"
    "name varchar(255) not null,\n"
    "score int unsigned not null,\n"
    "strand char(1) not null,\n"
    "db varchar(36) not null,\n"
    "owner varchar(255) not null,\n"
    "color varchar(255) not null,\n"
    "class varchar(255) not null,\n"
    "creationDate varchar(255) not null,\n"
    "lastModifiedDate varchar(255) not null,\n"
    "descriptionKey varchar(255) not null,\n"
    "INDEX chrom(db,bin,chrom)\n"
")\n";

char *wikiTrackGetCreateSql(char *tableName)
/* return sql create statement for wiki track with tableName */
{
struct dyString *createTable = dyStringNew(512);

dyStringPrintf(createTable, createString, tableName);

return (dyStringCannibalize(&createTable));
}
