/* ccdsKgMap.c was originally generated by the autoSql program, which also 
 * generated ccdsKgMap.h and ccdsKgMap.sql.  This module links the database and
 * the RAM representation of objects. */

#include "common.h"
#include "linefile.h"
#include "dystring.h"
#include "jksql.h"
#include "ccdsKgMap.h"

static char const rcsid[] = "$Id: ccdsKgMap.c,v 1.1 2005/04/08 09:02:40 markd Exp $";

void ccdsKgMapStaticLoad(char **row, struct ccdsKgMap *ret)
/* Load a row from ccdsKgMap table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->ccdsId = row[0];
ret->kgId = row[1];
ret->cdsSimilarity = atof(row[2]);
}

struct ccdsKgMap *ccdsKgMapLoad(char **row)
/* Load a ccdsKgMap from row fetched with select * from ccdsKgMap
 * from database.  Dispose of this with ccdsKgMapFree(). */
{
struct ccdsKgMap *ret;

AllocVar(ret);
ret->ccdsId = cloneString(row[0]);
ret->kgId = cloneString(row[1]);
ret->cdsSimilarity = atof(row[2]);
return ret;
}

struct ccdsKgMap *ccdsKgMapLoadAll(char *fileName) 
/* Load all ccdsKgMap from a whitespace-separated file.
 * Dispose of this with ccdsKgMapFreeList(). */
{
struct ccdsKgMap *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[3];

while (lineFileRow(lf, row))
    {
    el = ccdsKgMapLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct ccdsKgMap *ccdsKgMapLoadAllByChar(char *fileName, char chopper) 
/* Load all ccdsKgMap from a chopper separated file.
 * Dispose of this with ccdsKgMapFreeList(). */
{
struct ccdsKgMap *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[3];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = ccdsKgMapLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct ccdsKgMap *ccdsKgMapCommaIn(char **pS, struct ccdsKgMap *ret)
/* Create a ccdsKgMap out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new ccdsKgMap */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->ccdsId = sqlStringComma(&s);
ret->kgId = sqlStringComma(&s);
ret->cdsSimilarity = sqlFloatComma(&s);
*pS = s;
return ret;
}

void ccdsKgMapFree(struct ccdsKgMap **pEl)
/* Free a single dynamically allocated ccdsKgMap such as created
 * with ccdsKgMapLoad(). */
{
struct ccdsKgMap *el;

if ((el = *pEl) == NULL) return;
freeMem(el->ccdsId);
freeMem(el->kgId);
freez(pEl);
}

void ccdsKgMapFreeList(struct ccdsKgMap **pList)
/* Free a list of dynamically allocated ccdsKgMap's */
{
struct ccdsKgMap *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    ccdsKgMapFree(&el);
    }
*pList = NULL;
}

void ccdsKgMapOutput(struct ccdsKgMap *el, FILE *f, char sep, char lastSep) 
/* Print out ccdsKgMap.  Separate fields with sep. Follow last field with lastSep. */
{
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->ccdsId);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->kgId);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%g", el->cdsSimilarity);
fputc(lastSep,f);
}

/* -------------------------------- End autoSql Generated Code -------------------------------- */

static char *createSql =
    "CREATE TABLE %s ("
    "    ccdsId varchar(32) not null,"
    "    kgId varchar(32) not null,"
    "    cdsSimilarity float not null,"
    "    KEY(ccdsId(8)),"
    "    KEY(ccdsId(8))"
    ")";

char *ccdsKgMapGetCreateSql(char *table)
/* Get sql command to create ccdsKgMap table. Result should be freed. */
{
char sql[256];
safef(sql, sizeof(sql), createSql, table);
return cloneString(sql);
}

struct ccdsKgMap *ccdsKgMapSelectByCcds(struct sqlConnection *conn, char *ccdsId,
                                        float minSimilarity)
/* select ccdsKgMap records by ccds and minimum CDS similarity. */
{
struct ccdsKgMap * ccdsKgList = NULL;
char query[128];
struct sqlResult *sr = NULL;
char **row = NULL;

safef(query, sizeof(query), "select * from ccdsKgMap where ccdsId='%s' and cdsSimilarity >= %f",
      ccdsId, minSimilarity);
sr = sqlGetResult(conn, query);
while ((row = sqlNextRow(sr)) != NULL)
    slSafeAddHead(&ccdsKgList, ccdsKgMapLoad(row));
sqlFreeResult(&sr);
return ccdsKgList;
}

struct ccdsKgMap *ccdsKgMapSelectByKG(struct sqlConnection *conn, char *kgId,
                                      float minSimilarity)
/* select ccdsKgMap records by known gene id and minimum CDS similarity. */
{
struct ccdsKgMap *ccdsKgList = NULL;
char query[128];
struct sqlResult *sr = NULL;
char **row = NULL;

safef(query, sizeof(query), "select * from ccdsKgMap where kgId='%s' and cdsSimilarity >= %f",
      kgId, minSimilarity);
sr = sqlGetResult(conn, query);
while ((row = sqlNextRow(sr)) != NULL)
    slSafeAddHead(&ccdsKgList, ccdsKgMapLoad(row));
sqlFreeResult(&sr);
return ccdsKgList;
}

int ccdsKgMapSimilarityCmp(const void *va, const void *vb)
/* compare based on descending similarity */
{
const struct ccdsKgMap *a = *((struct ccdsKgMap **)va);
const struct ccdsKgMap *b = *((struct ccdsKgMap **)vb);
if (a->cdsSimilarity > b->cdsSimilarity)
    return -1;
if (a->cdsSimilarity < b->cdsSimilarity)
    return 1;
return 0;
}

int ccdsKgMapKgIdCmp(const void *va, const void *vb)
/* compare based on kg id */
{
const struct ccdsKgMap *a = *((struct ccdsKgMap **)va);
const struct ccdsKgMap *b = *((struct ccdsKgMap **)vb);
return strcmp(a->kgId, b->kgId);
}

