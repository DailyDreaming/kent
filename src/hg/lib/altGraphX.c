/* altGraphX.c was originally generated by the autoSql program, which also 
 * generated altGraphX.h and altGraphX.sql.  This module links the database and
 * the RAM representation of objects. */

#include "common.h"
#include "linefile.h"
#include "dystring.h"
#include "jksql.h"
#include "altGraphX.h"
#include "geneGraph.h"
#include "bed.h"

static char const rcsid[] = "$Id: altGraphX.c,v 1.10 2003/06/18 17:04:45 sugnet Exp $";

struct altGraphX *_agxSortable = NULL; /* used for sorting. */

struct evidence *evidenceCommaIn(char **pS, struct evidence *ret)
/* Create a evidence out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new evidence */
{
char *s = *pS;
int i;

if(s == NULL)
    return NULL;
if (ret == NULL)
    AllocVar(ret);
ret->evCount = sqlSignedComma(&s);
s = sqlEatChar(s, '{');
AllocArray(ret->mrnaIds, ret->evCount);
for (i=0; i<ret->evCount; ++i)
    {
    ret->mrnaIds[i] = sqlSignedComma(&s);
    }
s = sqlEatChar(s, '}');
s = sqlEatChar(s, ',');
*pS = s;
return ret;
}

void evidenceFree(struct evidence **pEl)
/* Free a single dynamically allocated evidence such as created
 * with evidenceLoad(). */
{
struct evidence *el;

if ((el = *pEl) == NULL) return;
freeMem(el->mrnaIds);
freez(pEl);
}

void evidenceFreeList(struct evidence **pList)
/* Free a list of dynamically allocated evidence's */
{
struct evidence *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    evidenceFree(&el);
    }
*pList = NULL;
}

void evidenceOutput(struct evidence *el, FILE *f, char sep, char lastSep) 
/* Print out evidence.  Separate fields with sep. Follow last field with lastSep. */
{
int i;
fprintf(f, "%d", el->evCount);
fputc(sep,f);
if (sep == ',') fputc('{',f);
for (i=0; i<el->evCount; ++i)
    {
    fprintf(f, "%d", el->mrnaIds[i]);
    fputc(',', f);
    }
if (sep == ',') fputc('}',f);
fputc(lastSep,f);
}

struct altGraphX *altGraphXLoad(char **row)
/* Load a altGraphX from row fetched with select * from altGraphX
 * from database.  Dispose of this with altGraphXFree(). */
{
struct altGraphX *ret;
int sizeOne,i;
char *s;

AllocVar(ret);
ret->vertexCount = sqlUnsigned(row[6]);
ret->edgeCount = sqlUnsigned(row[9]);
ret->mrnaRefCount = sqlSigned(row[14]);
ret->tName = cloneString(row[0]);
ret->tStart = sqlSigned(row[1]);
ret->tEnd = sqlSigned(row[2]);
ret->name = cloneString(row[3]);
ret->id = sqlUnsigned(row[4]);
strcpy(ret->strand, row[5]);
sqlUbyteDynamicArray(row[7], &ret->vTypes, &sizeOne);
assert(sizeOne == ret->vertexCount);
sqlSignedDynamicArray(row[8], &ret->vPositions, &sizeOne);
assert(sizeOne == ret->vertexCount);
sqlSignedDynamicArray(row[10], &ret->edgeStarts, &sizeOne);
assert(sizeOne == ret->edgeCount);
sqlSignedDynamicArray(row[11], &ret->edgeEnds, &sizeOne);
assert(sizeOne == ret->edgeCount);
s = row[12];
for (i=0; i<ret->edgeCount; ++i)
    {
    s = sqlEatChar(s, '{');
    slSafeAddHead(&ret->evidence, evidenceCommaIn(&s, NULL));
    s = sqlEatChar(s, '}');
    s = sqlEatChar(s, ',');
    }
slReverse(&ret->evidence);
sqlSignedDynamicArray(row[13], &ret->edgeTypes, &sizeOne);
assert(sizeOne == ret->edgeCount);
sqlStringDynamicArray(row[15], &ret->mrnaRefs, &sizeOne);
assert(sizeOne == ret->mrnaRefCount);
sqlSignedDynamicArray(row[16], &ret->mrnaTissues, &sizeOne);
assert(sizeOne == ret->mrnaRefCount);
sqlSignedDynamicArray(row[17], &ret->mrnaLibs, &sizeOne);
assert(sizeOne == ret->mrnaRefCount);
return ret;
}

struct altGraphX *altGraphXLoadAll(char *fileName) 
/* Load all altGraphX from a tab-separated file.
 * Dispose of this with altGraphXFreeList(). */
{
struct altGraphX *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[18];

while (lineFileRow(lf, row))
    {
    el = altGraphXLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct altGraphX *altGraphXLoadByQuery(struct sqlConnection *conn, char *query)
/* Load all altGraphX from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with altGraphXFreeList(). */
{
struct altGraphX *list = NULL, *el;
struct sqlResult *sr;
char **row;

sr = sqlGetResult(conn, query);
while ((row = sqlNextRow(sr)) != NULL)
    {
    el = altGraphXLoad(row);
    slAddHead(&list, el);
    }
slReverse(&list);
sqlFreeResult(&sr);
return list;
}

void altGraphXSaveToDb(struct sqlConnection *conn, struct altGraphX *el, char *tableName, int updateSize)
/* Save altGraphX as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use altGraphXSaveToDbEscaped() */
{
struct dyString *update = newDyString(updateSize);
char  *vTypesArray, *vPositionsArray, *edgeStartsArray, *edgeEndsArray, *edgeTypesArray, *mrnaRefsArray, *mrnaTissuesArray, *mrnaLibsArray;
vTypesArray = sqlUbyteArrayToString(el->vTypes, el->vertexCount);
vPositionsArray = sqlSignedArrayToString(el->vPositions, el->vertexCount);
edgeStartsArray = sqlSignedArrayToString(el->edgeStarts, el->edgeCount);
edgeEndsArray = sqlSignedArrayToString(el->edgeEnds, el->edgeCount);
edgeTypesArray = sqlSignedArrayToString(el->edgeTypes, el->edgeCount);
mrnaRefsArray = sqlStringArrayToString(el->mrnaRefs, el->mrnaRefCount);
mrnaTissuesArray = sqlSignedArrayToString(el->mrnaTissues, el->mrnaRefCount);
mrnaLibsArray = sqlSignedArrayToString(el->mrnaLibs, el->mrnaRefCount);
dyStringPrintf(update, "insert into %s values ( '%s',%d,%d,'%s',%u,'%s',%u,'%s','%s',%u,'%s','%s', NULL ,'%s',%d,'%s','%s','%s')", 
	tableName,  el->tName,  el->tStart,  el->tEnd,  el->name,  el->id,  el->strand,  el->vertexCount,  vTypesArray ,  vPositionsArray ,  el->edgeCount,  edgeStartsArray ,  edgeEndsArray ,  edgeTypesArray ,  el->mrnaRefCount,  mrnaRefsArray ,  mrnaTissuesArray ,  mrnaLibsArray );
sqlUpdate(conn, update->string);
freeDyString(&update);
freez(&vTypesArray);
freez(&vPositionsArray);
freez(&edgeStartsArray);
freez(&edgeEndsArray);
freez(&edgeTypesArray);
freez(&mrnaRefsArray);
freez(&mrnaTissuesArray);
freez(&mrnaLibsArray);
}

void altGraphXSaveToDbEscaped(struct sqlConnection *conn, struct altGraphX *el, char *tableName, int updateSize)
/* Save altGraphX as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than altGraphXSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 
{
struct dyString *update = newDyString(updateSize);
char  *tName, *name, *strand, *vTypesArray, *vPositionsArray, *edgeStartsArray, *edgeEndsArray, *edgeTypesArray, *mrnaRefsArray, *mrnaTissuesArray, *mrnaLibsArray;
tName = sqlEscapeString(el->tName);
name = sqlEscapeString(el->name);
strand = sqlEscapeString(el->strand);

vTypesArray = sqlUbyteArrayToString(el->vTypes, el->vertexCount);
vPositionsArray = sqlSignedArrayToString(el->vPositions, el->vertexCount);
edgeStartsArray = sqlSignedArrayToString(el->edgeStarts, el->edgeCount);
edgeEndsArray = sqlSignedArrayToString(el->edgeEnds, el->edgeCount);
edgeTypesArray = sqlSignedArrayToString(el->edgeTypes, el->edgeCount);
mrnaRefsArray = sqlStringArrayToString(el->mrnaRefs, el->mrnaRefCount);
mrnaTissuesArray = sqlSignedArrayToString(el->mrnaTissues, el->mrnaRefCount);
mrnaLibsArray = sqlSignedArrayToString(el->mrnaLibs, el->mrnaRefCount);
dyStringPrintf(update, "insert into %s values ( '%s',%d,%d,'%s',%u,'%s',%u,'%s','%s',%u,'%s','%s', NULL ,'%s',%d,'%s','%s','%s')", 
	tableName,  tName, el->tStart , el->tEnd ,  name, el->id ,  strand, el->vertexCount ,  vTypesArray ,  vPositionsArray , el->edgeCount ,  edgeStartsArray ,  edgeEndsArray ,  edgeTypesArray , el->mrnaRefCount ,  mrnaRefsArray ,  mrnaTissuesArray ,  mrnaLibsArray );
sqlUpdate(conn, update->string);
freeDyString(&update);
freez(&tName);
freez(&name);
freez(&strand);
freez(&vTypesArray);
freez(&vPositionsArray);
freez(&edgeStartsArray);
freez(&edgeEndsArray);
freez(&edgeTypesArray);
freez(&mrnaRefsArray);
freez(&mrnaTissuesArray);
freez(&mrnaLibsArray);
}

struct altGraphX *altGraphXCommaIn(char **pS, struct altGraphX *ret)
/* Create a altGraphX out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new altGraphX */
{
char *s = *pS;
int i;

if (ret == NULL)
    AllocVar(ret);
ret->tName = sqlStringComma(&s);
ret->tStart = sqlSignedComma(&s);
ret->tEnd = sqlSignedComma(&s);
ret->name = sqlStringComma(&s);
ret->id = sqlUnsignedComma(&s);
sqlFixedStringComma(&s, ret->strand, sizeof(ret->strand));
ret->vertexCount = sqlUnsignedComma(&s);
s = sqlEatChar(s, '{');
AllocArray(ret->vTypes, ret->vertexCount);
for (i=0; i<ret->vertexCount; ++i)
    {
    ret->vTypes[i] = sqlUnsignedComma(&s);
    }
s = sqlEatChar(s, '}');
s = sqlEatChar(s, ',');
s = sqlEatChar(s, '{');
AllocArray(ret->vPositions, ret->vertexCount);
for (i=0; i<ret->vertexCount; ++i)
    {
    ret->vPositions[i] = sqlSignedComma(&s);
    }
s = sqlEatChar(s, '}');
s = sqlEatChar(s, ',');
ret->edgeCount = sqlUnsignedComma(&s);
s = sqlEatChar(s, '{');
AllocArray(ret->edgeStarts, ret->edgeCount);
for (i=0; i<ret->edgeCount; ++i)
    {
    ret->edgeStarts[i] = sqlSignedComma(&s);
    }
s = sqlEatChar(s, '}');
s = sqlEatChar(s, ',');
s = sqlEatChar(s, '{');
AllocArray(ret->edgeEnds, ret->edgeCount);
for (i=0; i<ret->edgeCount; ++i)
    {
    ret->edgeEnds[i] = sqlSignedComma(&s);
    }
s = sqlEatChar(s, '}');
s = sqlEatChar(s, ',');
s = sqlEatChar(s, '{');
for (i=0; i<ret->edgeCount; ++i)
    {
    s = sqlEatChar(s, '{');
    slSafeAddHead(&ret->evidence, evidenceCommaIn(&s,NULL));
    s = sqlEatChar(s, '}');
    s = sqlEatChar(s, ',');
    }
slReverse(&ret->evidence);
s = sqlEatChar(s, '}');
s = sqlEatChar(s, ',');
s = sqlEatChar(s, '{');
AllocArray(ret->edgeTypes, ret->edgeCount);
for (i=0; i<ret->edgeCount; ++i)
    {
    ret->edgeTypes[i] = sqlSignedComma(&s);
    }
s = sqlEatChar(s, '}');
s = sqlEatChar(s, ',');
ret->mrnaRefCount = sqlSignedComma(&s);
s = sqlEatChar(s, '{');
AllocArray(ret->mrnaRefs, ret->mrnaRefCount);
for (i=0; i<ret->mrnaRefCount; ++i)
    {
    ret->mrnaRefs[i] = sqlStringComma(&s);
    }
s = sqlEatChar(s, '}');
s = sqlEatChar(s, ',');
s = sqlEatChar(s, '{');
AllocArray(ret->mrnaTissues, ret->mrnaRefCount);
for (i=0; i<ret->mrnaRefCount; ++i)
    {
    ret->mrnaTissues[i] = sqlSignedComma(&s);
    }
s = sqlEatChar(s, '}');
s = sqlEatChar(s, ',');
s = sqlEatChar(s, '{');
AllocArray(ret->mrnaLibs, ret->mrnaRefCount);
for (i=0; i<ret->mrnaRefCount; ++i)
    {
    ret->mrnaLibs[i] = sqlSignedComma(&s);
    }
s = sqlEatChar(s, '}');
s = sqlEatChar(s, ',');
*pS = s;
return ret;
}

void altGraphXFree(struct altGraphX **pEl)
/* Free a single dynamically allocated altGraphX such as created
 * with altGraphXLoad(). */
{
struct altGraphX *el;
int i;
if ((el = *pEl) == NULL) return;
freeMem(el->tName);
freeMem(el->name);
freeMem(el->vTypes);
freeMem(el->vPositions);
freeMem(el->edgeStarts);
freeMem(el->edgeEnds);
evidenceFreeList(&el->evidence);
freeMem(el->edgeTypes);
/* it appears that the mrnaRefs are really one big string from loadAll function, so they can be free'd all at once */
/* for(i=0;i<el->mrnaRefCount; i++) */
/*     freez(&el->mrnaRefs[i]); */

/* First free the first entry if exists, this frees all
   of the rest of them. */
if(el->mrnaRefs != NULL)
    freeMem(el->mrnaRefs[0]);
/* Now free the array that points to them. */
freeMem(el->mrnaRefs);
freeMem(el->mrnaTissues);
freeMem(el->mrnaLibs);
freez(pEl);
}

void altGraphXFreeList(struct altGraphX **pList)
/* Free a list of dynamically allocated altGraphX's */
{
struct altGraphX *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    altGraphXFree(&el);
    }
*pList = NULL;
}

void altGraphXOutput(struct altGraphX *el, FILE *f, char sep, char lastSep) 
/* Print out altGraphX.  Separate fields with sep. Follow last field with lastSep. */
{
int i;
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->tName);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%d", el->tStart);
fputc(sep,f);
fprintf(f, "%d", el->tEnd);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->name);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%u", el->id);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->strand);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%u", el->vertexCount);
fputc(sep,f);
if (sep == ',') fputc('{',f);
for (i=0; i<el->vertexCount; ++i)
    {
    fprintf(f, "%u", el->vTypes[i]);
    fputc(',', f);
    }
if (sep == ',') fputc('}',f);
fputc(sep,f);
if (sep == ',') fputc('{',f);
for (i=0; i<el->vertexCount; ++i)
    {
    fprintf(f, "%d", el->vPositions[i]);
    fputc(',', f);
    }
if (sep == ',') fputc('}',f);
fputc(sep,f);
fprintf(f, "%u", el->edgeCount);
fputc(sep,f);
if (sep == ',') fputc('{',f);
for (i=0; i<el->edgeCount; ++i)
    {
    fprintf(f, "%d", el->edgeStarts[i]);
    fputc(',', f);
    }
if (sep == ',') fputc('}',f);
fputc(sep,f);
if (sep == ',') fputc('{',f);
for (i=0; i<el->edgeCount; ++i)
    {
    fprintf(f, "%d", el->edgeEnds[i]);
    fputc(',', f);
    }
if (sep == ',') fputc('}',f);
fputc(sep,f);
/* Loading evidence list. */
    {
    struct evidence *it = el->evidence;
    if (sep == ',') fputc('{',f);
    for (i=0; i<el->edgeCount && el->evidence != NULL; ++i)
        {
        fputc('{',f);
        evidenceCommaOut(it,f);
        it = it->next;
        fputc('}',f);
        fputc(',',f);
        }
    if (sep == ',') fputc('}',f);
    }
fputc(sep,f);
if (sep == ',') fputc('{',f);
for (i=0; i<el->edgeCount; ++i)
    {
    fprintf(f, "%d", el->edgeTypes[i]);
    fputc(',', f);
    }
if (sep == ',') fputc('}',f);
fputc(sep,f);
fprintf(f, "%d", el->mrnaRefCount);
fputc(sep,f);
if (sep == ',') fputc('{',f);
for (i=0; i<el->mrnaRefCount; ++i)
    {
    if (sep == ',') fputc('"',f);
    fprintf(f, "%s", el->mrnaRefs[i]);
    if (sep == ',') fputc('"',f);
    fputc(',', f);
    }
if (sep == ',') fputc('}',f);
fputc(sep,f);
if (sep == ',') fputc('{',f);
for (i=0; i<el->mrnaRefCount; ++i)
    {
    fprintf(f, "%d", el->mrnaTissues[i]);
    fputc(',', f);
    }
if (sep == ',') fputc('}',f);
fputc(sep,f);
if (sep == ',') fputc('{',f);
for (i=0; i<el->mrnaRefCount; ++i)
    {
    fprintf(f, "%d", el->mrnaLibs[i]);
    fputc(',', f);
    }
if (sep == ',') fputc('}',f);
fputc(lastSep,f);
}

/* -------------------------------- End autoSql Generated Code -------------------------------- */

void altGraphXoffset(struct altGraphX *ag, int offset)
/* add offset to all coordinates of altGraphX */
{
int i;
ag->tStart += offset;
ag->tEnd += offset;
for(i=0; i<ag->vertexCount; i++)
    ag->vPositions[i] += offset;    
}

boolean isEndXVertice(bool **em, int vertexCount, int vertice, char *vTypes)
/* check to see if there are any edges coming out of this vertice */
{
int i;
for(i=0; i<vertexCount; i++)
    {
    if(em[vertice][i] && (vTypes[i] != ggUnused))
	return FALSE;
    }
return TRUE;
}

void countXPathsFromVertice(bool **em, bool *seen, char *vTypes, int vertexCount, int vertice, int *pathCount)
/* recursively count paths from vertice */
{
int i=0;
/* color me counted */
seen[vertice] = TRUE;

/* check for termination */
if(isEndXVertice(em, vertexCount, vertice, vTypes))
    {
    (*pathCount)++;
    }
else
    {
    /* recursively call for all vertices that are connected to from this vertex */
    for(i = 0; i < vertexCount; i++)
	{
	if(em[vertice][i] && vTypes[i] != ggUnused)
	    {
	    countXPathsFromVertice(em, seen, vTypes, vertexCount, i, pathCount);
	    }
	}
    }
}

int altGraphXNumAltSplices(struct altGraphX *ag)
/* Count number of times that exons have more than one edge through them */
{
int count=0; 
int pathCount=0;
int i=0;
int vertexCount = ag->vertexCount;
bool **em;    /* edge matrix */
bool *seen;  /* has this edge been seen? */
/* construct the edge matrix */
em = AllocArray(em, vertexCount);
seen = AllocArray(seen, vertexCount);
for (i=0; i<vertexCount; ++i)
    {
    em[i] = AllocArray(em[i], vertexCount);
    }
for (i=0; i<ag->edgeCount; ++i)
    em[ag->edgeStarts[i]][ag->edgeEnds[i]] = TRUE;

/* recursively count all possible paths for each
   vertice if we've seen it  */
for(i=0; i<vertexCount; i++)
    if(!seen[i])
	{
	countXPathsFromVertice(em, seen, ag->vTypes, vertexCount, i, &pathCount);
	}

/* clean up */
for(i = 0; i < vertexCount; i++)
    freez(&em[i]);
freez(&em);

return pathCount;
}

enum agColor 
/* color of a vertex */
{
    agWhite, /* unseen */
    agGray,  /* seen */
    agBlack, /* finished */
};

bool **altGraphXCreateEdgeMatrix(struct altGraphX *ag)
/* create an edgematix from an altGraphX, free this with 
 * agFreeEdgeMatrix */
{
int numVert = ag->vertexCount;
bool **em;
int i=0;
int numEdges = ag->edgeCount;
int *eStarts, *eEnds;
eStarts = ag->edgeStarts;
eEnds = ag->edgeEnds;

assert(numVert > 0);
/* allocate memory */
AllocArray(em, numVert);
for(i=0; i< numVert; i++)
    AllocArray(em[i], numVert);

/* fill in edges */
for(i=0; i < numEdges; i++)
    em[eStarts[i]][eEnds[i]] = TRUE;
return em;
}

void altGraphXFreeEdgeMatrix(bool ***pEm, int vertCount)
/* Free an edge matrix. */
{
int i;
bool **em = *pEm; 
if(em == NULL)
    return;
for(i=0; i<vertCount; i++)
    freez(&em[i]);
freez(pEm);
}

static void agDfsTopo(bool **em, int vertex, int *colors, int *topo, 
	int numVert, int *topoNum)
/* recursive depth first search routine for topological sort */
{
int i,j;
colors[vertex] = agGray;
for(i =0; i<numVert; i++)
    if(em[vertex][i] && colors[i] == agWhite)
	agDfsTopo(em, i, colors, topo, numVert, topoNum);
(*topoNum)--;
assert(*topoNum >= 0);
topo[vertex] = *topoNum;
colors[vertex] = agBlack;
}

void agTranslateEdgeArray(int *from, int *to, int *translator, int count)
/* change order of from as described in translator and
 * return in to. */
{
int i;
for(i=0;i<count; i++)
    {
    to[i] = translator[from[i]];
    }
}

void agTranslateIntArray(int *from, int *to, int *translator, int count)
/* change order of from as described in translator and
 * return in to. */
{
int i;
for(i=0;i<count; i++)
    {
    to[translator[i]] = from[i];
    }
}

void agTranslateUCharArray(unsigned char *from, unsigned char *to, int *translator, int count)
/* change order of from as described in translator and
 * return in to. */
{
int i;
for(i=0;i<count; i++)
    {
    to[translator[i]] = from[i];
    }
}


void altGraphXArrangeVertsByOrder(struct altGraphX *ag, int *translator)
/* use the translator as a way to "sort" vertices, and
 * edges */
{
struct evidence ***agEv = NULL;
struct evidence *ev = NULL, *evNext = NULL;
int *sEdgeStarts = NULL;
int *sEdgeEnds = NULL;
unsigned char *sVTypes = NULL;
int *sVPositions = NULL;
int vertCount = ag->vertexCount;
int edgeCount = ag->edgeCount;
bool **em = NULL;
int i,j;

/* convert vertices to translator order */
AllocArray(sVTypes, vertCount);
agTranslateUCharArray(ag->vTypes, sVTypes, translator, vertCount);

AllocArray(sVPositions, vertCount);
agTranslateIntArray(ag->vPositions, sVPositions, translator, vertCount);

AllocArray(sEdgeStarts, edgeCount);
agTranslateEdgeArray(ag->edgeStarts, sEdgeStarts, translator, edgeCount);

AllocArray(sEdgeEnds, edgeCount);
agTranslateEdgeArray(ag->edgeEnds, sEdgeEnds, translator, edgeCount);


/* repackage our sorted stuff into the altGraphX */
freez(&ag->vTypes);
ag->vTypes = sVTypes;

freez(&ag->vPositions);
ag->vPositions = sVPositions;

freez(&ag->edgeStarts);
ag->edgeStarts = sEdgeStarts;

freez(&ag->edgeEnds);
ag->edgeEnds = sEdgeEnds;

em = altGraphXCreateEdgeMatrix(ag);

/* sort our edges by the same translator order,
 * use edge matrix to do so. */
AllocArray(agEv, vertCount);
for(i=0; i<vertCount; i++)
    AllocArray(agEv[i], vertCount);
for(i=0; i<edgeCount; i++)
    {
    agEv[sEdgeStarts[i]][sEdgeEnds[i]] = slElementFromIx(ag->evidence, i);
    }
edgeCount =0;
ag->evidence = NULL;
for(i=0; i<vertCount; i++)
    {
    for(j=0; j<vertCount; j++)
	{
	if(em[i][j])
	    {
	    ag->edgeStarts[edgeCount] = i;
	    ag->edgeEnds[edgeCount] = j;
	    slAddHead(&ag->evidence, agEv[i][j]);
	    edgeCount++;
	    }
	}
    }
slReverse(&ag->evidence);
altGraphXFreeEdgeMatrix(&em, vertCount);
for(i=0; i<vertCount; i++)
    freez(&agEv[i]);
freez(&agEv);
}

struct agVertSortable
/* package for sorting vertices */
{
    int index;
    int vPosition;
};

int agVertSortableCmp(const void *e1, const void *e2)
/* used with qsort to sort array */
{
const struct agVertSortable *a = *((struct agVertSortable **)e1);
const struct agVertSortable *b = *((struct agVertSortable **)e2);
return (a->vPosition - b->vPosition);
}

void altGraphXVertPosSort(struct altGraphX *ag)
/* sort an altGraphX's vertices by position on tName */
{
struct agVertSortable **pAvg = NULL;
struct agVertSortable *avg = NULL;
int i,j;
int *translator = NULL;
int vertCount = ag->vertexCount;
assert(vertCount > 0);

/* get order sorted by position */
AllocArray(pAvg, vertCount);
for(i=0;i<vertCount; i++)
    {
    AllocVar(avg);
    avg->index = i;
    avg->vPosition = ag->vPositions[i];
    pAvg[i] = avg;
    }
qsort(pAvg, vertCount, sizeof(pAvg[0]), agVertSortableCmp);

AllocArray(translator, vertCount);
for(i=0;i<vertCount; i++)
    translator[pAvg[i]->index] = i; 

/* arrange vertices and edges in that order */
altGraphXArrangeVertsByOrder(ag, translator);

/* cleanup */
freez(&translator);
for(i=0;i<vertCount; i++)
    freez(&pAvg[i]);
freez(&pAvg);
}

void altGraphXTopologicalSort(struct altGraphX *ag)
/* Do a topological sort on vertices in altGraphX, basic 
 * algorithm from "Computer Algorithms" Sara Baase and Allen Van Gelder
 * 3rd Edition 2000, pp 345-353 */
{
int *colors = NULL;
int *topo = NULL;
int topoNum = 0;
int vertCount = ag->vertexCount;
bool **em = NULL;
int i,j;
/* allocate memeory and initialize */
assert(vertCount > 0);
AllocArray(colors, vertCount);
AllocArray(topo, vertCount);
em = altGraphXCreateEdgeMatrix(ag);
for(i=0; i<vertCount; i++)
    colors[i] = agWhite;
topoNum = vertCount;

/* get topological order */
for(i=0; i<vertCount; i++)
    {
    if(colors[i] == agWhite)
	agDfsTopo(em, i, colors, topo, vertCount, &topoNum);
    }

altGraphXArrangeVertsByOrder(ag, topo);
altGraphXFreeEdgeMatrix(&em, vertCount);
freez(&colors);
freez(&topo);
}


boolean altGraphXEdgeObserved(struct altGraphX *ag, int *seen, int *seenCount, int mrnaIx)
/* is the mrnaIx already in seen? */
{
int i=0;
boolean result = FALSE;
for(i=0; i<*seenCount; i++)
    {
    if(ag->mrnaTissues[seen[i]] == ag->mrnaTissues[mrnaIx] ||
       ag->mrnaLibs[seen[i]] == ag->mrnaLibs[mrnaIx])
	{
	result = TRUE;
	break;
	}
    }
if(!result)
    {
    seen[*seenCount++] = mrnaIx;
    }
return result;
}


int altGraphTimesSeenEdge(struct altGraphX *ag, int eIx) 
/* Count how many times we see evidence for a particular edge. */
{
struct evidence *ev = slElementFromIx(ag->evidence, eIx);
int *seen = NULL;
int seenCount = 0,i;
int conf = 0;
AllocArray(seen, ag->edgeCount);
for(i=0; i<ag->edgeCount; i++)
    seen[i] = -1;
for(i=0; i<ev->evCount; i++)
    if(!altGraphXEdgeObserved(ag, seen, &seenCount, ev->mrnaIds[i]))
	conf++;
freez(&seen);
return conf;
}

static void assignToArray(int *array, int arraySize, int count, int val)
{
if(count >= arraySize)
    errAbort("Can't have count: %d greater than array size: %d", count, arraySize);
array[count] = val;
}

boolean uniqeInArray(int *array, int size, int val)
{
int i;
for(i=0;i<size; i++)
    if(array[i] == val)
	return FALSE;
return TRUE;
}

int edgePopularityCmp(const void *va, const void *vb)
/* Compare to sort on commonness edge. */
{
int cmp = 0;
const int *a = ((int *)va);
const int *b = ((int *)vb);
struct evidence *evB = slElementFromIx(_agxSortable->evidence, *b);
struct evidence *evA = slElementFromIx(_agxSortable->evidence, *a);
cmp = evB->evCount - evA->evCount;
return cmp;
}

int findMostCommonEdge(struct altGraphX *ag, int *edgeArray, int edgeCount)
/* Find the most common edge in the edge array. */
{
assert(edgeArray);
assert(ag);
_agxSortable = ag;
qsort(edgeArray, edgeCount, sizeof(int *), edgePopularityCmp);
_agxSortable =  NULL;
return (edgeArray[0]);
}

int findUpStartFrom(struct altGraphX *ag, int fpSplice)
/* Given a five prime splice site, find the three prime splice that
   makes an exon. Returns -1 if can't find any. */
{
int *exonStartEdges = NULL;
int exonStartCount = 0;
int eCount = ag->edgeCount;
int tpSite = 0;
int i;
AllocArray(exonStartEdges, eCount);
for(i = 0; i < eCount; i++)
    {
    if(ag->edgeEnds[i] == ag->edgeStarts[fpSplice])
	assignToArray(exonStartEdges, eCount, exonStartCount++, i);
    }
if(exonStartCount == 0)
    tpSite =-1;
else
    tpSite = findMostCommonEdge(ag, exonStartEdges, exonStartCount);
freez(&exonStartEdges);
return tpSite;
}

int findDownEndFrom(struct altGraphX *ag, int tpSplice)
/* Given a three prime splice site, find the downstream five prime splice that
   makes an exon. Returns -1 if can't find any. */
{
int *exonEndEdges = NULL;
int exonEndCount = 0;
int eCount = ag->edgeCount;
int tpSite = 0;
int i;
AllocArray(exonEndEdges, eCount);
for(i = 0; i < eCount; i++)
    {
    if(ag->edgeStarts[i] == ag->edgeEnds[tpSplice])
	assignToArray(exonEndEdges, eCount, exonEndCount++, i);
    }
if(exonEndCount == 0)
    tpSite =-1;
else
    tpSite = findMostCommonEdge(ag, exonEndEdges, exonEndCount);
freez(&exonEndEdges);
return tpSite;
}

int getEvidenceCount(struct altGraphX *ag, int edge)
{
struct evidence *ev = slElementFromIx(ag->evidence, edge);
return ev->evCount;
}

struct bed *createBedFromEdges( struct altGraphX *ag, int fpEdge, int cassEdge, int tpEdge)
/* Put the edges together to from a bed structure. */
{
int *vPos = ag->vPositions;
int *starts = ag->edgeStarts;
int *ends = ag->edgeEnds;
struct bed *bed;
int numBlocks = 3;
AllocVar(bed);
bed->chrom = cloneString(ag->tName);
snprintf(bed->strand, sizeof(bed->strand), "%s", ag->strand);
bed->chromStart = bed->thickStart = vPos[starts[fpEdge]];
bed->chromEnd = bed->thickEnd = vPos[ends[tpEdge]];
bed->name = cloneString(ag->name);
bed->blockCount = numBlocks;
bed->blockSizes = AllocArray(bed->blockSizes, numBlocks);
bed->chromStarts = AllocArray(bed->chromStarts, numBlocks);
bed->blockSizes[0] = vPos[ends[fpEdge]] - vPos[starts[fpEdge]];
bed->blockSizes[1] = vPos[ends[cassEdge]] - vPos[starts[cassEdge]];
bed->blockSizes[2] = vPos[ends[tpEdge]] - vPos[starts[tpEdge]];
bed->chromStarts[0] = vPos[starts[fpEdge]] -bed->chromStart;
bed->chromStarts[1] = vPos[starts[cassEdge]] - bed->chromStart;
bed->chromStarts[2] = vPos[starts[tpEdge]] -bed->chromStart;
bed->score = getEvidenceCount(ag,fpEdge)+ getEvidenceCount(ag, tpEdge);

bed->expCount = numBlocks;
bed->expIds = AllocArray(bed->expIds, numBlocks);
bed->expScores = AllocArray(bed->expScores, numBlocks);
bed->expIds[0] = fpEdge;
bed->expIds[1] = cassEdge;
bed->expIds[2] = tpEdge;
return bed;
}

static enum ggEdgeType altGraphXEdgeVertexType(struct altGraphX *ag, int v1, int v2)
/* Return edge type. */
{
if( (ag->vTypes[v1] == ggHardStart || ag->vTypes[v1] == ggSoftStart)  
    && (ag->vTypes[v2] == ggHardEnd || ag->vTypes[v2] == ggSoftEnd)) 
    return ggExon;
else if( (ag->vTypes[v1] == ggHardEnd || ag->vTypes[v1] == ggSoftEnd)  
	 && (ag->vTypes[v2] == ggHardStart || ag->vTypes[v2] == ggSoftStart)) 
    return ggSJ;
else
    return ggIntron;
}

enum ggEdgeType altGraphXEdgeType(struct altGraphX *ag, int edge)
/* Return edge type. */
{
return altGraphXEdgeVertexType(ag, ag->edgeStarts[edge], ag->edgeEnds[edge]);
}


struct bed *altGraphXToBed(struct altGraphX *ag)
/* Merge all overlapping exons to form bed datatype. Free with bedFree().*/
{
int *bases = NULL;
int baseCount =  ag->tEnd - ag->tStart +1;
struct bed *bed = NULL;
int i=0, j=0, k=0;
int offSet = ag->tStart;
int vCount = ag->vertexCount;
int *vPos = ag->vPositions;
int start = 0;
int width = 0;
int currentStart = 0;
boolean extending = FALSE;
enum ggEdgeType eType;
AllocArray(bases, baseCount);

/* first paint the bases. */
for(i=0; i<ag->edgeCount; i++)
    {
    eType = altGraphXEdgeType(ag, i);
    if(eType == ggExon || eType == ggCassette)
	{
	width = vPos[ag->edgeEnds[i]] - vPos[ag->edgeStarts[i]];
	start = vPos[ag->edgeStarts[i]]-offSet;
	for(k=start; k<width+start;k++)
	    {
	    bases[k] = 1;
	    }
	}
    }
AllocVar(bed);
AllocArray(bed->blockSizes, ag->edgeCount);
AllocArray(bed->chromStarts, ag->edgeCount);
bed->chrom = cloneString(ag->tName);
bed->name = cloneString(ag->name);
safef(bed->strand, sizeof(bed->strand), "%s", ag->strand);
bed->thickStart = bed->chromStart = ag->tStart;
bed->thickEnd = bed->chromEnd = ag->tEnd;
for(i=0; i<baseCount; i++)
    {
    if(bases[i] == 1 && !extending)
	{
	currentStart = i;
	extending = TRUE;
	}
    else if(bases[i] == 0 && extending)
	{
	bed->blockSizes[bed->blockCount] = i - currentStart;
	bed->chromStarts[bed->blockCount] = currentStart;
	bed->thickEnd = bed->chromEnd = max(bed->thickEnd, i+offSet);
	bed->thickStart = bed->chromStart = min(bed->thickStart, (currentStart + offSet));
	bed->blockCount++;
	currentStart = BIGNUM;
	extending = FALSE;
	}
    }
/* Finish her off..*/
if(extending)
    {
    bed->blockSizes[bed->blockCount] = i - currentStart;
    bed->chromStarts[bed->blockCount] = currentStart;
    bed->thickEnd = bed->chromEnd = max(bed->thickEnd, i+offSet);
    bed->thickStart = bed->chromStart = min(bed->thickStart, currentStart+offSet);
    bed->blockCount++;
    currentStart = BIGNUM;
    extending = FALSE;
    }
freez(&bases);
return bed;
}

struct bed *altGraphGetExonCassette(struct altGraphX *ag, int eIx)
/* Get a bed which corresponds to the exons involved in a cassette exon. */
{
int eStart =0, eEnd = 0;
int *intStartEdges = NULL, *intEndEdges =NULL, *altEdges = NULL;
int intStartCount = 0, intEndCount =0, altCount =0;
int i,j,k;
int conf = 0;
int eCount = ag->edgeCount;
struct bed *bedList = NULL;
AllocArray(intStartEdges, ag->edgeCount);
AllocArray(intEndEdges, ag->edgeCount);
AllocArray(altEdges, ag->edgeCount);
eStart = ag->edgeStarts[eIx];
eEnd = ag->edgeEnds[eIx];
/* First find the introns that connect to our edge of interest. */
for(i = 0; i < ag->edgeCount; i++)
    {
    if(ag->edgeEnds[i] == eStart)
	assignToArray(intStartEdges, eCount, intStartCount++, i);
    if(ag->edgeStarts[i] == eEnd)
	assignToArray(intEndEdges, eCount, intEndCount++, i);
    }
/* for each intron that connects to our exon. */
for(i = 0; i < intStartCount; i++)
    {
    for(j =0; j < ag->edgeCount; j++)
	{
	/* Look for and edge that starts at the same place as our introns. */
	if(intStartEdges[i] != j && (ag->edgeStarts[j] == ag->edgeStarts[intStartEdges[i]]))
	    {
	    for(k=0; k < intEndCount; k++) 
		{
		/* Then connects to one of the same ends. */
		if(ag->edgeEnds[j] == ag->edgeEnds[intEndEdges[k]])
		    {
		    /* If it is new... */
		    if(uniqeInArray(altEdges, altCount, j))
			{
			struct bed *bed = NULL;
			int upStart = findUpStartFrom(ag, intStartEdges[i]);
			int downEnd = findDownEndFrom(ag, intEndEdges[k]);
			bed = createBedFromEdges(ag, upStart, eIx, downEnd);
			assignToArray(altEdges, eCount, altCount++, j);
			slAddHead(&bedList, bed);
			}
		    }
		}
	    }
	}
    }
freez(&altEdges);
freez(&intStartEdges);
freez(&intEndEdges);
return bedList;
}

int altGraphTimesNotSeenEdge(struct altGraphX *ag, int eIx) 
/* Discover how many times there is a transcript that uses an alternative
   to the edge eIx. */
{
int eStart =0, eEnd = 0;
int *intStartEdges = NULL, *intEndEdges =NULL, *altEdges = NULL;
int intStartCount = 0, intEndCount =0, altCount =0;
int i,j,k;
int conf = 0;
int eCount = ag->edgeCount;
AllocArray(intStartEdges, ag->edgeCount);
AllocArray(intEndEdges, ag->edgeCount);
AllocArray(altEdges, ag->edgeCount);
eStart = ag->edgeStarts[eIx];
eEnd = ag->edgeEnds[eIx];
/* First find the introns that connect to our edge of interest. */
for(i = 0; i < ag->edgeCount; i++)
    {
    if(ag->edgeEnds[i] == eStart)
	assignToArray(intStartEdges, eCount, intStartCount++, i);
    if(ag->edgeStarts[i] == eEnd)
	assignToArray(intEndEdges, eCount, intEndCount++, i);
    }

/* for each intron that connects to our exon. */
for(i = 0; i < intStartCount; i++)
    {
    for(j =0; j < ag->edgeCount; j++)
	{
	/* Look for and edge that starts at the same place as our introns. */
	if(intStartEdges[i] != j && (ag->edgeStarts[j] == ag->edgeStarts[intStartEdges[i]]))
	    {
	    for(k=0; k < intEndCount; k++) 
		{
		/* Then connects to one of the same ends. */
		if(ag->edgeEnds[j] == ag->edgeEnds[intEndEdges[k]])
		    if(uniqeInArray(altEdges, altCount, j))
			assignToArray(altEdges, eCount, altCount++, j);
		}
	    }
	}
    }

for(i=0; i< altCount; i++)
    {
    conf += altGraphTimesSeenEdge(ag, altEdges[i]);
    }
freez(&altEdges);
freez(&intStartEdges);
freez(&intEndEdges);
return conf;
}

float altGraphCassetteConfForEdge(struct altGraphX *ag, int eIx, float prior)
/* Return the score for this cassette exon. Want to have cassette exons
that are present in multiple transcripts and that are not present in multiple
exons. We want to see both forms of the cassette exon, we don't want to have
one outlier be chosen. Thus we count the times that the exon is seen, we
count the times that the exon isn't seen and we calculate a final score by:
(seen + notseen + prior)/(abs(seen - notSeen+prior) + 1) . Thus larger scores are better. */
{
int seen = altGraphTimesSeenEdge(ag, eIx);
int notSeen = altGraphTimesNotSeenEdge(ag, eIx);
float conf = 0;
conf = (float)(seen + notSeen + prior)/(float)(abs(seen - notSeen) + prior);
return conf;
}

enum ggEdgeType getSpliceEdgeType(struct altGraphX *ag, int edge)
/* Return edge type. */
{
if( (ag->vTypes[ag->edgeStarts[edge]] == ggHardStart || ag->vTypes[ag->edgeStarts[edge]] == ggSoftStart)
    && (ag->vTypes[ag->edgeEnds[edge]] == ggHardEnd || ag->vTypes[ag->edgeEnds[edge]] == ggSoftEnd))
    return ggExon;
else if( (ag->vTypes[ag->edgeStarts[edge]] == ggHardEnd || ag->vTypes[ag->edgeStarts[edge]] == ggSoftEnd)
	 && (ag->vTypes[ag->edgeEnds[edge]] == ggHardStart || ag->vTypes[ag->edgeEnds[edge]] == ggSoftStart))
    return ggSJ;
else
    return ggIntron;
}

boolean altGraphXEdgeSeen(struct altGraphX *ag, int *seen, int *seenCount, int mrnaIx)
/* is the mrnaIx already in seen? */
{
int i=0;
boolean result = FALSE;
for(i=0; i<(*seenCount); i++)
    {
    if(ag->mrnaTissues[seen[i]] == ag->mrnaTissues[mrnaIx] ||
       ag->mrnaLibs[seen[i]] == ag->mrnaLibs[mrnaIx])
	{
	result = TRUE;
	break;
	}
    }
if(!result)
    {
    seen[(*seenCount)] = mrnaIx;
    (*seenCount)++;
    }
return result;
}

int altGraphConfidenceForEdge(struct altGraphX *ag, int eIx)
/* count how many unique libraries or tissues contain a given edge */
{
struct evidence *ev = slElementFromIx(ag->evidence, eIx);
int *seen = NULL;
int seenCount = 0,i;
int conf = 0;
AllocArray(seen, ev->evCount);
for(i=0; i<ev->evCount; i++)
    seen[i] = -1;
for(i=0; i<ev->evCount; i++)
    if(!altGraphXEdgeSeen(ag, seen, &seenCount, ev->mrnaIds[i]))
	conf++;
freez(&seen);
return conf;
}


struct spliceEdge *altGraphXToEdges(struct altGraphX *ag)
/* Return a list of splice edges based on data in altGraphX. */
{
int i;
struct spliceEdge *e = NULL, *eList = NULL;
int *vPos = ag->vPositions;
int *starts = ag->edgeStarts;
int *ends = ag->edgeEnds;
for(i=0; i<ag->edgeCount; i++)
    {
    AllocVar(e);
    e->type = getSpliceEdgeType(ag,i);
    e->start = vPos[starts[i]];
    e->end = vPos[ends[i]];
    e->v1 = starts[i];
    e->v2 = ends[i];
//    e->conf = ag->evidence[i].evCount;
    e->conf = altGraphConfidenceForEdge(ag, i);
    slAddHead(&eList, e);
    } 
return eList;
}

int spliceEdgeTypeConfCmp(const void *va, const void *vb)
/* Compare to sort based on type, confidence, and then start. */
{
const struct spliceEdge *a = *((struct spliceEdge **)va);
const struct spliceEdge *b = *((struct spliceEdge **)vb);
int diff = a->type - b->type;
if(diff == 0)
    diff = b->conf - a->conf;
if(diff == 0)
    diff = a->start - b->start;
if(diff == 0)
    diff = a->end - b->end;
return diff;
}


void addSpliceNode(struct hash *spliceHash, int count, int position, int row, int maxRows)
/* Add a 1 in the correct row to indicate that there is a
   feature there. */
{
char key[128];
int *levels = NULL;
safef(key, sizeof(key), "%d-%d", count, position);
if(row >= maxRows)
    errAbort("addSpliceNode() - Row %d is greater than maxRows %d\n", row, maxRows);
levels = hashFindVal(spliceHash, key);
if(levels == NULL)
    {
    AllocArray(levels, maxRows);
    levels[row] = 1;
    hashAdd(spliceHash, key, levels);
    }
else
    levels[row] = 1;
}


void drawExonAt(struct spliceEdge *se, int heightPer, int regionStart, int regionEnd,
		struct vGfx *vg, int xOff, int y, 
		double scale, MgFont *font, Color color, Color *shades)
/* Draw an exon at. */
{
int x1 = round((double)((int)se->start-regionStart)*scale) + xOff;
int x2 = round((double)((int)se->end-regionStart)*scale) + xOff;
int w=0, textWidth=0;
Color exonColor;
char buff[256];
int conf = 0;
if(se->conf > 9) 
    conf = 9;
else if(se->conf < 2) 
    conf = 2;
else
    conf = (int)se->conf;
w = x2-x1;
if (w < 1)
    w = 1;
exonColor = shades[conf];
vgBox(vg, x1, y, w, heightPer/2, exonColor);
safef(buff, sizeof(buff), "%d-%d-%d", se->v1, se->v2, (int)se->conf);
textWidth = mgFontStringWidth(font, buff);
if(textWidth <= w)
    vgTextCentered(vg, x1, y, w, heightPer/2, MG_WHITE, font, buff);
}

struct spliceEdge *createFakeExon(int vertex, int position, int confidence)
/* Return a spliceEdge of type exon that is a single base pair for
   this splice site. */
{
struct spliceEdge *se = NULL;
AllocVar(se);
se->v1 = vertex;
se->v2 = vertex;
se->start = position;
se->end = position+1;
se->conf = confidence;
return se;
}

void altGraphXLayout(struct altGraphX *agList, int regionStart, int regionEnd, 
		     int regionWidth, double scale, int maxRows,
		     struct spaceSaver **ssList, struct hash **heightHash, 
		     int *rowCount)
/** Layout a list of altGraphX's in a space width wide. Return a list
    of one spaceSaver per altGraphX record, a hash with the row layout
    offset of the exons, and the number of rows required to layout. */
{
struct altGraphX *ag = NULL;
struct spaceSaver *ss = NULL;
struct spliceEdge *egList = NULL, *eg = NULL, *egNext = NULL;
struct spaceNode *sn = NULL;
char keyBuff[1024];
int start, end, height;
int agCount = 0;
*heightHash = newHash(8);
/* For every item */
for(ag = agList; ag != NULL; ag = ag->next)
    {
    bool *vSeen = NULL; /* Have we seen a given vertex yet? */
    AllocArray(vSeen, ag->vertexCount);
    ss = spaceSaverNew(0, regionWidth, maxRows);
    egList = altGraphXToEdges(ag);
    slSort(&egList, spliceEdgeTypeConfCmp);
    /* For every edge in graph. */
    for(eg = egList; eg != NULL; eg = egNext)	
	{
	egNext = eg->next;
	eg->itemNumber = agCount;
	if(eg->type != ggExon && eg->type != ggCassette)
	    {

	    if(vSeen[eg->v1] && vSeen[eg->v2])
		continue;
	    /* If we don't have an exon for a splice site we have to do a little futzing.
	       to create a "fake" exon for the splice site so it will be drawn. */
	    else 
		{
		struct spliceEdge *fake = NULL;
		slAddHead(&egNext, eg);
		if(!vSeen[eg->v2])
		    {
		    fake = createFakeExon(eg->v2, eg->end, eg->conf);
		    slAddHead(&egNext, fake);
		    }
		if(!vSeen[eg->v1])
		    {
		    fake = createFakeExon(eg->v1, eg->start-1, eg->conf);
		    slAddHead(&egNext, fake);
		    }
		}
	    continue;
	    }
	vSeen[eg->v1] = 1;
	vSeen[eg->v2] = 1;
	start = round((double)(eg->start - regionStart)*scale);
	end = round((double)(eg->end - regionStart)*scale);
	if (start <= regionWidth && end >= 0)
	    {
	    if (start < 0) start = 0;
	    if (end > regionWidth) end = regionWidth;
	    if (spaceSaverAdd(ss, start, end, eg) == NULL)
		break;
	    }
	}
    spaceSaverFinish(ss);
    slAddHead(ssList, ss);
    (*rowCount) += ss->rowCount;
    for (sn = ss->nodeList; sn != NULL; sn = sn->next)
	{
	struct spliceEdge *se = sn->val, *seTmp = NULL;
	char key[128];
	se->row = sn->row;
	safef(key, sizeof(key), "%d", se->itemNumber);
	seTmp = hashFindVal((*heightHash), key);
	if(seTmp != NULL)
	    {
	    if(seTmp->row < se->row)
		hashAdd((*heightHash), key, se);
	    }
	else
	    hashAdd((*heightHash), key, se);
	}
    freez(&vSeen);
    agCount++;
    }
slReverse(ssList);
}

void altGraphXDrawPack(struct altGraphX *agList, struct spaceSaver *ssList, 
		       int xOff, int yOff, int width,  int heightPer, int lineHeight,
		       int regionStart, int regionEnd, double scale, int baseWidth, 
		       struct vGfx *vg, MgFont *font, Color color, Color *shades, char *drawName,
		       void (*mapItem)(char *tableName, struct altGraphX *ag, int start, int end,
				       int x, int y, int width, int height))
/** Draw a splicing graph for each altGraphX in the agList where the
    exons don't overlap as they have been laid out in the spaceSaver
    list. */
{
struct hash *spliceHash = newHash(8);
char key[128];
struct altGraphX *ag = NULL;
struct spliceEdge *eg = NULL, *egList = NULL, *egNext = NULL;
struct spaceSaver *ss = NULL;
int count =0;
int i=0,j=0, minRow=0;
double y1=0, y2=0;
int y=0;
for(ss = ssList, ag=agList; ss != NULL && ag != NULL; ss=ss->next, ag=ag->next)
    {
    struct spaceNode *sn = NULL;
    int *sjStarts = NULL, *sjEnds = NULL;
    int mapStart = round((ag->tStart - regionStart)*scale) + xOff;
    int mapEnd = round((ag->tEnd - regionStart)*scale) + xOff;	
    int mapHeight = 0;

    /* Draw a clickable thing if we can. */
    if(mapItem != NULL)
	{
	int mapWidth = mapEnd - mapStart;
	if(mapWidth < 1) 
	    mapStart = 1;
	mapHeight = ((ss->rowCount+1) * lineHeight);
	mapItem(drawName, ag, ag->tStart, ag->tEnd, mapStart, yOff, mapWidth, mapHeight);
	}
    /* Draw all of the exons that have been stored in the spacesaver. */
    for (sn = ss->nodeList; sn != NULL; sn = sn->next)
	{
	struct spliceEdge *se = sn->val;
	int s = se->start;
	int e = se->end;
	int x1 = round((s - regionStart)*scale) + xOff;
	int x2 = round((e - regionStart)*scale) + xOff;	
	y = yOff + (lineHeight * sn->row) + (lineHeight/2);
	drawExonAt(se, heightPer, regionStart, regionEnd,
		   vg, xOff, y, scale, font, color, shades);
	/* Record the row that this exon was drawn at. */
	addSpliceNode(spliceHash, count, s, sn->row, ss->rowCount);
	addSpliceNode(spliceHash, count, e, sn->row, ss->rowCount);
	}
    /* For every edge in item's graph. */
    egList = altGraphXToEdges(ag);
    slSort(&egList, spliceEdgeTypeConfCmp);
    for(eg = egList; eg != NULL; eg = egNext)	
	{
	egNext = eg->next;
	/* We are only drawing splice junctions now. */
	if(eg->type != ggSJ)
	    {
	    freez(&eg);
	    continue;
	    }
	/* Look up the rows that this splice junction starts and ends at. */
	safef(key, sizeof(key), "%d-%d", count, eg->start);
	sjStarts = hashFindVal(spliceHash, key);
	safef(key, sizeof(key), "%d-%d", count, eg->end);
	sjEnds = hashFindVal(spliceHash, key);
	/* Draw and edge from each starting row to each ending column. */
	for(i=0; i< ss->rowCount; i++)
	    {
	    if(sjStarts != NULL && sjStarts[i] == 1)
		{
		for(j=0; j< ss->rowCount; j++)
		    {
		    if(sjEnds != NULL && sjEnds[j] == 1)
			{
			int s = eg->start;
			int e = eg->end;
			int x1 = round((s - regionStart)*scale) + xOff;
			int x2 = round((e - regionStart)*scale) + xOff;	
			int midX = 0, midY =0;
			Color c = MG_BLACK;
			minRow = min(j, i);
			midY = yOff + (lineHeight * minRow);
			midX = (x1+x2)/2;
			vgLine(vg, x1,round(yOff+(lineHeight*i)+lineHeight/2), midX, midY, c);
			vgLine(vg, midX, midY, x2, round(yOff+(lineHeight*j)+lineHeight/2), c);
			}
		    }
		}
	    }
	freez(&eg);
	}
    count++;
    yOff += ss->rowCount *lineHeight;
    }
freeHashAndVals(&spliceHash);
}
