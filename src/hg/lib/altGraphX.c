/* altGraphX.c was originally generated by the autoSql program, which also 
 * generated altGraphX.h and altGraphX.sql.  This module links the database and
 * the RAM representation of objects. */

#include "common.h"
#include "linefile.h"
#include "dystring.h"
#include "jksql.h"
#include "altGraphX.h"
#include "geneGraph.h"
#include "bed.h"

struct altGraphX *_agxSortable = NULL; /* used for sorting. */

struct evidence *evidenceCommaIn(char **pS, struct evidence *ret)
/* Create a evidence out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new evidence */
{
char *s = *pS;
int i;

if (ret == NULL)
    AllocVar(ret);
ret->evCount = sqlSignedComma(&s);
s = sqlEatChar(s, '{');
AllocArray(ret->mrnaIds, ret->evCount);
for (i=0; i<ret->evCount; ++i)
    {
    ret->mrnaIds[i] = sqlSignedComma(&s);
    }
s = sqlEatChar(s, '}');
s = sqlEatChar(s, ',');
*pS = s;
return ret;
}

void evidenceFree(struct evidence **pEl)
/* Free a single dynamically allocated evidence such as created
 * with evidenceLoad(). */
{
struct evidence *el;

if ((el = *pEl) == NULL) return;
freeMem(el->mrnaIds);
freez(pEl);
}

void evidenceFreeList(struct evidence **pList)
/* Free a list of dynamically allocated evidence's */
{
struct evidence *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    evidenceFree(&el);
    }
*pList = NULL;
}

void evidenceOutput(struct evidence *el, FILE *f, char sep, char lastSep) 
/* Print out evidence.  Separate fields with sep. Follow last field with lastSep. */
{
int i;
fprintf(f, "%d", el->evCount);
fputc(sep,f);
if (sep == ',') fputc('{',f);
for (i=0; i<el->evCount; ++i)
    {
    fprintf(f, "%d", el->mrnaIds[i]);
    fputc(',', f);
    }
if (sep == ',') fputc('}',f);
fputc(lastSep,f);
}

struct altGraphX *altGraphXLoad(char **row)
/* Load a altGraphX from row fetched with select * from altGraphX
 * from database.  Dispose of this with altGraphXFree(). */
{
struct altGraphX *ret;
int sizeOne,i;
char *s;

AllocVar(ret);
ret->vertexCount = sqlUnsigned(row[6]);
ret->edgeCount = sqlUnsigned(row[9]);
ret->mrnaRefCount = sqlSigned(row[14]);
ret->tName = cloneString(row[0]);
ret->tStart = sqlSigned(row[1]);
ret->tEnd = sqlSigned(row[2]);
ret->name = cloneString(row[3]);
ret->id = sqlUnsigned(row[4]);
strcpy(ret->strand, row[5]);
sqlUbyteDynamicArray(row[7], &ret->vTypes, &sizeOne);
assert(sizeOne == ret->vertexCount);
sqlSignedDynamicArray(row[8], &ret->vPositions, &sizeOne);
assert(sizeOne == ret->vertexCount);
sqlSignedDynamicArray(row[10], &ret->edgeStarts, &sizeOne);
assert(sizeOne == ret->edgeCount);
sqlSignedDynamicArray(row[11], &ret->edgeEnds, &sizeOne);
assert(sizeOne == ret->edgeCount);
s = row[12];
for (i=0; i<ret->edgeCount; ++i)
    {
    s = sqlEatChar(s, '{');
    slSafeAddHead(&ret->evidence, evidenceCommaIn(&s, NULL));
    s = sqlEatChar(s, '}');
    s = sqlEatChar(s, ',');
    }
slReverse(&ret->evidence);
sqlSignedDynamicArray(row[13], &ret->edgeTypes, &sizeOne);
assert(sizeOne == ret->edgeCount);
sqlStringDynamicArray(row[15], &ret->mrnaRefs, &sizeOne);
assert(sizeOne == ret->mrnaRefCount);
sqlSignedDynamicArray(row[16], &ret->mrnaTissues, &sizeOne);
assert(sizeOne == ret->mrnaRefCount);
sqlSignedDynamicArray(row[17], &ret->mrnaLibs, &sizeOne);
assert(sizeOne == ret->mrnaRefCount);
return ret;
}

struct altGraphX *altGraphXLoadAll(char *fileName) 
/* Load all altGraphX from a tab-separated file.
 * Dispose of this with altGraphXFreeList(). */
{
struct altGraphX *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[18];

while (lineFileRow(lf, row))
    {
    el = altGraphXLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct altGraphX *altGraphXLoadByQuery(struct sqlConnection *conn, char *query)
/* Load all altGraphX from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with altGraphXFreeList(). */
{
struct altGraphX *list = NULL, *el;
struct sqlResult *sr;
char **row;

sr = sqlGetResult(conn, query);
while ((row = sqlNextRow(sr)) != NULL)
    {
    el = altGraphXLoad(row);
    slAddHead(&list, el);
    }
slReverse(&list);
sqlFreeResult(&sr);
return list;
}

void altGraphXSaveToDb(struct sqlConnection *conn, struct altGraphX *el, char *tableName, int updateSize)
/* Save altGraphX as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use altGraphXSaveToDbEscaped() */
{
struct dyString *update = newDyString(updateSize);
char  *vTypesArray, *vPositionsArray, *edgeStartsArray, *edgeEndsArray, *edgeTypesArray, *mrnaRefsArray, *mrnaTissuesArray, *mrnaLibsArray;
vTypesArray = sqlUbyteArrayToString(el->vTypes, el->vertexCount);
vPositionsArray = sqlSignedArrayToString(el->vPositions, el->vertexCount);
edgeStartsArray = sqlSignedArrayToString(el->edgeStarts, el->edgeCount);
edgeEndsArray = sqlSignedArrayToString(el->edgeEnds, el->edgeCount);
edgeTypesArray = sqlSignedArrayToString(el->edgeTypes, el->edgeCount);
mrnaRefsArray = sqlStringArrayToString(el->mrnaRefs, el->mrnaRefCount);
mrnaTissuesArray = sqlSignedArrayToString(el->mrnaTissues, el->mrnaRefCount);
mrnaLibsArray = sqlSignedArrayToString(el->mrnaLibs, el->mrnaRefCount);
dyStringPrintf(update, "insert into %s values ( '%s',%d,%d,'%s',%u,'%s',%u,'%s','%s',%u,'%s','%s', NULL ,'%s',%d,'%s','%s','%s')", 
	tableName,  el->tName,  el->tStart,  el->tEnd,  el->name,  el->id,  el->strand,  el->vertexCount,  vTypesArray ,  vPositionsArray ,  el->edgeCount,  edgeStartsArray ,  edgeEndsArray ,  edgeTypesArray ,  el->mrnaRefCount,  mrnaRefsArray ,  mrnaTissuesArray ,  mrnaLibsArray );
sqlUpdate(conn, update->string);
freeDyString(&update);
freez(&vTypesArray);
freez(&vPositionsArray);
freez(&edgeStartsArray);
freez(&edgeEndsArray);
freez(&edgeTypesArray);
freez(&mrnaRefsArray);
freez(&mrnaTissuesArray);
freez(&mrnaLibsArray);
}

void altGraphXSaveToDbEscaped(struct sqlConnection *conn, struct altGraphX *el, char *tableName, int updateSize)
/* Save altGraphX as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than altGraphXSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 
{
struct dyString *update = newDyString(updateSize);
char  *tName, *name, *strand, *vTypesArray, *vPositionsArray, *edgeStartsArray, *edgeEndsArray, *edgeTypesArray, *mrnaRefsArray, *mrnaTissuesArray, *mrnaLibsArray;
tName = sqlEscapeString(el->tName);
name = sqlEscapeString(el->name);
strand = sqlEscapeString(el->strand);

vTypesArray = sqlUbyteArrayToString(el->vTypes, el->vertexCount);
vPositionsArray = sqlSignedArrayToString(el->vPositions, el->vertexCount);
edgeStartsArray = sqlSignedArrayToString(el->edgeStarts, el->edgeCount);
edgeEndsArray = sqlSignedArrayToString(el->edgeEnds, el->edgeCount);
edgeTypesArray = sqlSignedArrayToString(el->edgeTypes, el->edgeCount);
mrnaRefsArray = sqlStringArrayToString(el->mrnaRefs, el->mrnaRefCount);
mrnaTissuesArray = sqlSignedArrayToString(el->mrnaTissues, el->mrnaRefCount);
mrnaLibsArray = sqlSignedArrayToString(el->mrnaLibs, el->mrnaRefCount);
dyStringPrintf(update, "insert into %s values ( '%s',%d,%d,'%s',%u,'%s',%u,'%s','%s',%u,'%s','%s', NULL ,'%s',%d,'%s','%s','%s')", 
	tableName,  tName, el->tStart , el->tEnd ,  name, el->id ,  strand, el->vertexCount ,  vTypesArray ,  vPositionsArray , el->edgeCount ,  edgeStartsArray ,  edgeEndsArray ,  edgeTypesArray , el->mrnaRefCount ,  mrnaRefsArray ,  mrnaTissuesArray ,  mrnaLibsArray );
sqlUpdate(conn, update->string);
freeDyString(&update);
freez(&tName);
freez(&name);
freez(&strand);
freez(&vTypesArray);
freez(&vPositionsArray);
freez(&edgeStartsArray);
freez(&edgeEndsArray);
freez(&edgeTypesArray);
freez(&mrnaRefsArray);
freez(&mrnaTissuesArray);
freez(&mrnaLibsArray);
}

struct altGraphX *altGraphXCommaIn(char **pS, struct altGraphX *ret)
/* Create a altGraphX out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new altGraphX */
{
char *s = *pS;
int i;

if (ret == NULL)
    AllocVar(ret);
ret->tName = sqlStringComma(&s);
ret->tStart = sqlSignedComma(&s);
ret->tEnd = sqlSignedComma(&s);
ret->name = sqlStringComma(&s);
ret->id = sqlUnsignedComma(&s);
sqlFixedStringComma(&s, ret->strand, sizeof(ret->strand));
ret->vertexCount = sqlUnsignedComma(&s);
s = sqlEatChar(s, '{');
AllocArray(ret->vTypes, ret->vertexCount);
for (i=0; i<ret->vertexCount; ++i)
    {
    ret->vTypes[i] = sqlUnsignedComma(&s);
    }
s = sqlEatChar(s, '}');
s = sqlEatChar(s, ',');
s = sqlEatChar(s, '{');
AllocArray(ret->vPositions, ret->vertexCount);
for (i=0; i<ret->vertexCount; ++i)
    {
    ret->vPositions[i] = sqlSignedComma(&s);
    }
s = sqlEatChar(s, '}');
s = sqlEatChar(s, ',');
ret->edgeCount = sqlUnsignedComma(&s);
s = sqlEatChar(s, '{');
AllocArray(ret->edgeStarts, ret->edgeCount);
for (i=0; i<ret->edgeCount; ++i)
    {
    ret->edgeStarts[i] = sqlSignedComma(&s);
    }
s = sqlEatChar(s, '}');
s = sqlEatChar(s, ',');
s = sqlEatChar(s, '{');
AllocArray(ret->edgeEnds, ret->edgeCount);
for (i=0; i<ret->edgeCount; ++i)
    {
    ret->edgeEnds[i] = sqlSignedComma(&s);
    }
s = sqlEatChar(s, '}');
s = sqlEatChar(s, ',');
s = sqlEatChar(s, '{');
for (i=0; i<ret->edgeCount; ++i)
    {
    s = sqlEatChar(s, '{');
    slSafeAddHead(&ret->evidence, evidenceCommaIn(&s,NULL));
    s = sqlEatChar(s, '}');
    s = sqlEatChar(s, ',');
    }
slReverse(&ret->evidence);
s = sqlEatChar(s, '}');
s = sqlEatChar(s, ',');
s = sqlEatChar(s, '{');
AllocArray(ret->edgeTypes, ret->edgeCount);
for (i=0; i<ret->edgeCount; ++i)
    {
    ret->edgeTypes[i] = sqlSignedComma(&s);
    }
s = sqlEatChar(s, '}');
s = sqlEatChar(s, ',');
ret->mrnaRefCount = sqlSignedComma(&s);
s = sqlEatChar(s, '{');
AllocArray(ret->mrnaRefs, ret->mrnaRefCount);
for (i=0; i<ret->mrnaRefCount; ++i)
    {
    ret->mrnaRefs[i] = sqlStringComma(&s);
    }
s = sqlEatChar(s, '}');
s = sqlEatChar(s, ',');
s = sqlEatChar(s, '{');
AllocArray(ret->mrnaTissues, ret->mrnaRefCount);
for (i=0; i<ret->mrnaRefCount; ++i)
    {
    ret->mrnaTissues[i] = sqlSignedComma(&s);
    }
s = sqlEatChar(s, '}');
s = sqlEatChar(s, ',');
s = sqlEatChar(s, '{');
AllocArray(ret->mrnaLibs, ret->mrnaRefCount);
for (i=0; i<ret->mrnaRefCount; ++i)
    {
    ret->mrnaLibs[i] = sqlSignedComma(&s);
    }
s = sqlEatChar(s, '}');
s = sqlEatChar(s, ',');
*pS = s;
return ret;
}

void altGraphXFree(struct altGraphX **pEl)
/* Free a single dynamically allocated altGraphX such as created
 * with altGraphXLoad(). */
{
struct altGraphX *el;
int i;
if ((el = *pEl) == NULL) return;
freeMem(el->tName);
freeMem(el->name);
freeMem(el->vTypes);
freeMem(el->vPositions);
freeMem(el->edgeStarts);
freeMem(el->edgeEnds);
evidenceFreeList(&el->evidence);
freeMem(el->edgeTypes);
/* it appears that the mrnaRefs are really one big string from loadAll function, so they can be free'd all at once */
/* for(i=0;i<el->mrnaRefCount; i++) */
/*     freez(&el->mrnaRefs[i]); */
freez(&el->mrnaRefs);
freeMem(el->mrnaTissues);
freeMem(el->mrnaLibs);
freez(pEl);
}

void altGraphXFreeList(struct altGraphX **pList)
/* Free a list of dynamically allocated altGraphX's */
{
struct altGraphX *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    altGraphXFree(&el);
    }
*pList = NULL;
}

void altGraphXOutput(struct altGraphX *el, FILE *f, char sep, char lastSep) 
/* Print out altGraphX.  Separate fields with sep. Follow last field with lastSep. */
{
int i;
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->tName);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%d", el->tStart);
fputc(sep,f);
fprintf(f, "%d", el->tEnd);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->name);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%u", el->id);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->strand);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%u", el->vertexCount);
fputc(sep,f);
if (sep == ',') fputc('{',f);
for (i=0; i<el->vertexCount; ++i)
    {
    fprintf(f, "%u", el->vTypes[i]);
    fputc(',', f);
    }
if (sep == ',') fputc('}',f);
fputc(sep,f);
if (sep == ',') fputc('{',f);
for (i=0; i<el->vertexCount; ++i)
    {
    fprintf(f, "%d", el->vPositions[i]);
    fputc(',', f);
    }
if (sep == ',') fputc('}',f);
fputc(sep,f);
fprintf(f, "%u", el->edgeCount);
fputc(sep,f);
if (sep == ',') fputc('{',f);
for (i=0; i<el->edgeCount; ++i)
    {
    fprintf(f, "%d", el->edgeStarts[i]);
    fputc(',', f);
    }
if (sep == ',') fputc('}',f);
fputc(sep,f);
if (sep == ',') fputc('{',f);
for (i=0; i<el->edgeCount; ++i)
    {
    fprintf(f, "%d", el->edgeEnds[i]);
    fputc(',', f);
    }
if (sep == ',') fputc('}',f);
fputc(sep,f);
/* Loading evidence list. */
    {
    struct evidence *it = el->evidence;
    if (sep == ',') fputc('{',f);
    for (i=0; i<el->edgeCount; ++i)
        {
        fputc('{',f);
        evidenceCommaOut(it,f);
        it = it->next;
        fputc('}',f);
        fputc(',',f);
        }
    if (sep == ',') fputc('}',f);
    }
fputc(sep,f);
if (sep == ',') fputc('{',f);
for (i=0; i<el->edgeCount; ++i)
    {
    fprintf(f, "%d", el->edgeTypes[i]);
    fputc(',', f);
    }
if (sep == ',') fputc('}',f);
fputc(sep,f);
fprintf(f, "%d", el->mrnaRefCount);
fputc(sep,f);
if (sep == ',') fputc('{',f);
for (i=0; i<el->mrnaRefCount; ++i)
    {
    if (sep == ',') fputc('"',f);
    fprintf(f, "%s", el->mrnaRefs[i]);
    if (sep == ',') fputc('"',f);
    fputc(',', f);
    }
if (sep == ',') fputc('}',f);
fputc(sep,f);
if (sep == ',') fputc('{',f);
for (i=0; i<el->mrnaRefCount; ++i)
    {
    fprintf(f, "%d", el->mrnaTissues[i]);
    fputc(',', f);
    }
if (sep == ',') fputc('}',f);
fputc(sep,f);
if (sep == ',') fputc('{',f);
for (i=0; i<el->mrnaRefCount; ++i)
    {
    fprintf(f, "%d", el->mrnaLibs[i]);
    fputc(',', f);
    }
if (sep == ',') fputc('}',f);
fputc(lastSep,f);
}

/* -------------------------------- End autoSql Generated Code -------------------------------- */

void altGraphXoffset(struct altGraphX *ag, int offset)
/* add offset to all coordinates of altGraphX */
{
int i;
ag->tStart += offset;
ag->tEnd += offset;
for(i=0; i<ag->vertexCount; i++)
    ag->vPositions[i] += offset;    
}

boolean isEndXVertice(bool **em, int vertexCount, int vertice, char *vTypes)
/* check to see if there are any edges coming out of this vertice */
{
int i;
for(i=0; i<vertexCount; i++)
    {
    if(em[vertice][i] && (vTypes[i] != ggUnused))
	return FALSE;
    }
return TRUE;
}

void countXPathsFromVertice(bool **em, bool *seen, char *vTypes, int vertexCount, int vertice, int *pathCount)
/* recursively count paths from vertice */
{
int i=0;
/* color me counted */
seen[vertice] = TRUE;

/* check for termination */
if(isEndXVertice(em, vertexCount, vertice, vTypes))
    {
    (*pathCount)++;
    }
else
    {
    /* recursively call for all vertices that are connected to from this vertex */
    for(i = 0; i < vertexCount; i++)
	{
	if(em[vertice][i] && vTypes[i] != ggUnused)
	    {
	    countXPathsFromVertice(em, seen, vTypes, vertexCount, i, pathCount);
	    }
	}
    }
}

int altGraphXNumAltSplices(struct altGraphX *ag)
/* Count number of times that exons have more than one edge through them */
{
int count=0; 
int pathCount=0;
int i=0;
int vertexCount = ag->vertexCount;
bool **em;    /* edge matrix */
bool *seen;  /* has this edge been seen? */
/* construct the edge matrix */
em = AllocArray(em, vertexCount);
seen = AllocArray(seen, vertexCount);
for (i=0; i<vertexCount; ++i)
    {
    em[i] = AllocArray(em[i], vertexCount);
    }
for (i=0; i<ag->edgeCount; ++i)
    em[ag->edgeStarts[i]][ag->edgeEnds[i]] = TRUE;

/* recursively count all possible paths for each
   vertice if we've seen it  */
for(i=0; i<vertexCount; i++)
    if(!seen[i])
	{
	countXPathsFromVertice(em, seen, ag->vTypes, vertexCount, i, &pathCount);
	}

/* clean up */
for(i = 0; i < vertexCount; i++)
    freez(&em[i]);
freez(&em);

return pathCount;
}

enum agColor 
/* color of a vertex */
{
    agWhite, /* unseen */
    agGray,  /* seen */
    agBlack, /* finished */
};

bool **altGraphXCreateEdgeMatrix(struct altGraphX *ag)
/* create an edgematix from an altGraphX, free this with 
 * agFreeEdgeMatrix */
{
int numVert = ag->vertexCount;
bool **em;
int i=0;
int numEdges = ag->edgeCount;
int *eStarts, *eEnds;
eStarts = ag->edgeStarts;
eEnds = ag->edgeEnds;

assert(numVert > 0);
/* allocate memory */
AllocArray(em, numVert);
for(i=0; i< numVert; i++)
    AllocArray(em[i], numVert);

/* fill in edges */
for(i=0; i < numEdges; i++)
    em[eStarts[i]][eEnds[i]] = TRUE;
return em;
}

void altGraphXFreeEdgeMatrix(bool ***pEm, int vertCount)
/* Free an edge matrix. */
{
int i;
bool **em = *pEm; 
if(em == NULL)
    return;
for(i=0; i<vertCount; i++)
    freez(&em[i]);
freez(pEm);
}

static void agDfsTopo(bool **em, int vertex, int *colors, int *topo, 
	int numVert, int *topoNum)
/* recursive depth first search routine for topological sort */
{
int i,j;
colors[vertex] = agGray;
for(i =0; i<numVert; i++)
    if(em[vertex][i] && colors[i] == agWhite)
	agDfsTopo(em, i, colors, topo, numVert, topoNum);
(*topoNum)--;
assert(*topoNum >= 0);
topo[vertex] = *topoNum;
colors[vertex] = agBlack;
}

void agTranslateEdgeArray(int *from, int *to, int *translator, int count)
/* change order of from as described in translator and
 * return in to. */
{
int i;
for(i=0;i<count; i++)
    {
    to[i] = translator[from[i]];
    }
}

void agTranslateIntArray(int *from, int *to, int *translator, int count)
/* change order of from as described in translator and
 * return in to. */
{
int i;
for(i=0;i<count; i++)
    {
    to[translator[i]] = from[i];
    }
}

void agTranslateUCharArray(unsigned char *from, unsigned char *to, int *translator, int count)
/* change order of from as described in translator and
 * return in to. */
{
int i;
for(i=0;i<count; i++)
    {
    to[translator[i]] = from[i];
    }
}


void altGraphXArrangeVertsByOrder(struct altGraphX *ag, int *translator)
/* use the translator as a way to "sort" vertices, and
 * edges */
{
struct evidence ***agEv = NULL;
struct evidence *ev = NULL, *evNext = NULL;
int *sEdgeStarts = NULL;
int *sEdgeEnds = NULL;
unsigned char *sVTypes = NULL;
int *sVPositions = NULL;
int vertCount = ag->vertexCount;
int edgeCount = ag->edgeCount;
bool **em = NULL;
int i,j;

/* convert vertices to translator order */
AllocArray(sVTypes, vertCount);
agTranslateUCharArray(ag->vTypes, sVTypes, translator, vertCount);

AllocArray(sVPositions, vertCount);
agTranslateIntArray(ag->vPositions, sVPositions, translator, vertCount);

AllocArray(sEdgeStarts, edgeCount);
agTranslateEdgeArray(ag->edgeStarts, sEdgeStarts, translator, edgeCount);

AllocArray(sEdgeEnds, edgeCount);
agTranslateEdgeArray(ag->edgeEnds, sEdgeEnds, translator, edgeCount);


/* repackage our sorted stuff into the altGraphX */
freez(&ag->vTypes);
ag->vTypes = sVTypes;

freez(&ag->vPositions);
ag->vPositions = sVPositions;

freez(&ag->edgeStarts);
ag->edgeStarts = sEdgeStarts;

freez(&ag->edgeEnds);
ag->edgeEnds = sEdgeEnds;

em = altGraphXCreateEdgeMatrix(ag);

/* sort our edges by the same translator order,
 * use edge matrix to do so. */
AllocArray(agEv, vertCount);
for(i=0; i<vertCount; i++)
    AllocArray(agEv[i], vertCount);
for(i=0; i<edgeCount; i++)
    {
    agEv[sEdgeStarts[i]][sEdgeEnds[i]] = slElementFromIx(ag->evidence, i);
    }
edgeCount =0;
ag->evidence = NULL;
for(i=0; i<vertCount; i++)
    {
    for(j=0; j<vertCount; j++)
	{
	if(em[i][j])
	    {
	    ag->edgeStarts[edgeCount] = i;
	    ag->edgeEnds[edgeCount] = j;
	    slAddHead(&ag->evidence, agEv[i][j]);
	    edgeCount++;
	    }
	}
    }
slReverse(&ag->evidence);
altGraphXFreeEdgeMatrix(&em, vertCount);
for(i=0; i<vertCount; i++)
    freez(&agEv[i]);
freez(&agEv);
}

struct agVertSortable
/* package for sorting vertices */
{
    int index;
    int vPosition;
};

int agVertSortableCmp(const void *e1, const void *e2)
/* used with qsort to sort array */
{
const struct agVertSortable *a = *((struct agVertSortable **)e1);
const struct agVertSortable *b = *((struct agVertSortable **)e2);
return (a->vPosition - b->vPosition);
}

void altGraphXVertPosSort(struct altGraphX *ag)
/* sort an altGraphX's vertices by position on tName */
{
struct agVertSortable **pAvg = NULL;
struct agVertSortable *avg = NULL;
int i,j;
int *translator = NULL;
int vertCount = ag->vertexCount;
assert(vertCount > 0);

/* get order sorted by position */
AllocArray(pAvg, vertCount);
for(i=0;i<vertCount; i++)
    {
    AllocVar(avg);
    avg->index = i;
    avg->vPosition = ag->vPositions[i];
    pAvg[i] = avg;
    }
qsort(pAvg, vertCount, sizeof(pAvg[0]), agVertSortableCmp);

AllocArray(translator, vertCount);
for(i=0;i<vertCount; i++)
    translator[pAvg[i]->index] = i; 

/* arrange vertices and edges in that order */
altGraphXArrangeVertsByOrder(ag, translator);

/* cleanup */
freez(&translator);
for(i=0;i<vertCount; i++)
    freez(&pAvg[i]);
freez(&pAvg);
}

void altGraphXTopologicalSort(struct altGraphX *ag)
/* Do a topological sort on vertices in altGraphX, basic 
 * algorithm from "Computer Algorithms" Sara Baase and Allen Van Gelder
 * 3rd Edition 2000, pp 345-353 */
{
int *colors = NULL;
int *topo = NULL;
int topoNum = 0;
int vertCount = ag->vertexCount;
bool **em = NULL;
int i,j;
/* allocate memeory and initialize */
assert(vertCount > 0);
AllocArray(colors, vertCount);
AllocArray(topo, vertCount);
em = altGraphXCreateEdgeMatrix(ag);
for(i=0; i<vertCount; i++)
    colors[i] = agWhite;
topoNum = vertCount;

/* get topological order */
for(i=0; i<vertCount; i++)
    {
    if(colors[i] == agWhite)
	agDfsTopo(em, i, colors, topo, vertCount, &topoNum);
    }

altGraphXArrangeVertsByOrder(ag, topo);
altGraphXFreeEdgeMatrix(&em, vertCount);
freez(&colors);
freez(&topo);
}


boolean altGraphXEdgeObserved(struct altGraphX *ag, int *seen, int *seenCount, int mrnaIx)
/* is the mrnaIx already in seen? */
{
int i=0;
boolean result = FALSE;
for(i=0; i<*seenCount; i++)
    {
    if(ag->mrnaTissues[seen[i]] == ag->mrnaTissues[mrnaIx] ||
       ag->mrnaLibs[seen[i]] == ag->mrnaLibs[mrnaIx])
	{
	result = TRUE;
	break;
	}
    }
if(!result)
    {
    seen[*seenCount++] = mrnaIx;
    }
return result;
}


int altGraphTimesSeenEdge(struct altGraphX *ag, int eIx) 
/* Count how many times we see evidence for a particular edge. */
{
struct evidence *ev = slElementFromIx(ag->evidence, eIx);
int *seen = NULL;
int seenCount = 0,i;
int conf = 0;
AllocArray(seen, ag->edgeCount);
for(i=0; i<ag->edgeCount; i++)
    seen[i] = -1;
for(i=0; i<ev->evCount; i++)
    if(!altGraphXEdgeObserved(ag, seen, &seenCount, ev->mrnaIds[i]))
	conf++;
freez(&seen);
return conf;
}

static void assignToArray(int *array, int arraySize, int count, int val)
{
if(count >= arraySize)
    errAbort("Can't have count: %d greater than array size: %d", count, arraySize);
array[count] = val;
}

boolean uniqeInArray(int *array, int size, int val)
{
int i;
for(i=0;i<size; i++)
    if(array[i] == val)
	return FALSE;
return TRUE;
}

int edgePopularityCmp(const void *va, const void *vb)
/* Compare to sort on commonness edge. */
{
int cmp = 0;
const int *a = ((int *)va);
const int *b = ((int *)vb);
struct evidence *evB = slElementFromIx(_agxSortable->evidence, *b);
struct evidence *evA = slElementFromIx(_agxSortable->evidence, *a);
cmp = evB->evCount - evA->evCount;
return cmp;
}

int findMostCommonEdge(struct altGraphX *ag, int *edgeArray, int edgeCount)
/* Find the most common edge in the edge array. */
{
assert(edgeArray);
assert(ag);
_agxSortable = ag;
qsort(edgeArray, edgeCount, sizeof(int *), edgePopularityCmp);
_agxSortable =  NULL;
return (edgeArray[0]);
}

int findUpStartFrom(struct altGraphX *ag, int fpSplice)
/* Given a five prime splice site, find the three prime splice that
   makes an exon. Returns -1 if can't find any. */
{
int *exonStartEdges = NULL;
int exonStartCount = 0;
int eCount = ag->edgeCount;
int tpSite = 0;
int i;
AllocArray(exonStartEdges, eCount);
for(i = 0; i < eCount; i++)
    {
    if(ag->edgeEnds[i] == ag->edgeStarts[fpSplice])
	assignToArray(exonStartEdges, eCount, exonStartCount++, i);
    }
if(exonStartCount == 0)
    tpSite =-1;
else
    tpSite = findMostCommonEdge(ag, exonStartEdges, exonStartCount);
freez(&exonStartEdges);
return tpSite;
}

int findDownEndFrom(struct altGraphX *ag, int tpSplice)
/* Given a three prime splice site, find the downstream five prime splice that
   makes an exon. Returns -1 if can't find any. */
{
int *exonEndEdges = NULL;
int exonEndCount = 0;
int eCount = ag->edgeCount;
int tpSite = 0;
int i;
AllocArray(exonEndEdges, eCount);
for(i = 0; i < eCount; i++)
    {
    if(ag->edgeStarts[i] == ag->edgeEnds[tpSplice])
	assignToArray(exonEndEdges, eCount, exonEndCount++, i);
    }
if(exonEndCount == 0)
    tpSite =-1;
else
    tpSite = findMostCommonEdge(ag, exonEndEdges, exonEndCount);
freez(&exonEndEdges);
return tpSite;
}

int getEvidenceCount(struct altGraphX *ag, int edge)
{
struct evidence *ev = slElementFromIx(ag->evidence, edge);
return ev->evCount;
}

struct bed *createBedFromEdges( struct altGraphX *ag, int fpEdge, int cassEdge, int tpEdge)
/* Put the edges together to from a bed structure. */
{
int *vPos = ag->vPositions;
int *starts = ag->edgeStarts;
int *ends = ag->edgeEnds;
struct bed *bed;
int numBlocks = 3;
AllocVar(bed);
bed->chrom = cloneString(ag->tName);
snprintf(bed->strand, sizeof(bed->strand), "%s", ag->strand);
bed->chromStart = bed->thickStart = vPos[starts[fpEdge]];
bed->chromEnd = bed->thickEnd = vPos[ends[tpEdge]];
bed->name = cloneString(ag->name);
bed->blockCount = numBlocks;
bed->blockSizes = AllocArray(bed->blockSizes, numBlocks);
bed->chromStarts = AllocArray(bed->chromStarts, numBlocks);
bed->blockSizes[0] = vPos[ends[fpEdge]] - vPos[starts[fpEdge]];
bed->blockSizes[1] = vPos[ends[cassEdge]] - vPos[starts[cassEdge]];
bed->blockSizes[2] = vPos[ends[tpEdge]] - vPos[starts[tpEdge]];
bed->chromStarts[0] = vPos[starts[fpEdge]] -bed->chromStart;
bed->chromStarts[1] = vPos[starts[cassEdge]] - bed->chromStart;
bed->chromStarts[2] = vPos[starts[tpEdge]] -bed->chromStart;
bed->score = getEvidenceCount(ag,fpEdge)+ getEvidenceCount(ag, tpEdge);

bed->expCount = numBlocks;
bed->expIds = AllocArray(bed->expIds, numBlocks);
bed->expScores = AllocArray(bed->expScores, numBlocks);
bed->expIds[0] = fpEdge;
bed->expIds[1] = cassEdge;
bed->expIds[2] = tpEdge;
return bed;
}

struct bed *altGraphGetExonCassette(struct altGraphX *ag, int eIx)
/* Get a bed which corresponds to the exons involved in a cassette exon. */
{
int eStart =0, eEnd = 0;
int *intStartEdges = NULL, *intEndEdges =NULL, *altEdges = NULL;
int intStartCount = 0, intEndCount =0, altCount =0;
int i,j,k;
int conf = 0;
int eCount = ag->edgeCount;
struct bed *bedList = NULL;
AllocArray(intStartEdges, ag->edgeCount);
AllocArray(intEndEdges, ag->edgeCount);
AllocArray(altEdges, ag->edgeCount);
eStart = ag->edgeStarts[eIx];
eEnd = ag->edgeEnds[eIx];
/* First find the introns that connect to our edge of interest. */
for(i = 0; i < ag->edgeCount; i++)
    {
    if(ag->edgeEnds[i] == eStart)
	assignToArray(intStartEdges, eCount, intStartCount++, i);
    if(ag->edgeStarts[i] == eEnd)
	assignToArray(intEndEdges, eCount, intEndCount++, i);
    }
/* for each intron that connects to our exon. */
for(i = 0; i < intStartCount; i++)
    {
    for(j =0; j < ag->edgeCount; j++)
	{
	/* Look for and edge that starts at the same place as our introns. */
	if(intStartEdges[i] != j && (ag->edgeStarts[j] == ag->edgeStarts[intStartEdges[i]]))
	    {
	    for(k=0; k < intEndCount; k++) 
		{
		/* Then connects to one of the same ends. */
		if(ag->edgeEnds[j] == ag->edgeEnds[intEndEdges[k]])
		    {
		    /* If it is new... */
		    if(uniqeInArray(altEdges, altCount, j))
			{
			struct bed *bed = NULL;
			int upStart = findUpStartFrom(ag, intStartEdges[i]);
			int downEnd = findDownEndFrom(ag, intEndEdges[k]);
			bed = createBedFromEdges(ag, upStart, eIx, downEnd);
			assignToArray(altEdges, eCount, altCount++, j);
			slAddHead(&bedList, bed);
			}
		    }
		}
	    }
	}
    }
freez(&altEdges);
freez(&intStartEdges);
freez(&intEndEdges);
return bedList;
}

int altGraphTimesNotSeenEdge(struct altGraphX *ag, int eIx) 
/* Discover how many times there is a transcript that uses an alternative
   to the edge eIx. */
{
int eStart =0, eEnd = 0;
int *intStartEdges = NULL, *intEndEdges =NULL, *altEdges = NULL;
int intStartCount = 0, intEndCount =0, altCount =0;
int i,j,k;
int conf = 0;
int eCount = ag->edgeCount;
AllocArray(intStartEdges, ag->edgeCount);
AllocArray(intEndEdges, ag->edgeCount);
AllocArray(altEdges, ag->edgeCount);
eStart = ag->edgeStarts[eIx];
eEnd = ag->edgeEnds[eIx];
/* First find the introns that connect to our edge of interest. */
for(i = 0; i < ag->edgeCount; i++)
    {
    if(ag->edgeEnds[i] == eStart)
	assignToArray(intStartEdges, eCount, intStartCount++, i);
    if(ag->edgeStarts[i] == eEnd)
	assignToArray(intEndEdges, eCount, intEndCount++, i);
    }

/* for each intron that connects to our exon. */
for(i = 0; i < intStartCount; i++)
    {
    for(j =0; j < ag->edgeCount; j++)
	{
	/* Look for and edge that starts at the same place as our introns. */
	if(intStartEdges[i] != j && (ag->edgeStarts[j] == ag->edgeStarts[intStartEdges[i]]))
	    {
	    for(k=0; k < intEndCount; k++) 
		{
		/* Then connects to one of the same ends. */
		if(ag->edgeEnds[j] == ag->edgeEnds[intEndEdges[k]])
		    if(uniqeInArray(altEdges, altCount, j))
			assignToArray(altEdges, eCount, altCount++, j);
		}
	    }
	}
    }

for(i=0; i< altCount; i++)
    {
    conf += altGraphTimesSeenEdge(ag, altEdges[i]);
    }
freez(&altEdges);
freez(&intStartEdges);
freez(&intEndEdges);
return conf;
}

float altGraphCassetteConfForEdge(struct altGraphX *ag, int eIx, float prior)
/* Return the score for this cassette exon. Want to have cassette exons
that are present in multiple transcripts and that are not present in multiple
exons. We want to see both forms of the cassette exon, we don't want to have
one outlier be chosen. Thus we count the times that the exon is seen, we
count the times that the exon isn't seen and we calculate a final score by:
(seen + notseen + prior)/(abs(seen - notSeen+prior) + 1) . Thus larger scores are better. */
{
int seen = altGraphTimesSeenEdge(ag, eIx);
int notSeen = altGraphTimesNotSeenEdge(ag, eIx);
float conf = 0;
conf = (float)(seen + notSeen + prior)/(float)(abs(seen - notSeen) + prior);
return conf;
}
