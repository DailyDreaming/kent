/* humPhen.c was originally generated by the autoSql program, which also 
 * generated humPhen.h and humPhen.sql.  This module links the database and
 * the RAM representation of objects. */

#include "common.h"
#include "linefile.h"
#include "dystring.h"
#include "jksql.h"
#include "humPhen.h"

static char const rcsid[] = "$Id: humPhen.c,v 1.1 2005/10/13 20:21:32 giardine Exp $";

void humanPhenotypeStaticLoad(char **row, struct humanPhenotype *ret)
/* Load a row from humanPhenotype table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->bin = sqlUnsigned(row[0]);
ret->chrom = row[1];
ret->chromStart = sqlUnsigned(row[2]);
ret->chromEnd = sqlUnsigned(row[3]);
ret->name = row[4];
ret->dbId = row[5];
ret->linkDbs = row[6];
ret->baseChangeType = row[7];
ret->location = row[8];
}

struct humanPhenotype *humanPhenotypeLoad(char **row)
/* Load a humanPhenotype from row fetched with select * from humanPhenotype
 * from database.  Dispose of this with humanPhenotypeFree(). */
{
struct humanPhenotype *ret;

AllocVar(ret);
ret->bin = sqlUnsigned(row[0]);
ret->chrom = cloneString(row[1]);
ret->chromStart = sqlUnsigned(row[2]);
ret->chromEnd = sqlUnsigned(row[3]);
ret->name = cloneString(row[4]);
ret->dbId = cloneString(row[5]);
ret->linkDbs = cloneString(row[6]);
ret->baseChangeType = cloneString(row[7]);
ret->location = cloneString(row[8]);
return ret;
}

struct humanPhenotype *humanPhenotypeLoadAll(char *fileName) 
/* Load all humanPhenotype from a whitespace-separated file.
 * Dispose of this with humanPhenotypeFreeList(). */
{
struct humanPhenotype *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[9];

while (lineFileRow(lf, row))
    {
    el = humanPhenotypeLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct humanPhenotype *humanPhenotypeLoadAllByChar(char *fileName, char chopper) 
/* Load all humanPhenotype from a chopper separated file.
 * Dispose of this with humanPhenotypeFreeList(). */
{
struct humanPhenotype *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[9];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = humanPhenotypeLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct humanPhenotype *humanPhenotypeLoadByQuery(struct sqlConnection *conn, char *query)
/* Load all humanPhenotype from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with humanPhenotypeFreeList(). */
{
struct humanPhenotype *list = NULL, *el;
struct sqlResult *sr;
char **row;

sr = sqlGetResult(conn, query);
while ((row = sqlNextRow(sr)) != NULL)
    {
    el = humanPhenotypeLoad(row);
    slAddHead(&list, el);
    }
slReverse(&list);
sqlFreeResult(&sr);
return list;
}

void humanPhenotypeSaveToDb(struct sqlConnection *conn, struct humanPhenotype *el, char *tableName, int updateSize)
/* Save humanPhenotype as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use humanPhenotypeSaveToDbEscaped() */
{
struct dyString *update = newDyString(updateSize);
dyStringPrintf(update, "insert into %s values ( %u,'%s',%u,%u,'%s','%s','%s','%s','%s')", 
	tableName,  el->bin,  el->chrom,  el->chromStart,  el->chromEnd,  el->name,  el->dbId,  el->linkDbs,  el->baseChangeType,  el->location);
sqlUpdate(conn, update->string);
freeDyString(&update);
}

void humanPhenotypeSaveToDbEscaped(struct sqlConnection *conn, struct humanPhenotype *el, char *tableName, int updateSize)
/* Save humanPhenotype as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than humanPhenotypeSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 
{
struct dyString *update = newDyString(updateSize);
char  *chrom, *name, *dbId, *linkDbs, *baseChangeType, *location;
chrom = sqlEscapeString(el->chrom);
name = sqlEscapeString(el->name);
dbId = sqlEscapeString(el->dbId);
linkDbs = sqlEscapeString(el->linkDbs);
baseChangeType = sqlEscapeString(el->baseChangeType);
location = sqlEscapeString(el->location);

dyStringPrintf(update, "insert into %s values ( %u,'%s',%u,%u,'%s','%s','%s','%s','%s')", 
	tableName, el->bin ,  chrom, el->chromStart , el->chromEnd ,  name,  dbId,  linkDbs,  baseChangeType,  location);
sqlUpdate(conn, update->string);
freeDyString(&update);
freez(&chrom);
freez(&name);
freez(&dbId);
freez(&linkDbs);
freez(&baseChangeType);
freez(&location);
}

struct humanPhenotype *humanPhenotypeCommaIn(char **pS, struct humanPhenotype *ret)
/* Create a humanPhenotype out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new humanPhenotype */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->bin = sqlUnsignedComma(&s);
ret->chrom = sqlStringComma(&s);
ret->chromStart = sqlUnsignedComma(&s);
ret->chromEnd = sqlUnsignedComma(&s);
ret->name = sqlStringComma(&s);
ret->dbId = sqlStringComma(&s);
ret->linkDbs = sqlStringComma(&s);
ret->baseChangeType = sqlStringComma(&s);
ret->location = sqlStringComma(&s);
*pS = s;
return ret;
}

void humanPhenotypeFree(struct humanPhenotype **pEl)
/* Free a single dynamically allocated humanPhenotype such as created
 * with humanPhenotypeLoad(). */
{
struct humanPhenotype *el;

if ((el = *pEl) == NULL) return;
freeMem(el->chrom);
freeMem(el->name);
freeMem(el->dbId);
freeMem(el->linkDbs);
freeMem(el->baseChangeType);
freeMem(el->location);
freez(pEl);
}

void humanPhenotypeFreeList(struct humanPhenotype **pList)
/* Free a list of dynamically allocated humanPhenotype's */
{
struct humanPhenotype *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    humanPhenotypeFree(&el);
    }
*pList = NULL;
}

void humanPhenotypeOutput(struct humanPhenotype *el, FILE *f, char sep, char lastSep) 
/* Print out humanPhenotype.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->bin);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->chrom);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%u", el->chromStart);
fputc(sep,f);
fprintf(f, "%u", el->chromEnd);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->name);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->dbId);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->linkDbs);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->baseChangeType);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->location);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void humPhenLinkStaticLoad(char **row, struct humPhenLink *ret)
/* Load a row from humPhenLink table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->linkDb = row[0];
ret->linkDisplayName = row[1];
ret->url = row[2];
}

struct humPhenLink *humPhenLinkLoad(char **row)
/* Load a humPhenLink from row fetched with select * from humPhenLink
 * from database.  Dispose of this with humPhenLinkFree(). */
{
struct humPhenLink *ret;

AllocVar(ret);
ret->linkDb = cloneString(row[0]);
ret->linkDisplayName = cloneString(row[1]);
ret->url = cloneString(row[2]);
return ret;
}

struct humPhenLink *humPhenLinkLoadAll(char *fileName) 
/* Load all humPhenLink from a whitespace-separated file.
 * Dispose of this with humPhenLinkFreeList(). */
{
struct humPhenLink *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[3];

while (lineFileRow(lf, row))
    {
    el = humPhenLinkLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct humPhenLink *humPhenLinkLoadAllByChar(char *fileName, char chopper) 
/* Load all humPhenLink from a chopper separated file.
 * Dispose of this with humPhenLinkFreeList(). */
{
struct humPhenLink *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[3];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = humPhenLinkLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct humPhenLink *humPhenLinkLoadByQuery(struct sqlConnection *conn, char *query)
/* Load all humPhenLink from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with humPhenLinkFreeList(). */
{
struct humPhenLink *list = NULL, *el;
struct sqlResult *sr;
char **row;

sr = sqlGetResult(conn, query);
while ((row = sqlNextRow(sr)) != NULL)
    {
    el = humPhenLinkLoad(row);
    slAddHead(&list, el);
    }
slReverse(&list);
sqlFreeResult(&sr);
return list;
}

void humPhenLinkSaveToDb(struct sqlConnection *conn, struct humPhenLink *el, char *tableName, int updateSize)
/* Save humPhenLink as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use humPhenLinkSaveToDbEscaped() */
{
struct dyString *update = newDyString(updateSize);
dyStringPrintf(update, "insert into %s values ( '%s','%s','%s')", 
	tableName,  el->linkDb,  el->linkDisplayName,  el->url);
sqlUpdate(conn, update->string);
freeDyString(&update);
}

void humPhenLinkSaveToDbEscaped(struct sqlConnection *conn, struct humPhenLink *el, char *tableName, int updateSize)
/* Save humPhenLink as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than humPhenLinkSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 
{
struct dyString *update = newDyString(updateSize);
char  *linkDb, *linkDisplayName, *url;
linkDb = sqlEscapeString(el->linkDb);
linkDisplayName = sqlEscapeString(el->linkDisplayName);
url = sqlEscapeString(el->url);

dyStringPrintf(update, "insert into %s values ( '%s','%s','%s')", 
	tableName,  linkDb,  linkDisplayName,  url);
sqlUpdate(conn, update->string);
freeDyString(&update);
freez(&linkDb);
freez(&linkDisplayName);
freez(&url);
}

struct humPhenLink *humPhenLinkCommaIn(char **pS, struct humPhenLink *ret)
/* Create a humPhenLink out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new humPhenLink */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->linkDb = sqlStringComma(&s);
ret->linkDisplayName = sqlStringComma(&s);
ret->url = sqlStringComma(&s);
*pS = s;
return ret;
}

void humPhenLinkFree(struct humPhenLink **pEl)
/* Free a single dynamically allocated humPhenLink such as created
 * with humPhenLinkLoad(). */
{
struct humPhenLink *el;

if ((el = *pEl) == NULL) return;
freeMem(el->linkDb);
freeMem(el->linkDisplayName);
freeMem(el->url);
freez(pEl);
}

void humPhenLinkFreeList(struct humPhenLink **pList)
/* Free a list of dynamically allocated humPhenLink's */
{
struct humPhenLink *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    humPhenLinkFree(&el);
    }
*pList = NULL;
}

void humPhenLinkOutput(struct humPhenLink *el, FILE *f, char sep, char lastSep) 
/* Print out humPhenLink.  Separate fields with sep. Follow last field with lastSep. */
{
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->linkDb);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->linkDisplayName);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->url);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void humPhenAliasStaticLoad(char **row, struct humPhenAlias *ret)
/* Load a row from humPhenAlias table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->dbId = row[0];
ret->name = row[1];
}

struct humPhenAlias *humPhenAliasLoad(char **row)
/* Load a humPhenAlias from row fetched with select * from humPhenAlias
 * from database.  Dispose of this with humPhenAliasFree(). */
{
struct humPhenAlias *ret;

AllocVar(ret);
ret->dbId = cloneString(row[0]);
ret->name = cloneString(row[1]);
return ret;
}

struct humPhenAlias *humPhenAliasLoadAll(char *fileName) 
/* Load all humPhenAlias from a whitespace-separated file.
 * Dispose of this with humPhenAliasFreeList(). */
{
struct humPhenAlias *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[2];

while (lineFileRow(lf, row))
    {
    el = humPhenAliasLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct humPhenAlias *humPhenAliasLoadAllByChar(char *fileName, char chopper) 
/* Load all humPhenAlias from a chopper separated file.
 * Dispose of this with humPhenAliasFreeList(). */
{
struct humPhenAlias *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[2];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = humPhenAliasLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct humPhenAlias *humPhenAliasLoadByQuery(struct sqlConnection *conn, char *query)
/* Load all humPhenAlias from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with humPhenAliasFreeList(). */
{
struct humPhenAlias *list = NULL, *el;
struct sqlResult *sr;
char **row;

sr = sqlGetResult(conn, query);
while ((row = sqlNextRow(sr)) != NULL)
    {
    el = humPhenAliasLoad(row);
    slAddHead(&list, el);
    }
slReverse(&list);
sqlFreeResult(&sr);
return list;
}

void humPhenAliasSaveToDb(struct sqlConnection *conn, struct humPhenAlias *el, char *tableName, int updateSize)
/* Save humPhenAlias as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use humPhenAliasSaveToDbEscaped() */
{
struct dyString *update = newDyString(updateSize);
dyStringPrintf(update, "insert into %s values ( '%s','%s')", 
	tableName,  el->dbId,  el->name);
sqlUpdate(conn, update->string);
freeDyString(&update);
}

void humPhenAliasSaveToDbEscaped(struct sqlConnection *conn, struct humPhenAlias *el, char *tableName, int updateSize)
/* Save humPhenAlias as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than humPhenAliasSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 
{
struct dyString *update = newDyString(updateSize);
char  *dbId, *name;
dbId = sqlEscapeString(el->dbId);
name = sqlEscapeString(el->name);

dyStringPrintf(update, "insert into %s values ( '%s','%s')", 
	tableName,  dbId,  name);
sqlUpdate(conn, update->string);
freeDyString(&update);
freez(&dbId);
freez(&name);
}

struct humPhenAlias *humPhenAliasCommaIn(char **pS, struct humPhenAlias *ret)
/* Create a humPhenAlias out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new humPhenAlias */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->dbId = sqlStringComma(&s);
ret->name = sqlStringComma(&s);
*pS = s;
return ret;
}

void humPhenAliasFree(struct humPhenAlias **pEl)
/* Free a single dynamically allocated humPhenAlias such as created
 * with humPhenAliasLoad(). */
{
struct humPhenAlias *el;

if ((el = *pEl) == NULL) return;
freeMem(el->dbId);
freeMem(el->name);
freez(pEl);
}

void humPhenAliasFreeList(struct humPhenAlias **pList)
/* Free a list of dynamically allocated humPhenAlias's */
{
struct humPhenAlias *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    humPhenAliasFree(&el);
    }
*pList = NULL;
}

void humPhenAliasOutput(struct humPhenAlias *el, FILE *f, char sep, char lastSep) 
/* Print out humPhenAlias.  Separate fields with sep. Follow last field with lastSep. */
{
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->dbId);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->name);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

/* -------------------------------- End autoSql Generated Code -------------------------------- */

