/* humPhen.c was originally generated by the autoSql program, which also 
 * generated humPhen.h and humPhen.sql.  This module links the database and
 * the RAM representation of objects. */

#include "common.h"
#include "linefile.h"
#include "dystring.h"
#include "jksql.h"
#include "humPhen.h"

static char const rcsid[] = "$Id: humPhen.c,v 1.2 2005/11/04 16:06:56 giardine Exp $";

void humanPhenotypeLSDBStaticLoad(char **row, struct humanPhenotypeLSDB *ret)
/* Load a row from humanPhenotypeLSDB table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->bin = sqlUnsigned(row[0]);
ret->chrom = row[1];
ret->chromStart = sqlUnsigned(row[2]);
ret->chromEnd = sqlUnsigned(row[3]);
ret->name = row[4];
ret->dbId = row[5];
ret->linkDbs = row[6];
ret->baseChangeType = row[7];
ret->location = row[8];
}

struct humanPhenotypeLSDB *humanPhenotypeLSDBLoad(char **row)
/* Load a humanPhenotypeLSDB from row fetched with select * from humanPhenotypeLSDB
 * from database.  Dispose of this with humanPhenotypeLSDBFree(). */
{
struct humanPhenotypeLSDB *ret;

AllocVar(ret);
ret->bin = sqlUnsigned(row[0]);
ret->chrom = cloneString(row[1]);
ret->chromStart = sqlUnsigned(row[2]);
ret->chromEnd = sqlUnsigned(row[3]);
ret->name = cloneString(row[4]);
ret->dbId = cloneString(row[5]);
ret->linkDbs = cloneString(row[6]);
ret->baseChangeType = cloneString(row[7]);
ret->location = cloneString(row[8]);
return ret;
}

struct humanPhenotypeLSDB *humanPhenotypeLSDBLoadAll(char *fileName) 
/* Load all humanPhenotypeLSDB from a whitespace-separated file.
 * Dispose of this with humanPhenotypeLSDBFreeList(). */
{
struct humanPhenotypeLSDB *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[9];

while (lineFileRow(lf, row))
    {
    el = humanPhenotypeLSDBLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct humanPhenotypeLSDB *humanPhenotypeLSDBLoadAllByChar(char *fileName, char chopper) 
/* Load all humanPhenotypeLSDB from a chopper separated file.
 * Dispose of this with humanPhenotypeLSDBFreeList(). */
{
struct humanPhenotypeLSDB *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[9];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = humanPhenotypeLSDBLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct humanPhenotypeLSDB *humanPhenotypeLSDBLoadByQuery(struct sqlConnection *conn, char *query)
/* Load all humanPhenotypeLSDB from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with humanPhenotypeLSDBFreeList(). */
{
struct humanPhenotypeLSDB *list = NULL, *el;
struct sqlResult *sr;
char **row;

sr = sqlGetResult(conn, query);
while ((row = sqlNextRow(sr)) != NULL)
    {
    el = humanPhenotypeLSDBLoad(row);
    slAddHead(&list, el);
    }
slReverse(&list);
sqlFreeResult(&sr);
return list;
}

void humanPhenotypeLSDBSaveToDb(struct sqlConnection *conn, struct humanPhenotypeLSDB *el, char *tableName, int updateSize)
/* Save humanPhenotypeLSDB as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use humanPhenotypeLSDBSaveToDbEscaped() */
{
struct dyString *update = newDyString(updateSize);
dyStringPrintf(update, "insert into %s values ( %u,'%s',%u,%u,'%s','%s','%s','%s','%s')", 
	tableName,  el->bin,  el->chrom,  el->chromStart,  el->chromEnd,  el->name,  el->dbId,  el->linkDbs,  el->baseChangeType,  el->location);
sqlUpdate(conn, update->string);
freeDyString(&update);
}

void humanPhenotypeLSDBSaveToDbEscaped(struct sqlConnection *conn, struct humanPhenotypeLSDB *el, char *tableName, int updateSize)
/* Save humanPhenotypeLSDB as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than humanPhenotypeLSDBSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 
{
struct dyString *update = newDyString(updateSize);
char  *chrom, *name, *dbId, *linkDbs, *baseChangeType, *location;
chrom = sqlEscapeString(el->chrom);
name = sqlEscapeString(el->name);
dbId = sqlEscapeString(el->dbId);
linkDbs = sqlEscapeString(el->linkDbs);
baseChangeType = sqlEscapeString(el->baseChangeType);
location = sqlEscapeString(el->location);

dyStringPrintf(update, "insert into %s values ( %u,'%s',%u,%u,'%s','%s','%s','%s','%s')", 
	tableName, el->bin ,  chrom, el->chromStart , el->chromEnd ,  name,  dbId,  linkDbs,  baseChangeType,  location);
sqlUpdate(conn, update->string);
freeDyString(&update);
freez(&chrom);
freez(&name);
freez(&dbId);
freez(&linkDbs);
freez(&baseChangeType);
freez(&location);
}

struct humanPhenotypeLSDB *humanPhenotypeLSDBCommaIn(char **pS, struct humanPhenotypeLSDB *ret)
/* Create a humanPhenotypeLSDB out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new humanPhenotypeLSDB */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->bin = sqlUnsignedComma(&s);
ret->chrom = sqlStringComma(&s);
ret->chromStart = sqlUnsignedComma(&s);
ret->chromEnd = sqlUnsignedComma(&s);
ret->name = sqlStringComma(&s);
ret->dbId = sqlStringComma(&s);
ret->linkDbs = sqlStringComma(&s);
ret->baseChangeType = sqlStringComma(&s);
ret->location = sqlStringComma(&s);
*pS = s;
return ret;
}

void humanPhenotypeLSDBFree(struct humanPhenotypeLSDB **pEl)
/* Free a single dynamically allocated humanPhenotypeLSDB such as created
 * with humanPhenotypeLSDBLoad(). */
{
struct humanPhenotypeLSDB *el;

if ((el = *pEl) == NULL) return;
freeMem(el->chrom);
freeMem(el->name);
freeMem(el->dbId);
freeMem(el->linkDbs);
freeMem(el->baseChangeType);
freeMem(el->location);
freez(pEl);
}

void humanPhenotypeLSDBFreeList(struct humanPhenotypeLSDB **pList)
/* Free a list of dynamically allocated humanPhenotypeLSDB's */
{
struct humanPhenotypeLSDB *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    humanPhenotypeLSDBFree(&el);
    }
*pList = NULL;
}

void humanPhenotypeLSDBOutput(struct humanPhenotypeLSDB *el, FILE *f, char sep, char lastSep) 
/* Print out humanPhenotypeLSDB.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->bin);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->chrom);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%u", el->chromStart);
fputc(sep,f);
fprintf(f, "%u", el->chromEnd);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->name);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->dbId);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->linkDbs);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->baseChangeType);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->location);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void humanPhenotypeSPStaticLoad(char **row, struct humanPhenotypeSP *ret)
/* Load a row from humanPhenotypeSP table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->bin = sqlUnsigned(row[0]);
ret->chrom = row[1];
ret->chromStart = sqlUnsigned(row[2]);
ret->chromEnd = sqlUnsigned(row[3]);
ret->name = row[4];
ret->dbId = row[5];
ret->linkDbs = row[6];
ret->baseChangeType = row[7];
ret->location = row[8];
}

struct humanPhenotypeSP *humanPhenotypeSPLoad(char **row)
/* Load a humanPhenotypeSP from row fetched with select * from humanPhenotypeSP
 * from database.  Dispose of this with humanPhenotypeSPFree(). */
{
struct humanPhenotypeSP *ret;

AllocVar(ret);
ret->bin = sqlUnsigned(row[0]);
ret->chrom = cloneString(row[1]);
ret->chromStart = sqlUnsigned(row[2]);
ret->chromEnd = sqlUnsigned(row[3]);
ret->name = cloneString(row[4]);
ret->dbId = cloneString(row[5]);
ret->linkDbs = cloneString(row[6]);
ret->baseChangeType = cloneString(row[7]);
ret->location = cloneString(row[8]);
return ret;
}

struct humanPhenotypeSP *humanPhenotypeSPLoadAll(char *fileName) 
/* Load all humanPhenotypeSP from a whitespace-separated file.
 * Dispose of this with humanPhenotypeSPFreeList(). */
{
struct humanPhenotypeSP *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[9];

while (lineFileRow(lf, row))
    {
    el = humanPhenotypeSPLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct humanPhenotypeSP *humanPhenotypeSPLoadAllByChar(char *fileName, char chopper) 
/* Load all humanPhenotypeSP from a chopper separated file.
 * Dispose of this with humanPhenotypeSPFreeList(). */
{
struct humanPhenotypeSP *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[9];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = humanPhenotypeSPLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct humanPhenotypeSP *humanPhenotypeSPLoadByQuery(struct sqlConnection *conn, char *query)
/* Load all humanPhenotypeSP from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with humanPhenotypeSPFreeList(). */
{
struct humanPhenotypeSP *list = NULL, *el;
struct sqlResult *sr;
char **row;

sr = sqlGetResult(conn, query);
while ((row = sqlNextRow(sr)) != NULL)
    {
    el = humanPhenotypeSPLoad(row);
    slAddHead(&list, el);
    }
slReverse(&list);
sqlFreeResult(&sr);
return list;
}

void humanPhenotypeSPSaveToDb(struct sqlConnection *conn, struct humanPhenotypeSP *el, char *tableName, int updateSize)
/* Save humanPhenotypeSP as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use humanPhenotypeSPSaveToDbEscaped() */
{
struct dyString *update = newDyString(updateSize);
dyStringPrintf(update, "insert into %s values ( %u,'%s',%u,%u,'%s','%s','%s','%s','%s')", 
	tableName,  el->bin,  el->chrom,  el->chromStart,  el->chromEnd,  el->name,  el->dbId,  el->linkDbs,  el->baseChangeType,  el->location);
sqlUpdate(conn, update->string);
freeDyString(&update);
}

void humanPhenotypeSPSaveToDbEscaped(struct sqlConnection *conn, struct humanPhenotypeSP *el, char *tableName, int updateSize)
/* Save humanPhenotypeSP as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than humanPhenotypeSPSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 
{
struct dyString *update = newDyString(updateSize);
char  *chrom, *name, *dbId, *linkDbs, *baseChangeType, *location;
chrom = sqlEscapeString(el->chrom);
name = sqlEscapeString(el->name);
dbId = sqlEscapeString(el->dbId);
linkDbs = sqlEscapeString(el->linkDbs);
baseChangeType = sqlEscapeString(el->baseChangeType);
location = sqlEscapeString(el->location);

dyStringPrintf(update, "insert into %s values ( %u,'%s',%u,%u,'%s','%s','%s','%s','%s')", 
	tableName, el->bin ,  chrom, el->chromStart , el->chromEnd ,  name,  dbId,  linkDbs,  baseChangeType,  location);
sqlUpdate(conn, update->string);
freeDyString(&update);
freez(&chrom);
freez(&name);
freez(&dbId);
freez(&linkDbs);
freez(&baseChangeType);
freez(&location);
}

struct humanPhenotypeSP *humanPhenotypeSPCommaIn(char **pS, struct humanPhenotypeSP *ret)
/* Create a humanPhenotypeSP out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new humanPhenotypeSP */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->bin = sqlUnsignedComma(&s);
ret->chrom = sqlStringComma(&s);
ret->chromStart = sqlUnsignedComma(&s);
ret->chromEnd = sqlUnsignedComma(&s);
ret->name = sqlStringComma(&s);
ret->dbId = sqlStringComma(&s);
ret->linkDbs = sqlStringComma(&s);
ret->baseChangeType = sqlStringComma(&s);
ret->location = sqlStringComma(&s);
*pS = s;
return ret;
}

void humanPhenotypeSPFree(struct humanPhenotypeSP **pEl)
/* Free a single dynamically allocated humanPhenotypeSP such as created
 * with humanPhenotypeSPLoad(). */
{
struct humanPhenotypeSP *el;

if ((el = *pEl) == NULL) return;
freeMem(el->chrom);
freeMem(el->name);
freeMem(el->dbId);
freeMem(el->linkDbs);
freeMem(el->baseChangeType);
freeMem(el->location);
freez(pEl);
}

void humanPhenotypeSPFreeList(struct humanPhenotypeSP **pList)
/* Free a list of dynamically allocated humanPhenotypeSP's */
{
struct humanPhenotypeSP *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    humanPhenotypeSPFree(&el);
    }
*pList = NULL;
}

void humanPhenotypeSPOutput(struct humanPhenotypeSP *el, FILE *f, char sep, char lastSep) 
/* Print out humanPhenotypeSP.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->bin);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->chrom);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%u", el->chromStart);
fputc(sep,f);
fprintf(f, "%u", el->chromEnd);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->name);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->dbId);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->linkDbs);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->baseChangeType);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->location);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void humPhenLinkStaticLoad(char **row, struct humPhenLink *ret)
/* Load a row from humPhenLink table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->linkDb = row[0];
ret->linkDisplayName = row[1];
ret->url = row[2];
}

struct humPhenLink *humPhenLinkLoad(char **row)
/* Load a humPhenLink from row fetched with select * from humPhenLink
 * from database.  Dispose of this with humPhenLinkFree(). */
{
struct humPhenLink *ret;

AllocVar(ret);
ret->linkDb = cloneString(row[0]);
ret->linkDisplayName = cloneString(row[1]);
ret->url = cloneString(row[2]);
return ret;
}

struct humPhenLink *humPhenLinkLoadAll(char *fileName) 
/* Load all humPhenLink from a whitespace-separated file.
 * Dispose of this with humPhenLinkFreeList(). */
{
struct humPhenLink *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[3];

while (lineFileRow(lf, row))
    {
    el = humPhenLinkLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct humPhenLink *humPhenLinkLoadAllByChar(char *fileName, char chopper) 
/* Load all humPhenLink from a chopper separated file.
 * Dispose of this with humPhenLinkFreeList(). */
{
struct humPhenLink *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[3];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = humPhenLinkLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct humPhenLink *humPhenLinkLoadByQuery(struct sqlConnection *conn, char *query)
/* Load all humPhenLink from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with humPhenLinkFreeList(). */
{
struct humPhenLink *list = NULL, *el;
struct sqlResult *sr;
char **row;

sr = sqlGetResult(conn, query);
while ((row = sqlNextRow(sr)) != NULL)
    {
    el = humPhenLinkLoad(row);
    slAddHead(&list, el);
    }
slReverse(&list);
sqlFreeResult(&sr);
return list;
}

void humPhenLinkSaveToDb(struct sqlConnection *conn, struct humPhenLink *el, char *tableName, int updateSize)
/* Save humPhenLink as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use humPhenLinkSaveToDbEscaped() */
{
struct dyString *update = newDyString(updateSize);
dyStringPrintf(update, "insert into %s values ( '%s','%s','%s')", 
	tableName,  el->linkDb,  el->linkDisplayName,  el->url);
sqlUpdate(conn, update->string);
freeDyString(&update);
}

void humPhenLinkSaveToDbEscaped(struct sqlConnection *conn, struct humPhenLink *el, char *tableName, int updateSize)
/* Save humPhenLink as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than humPhenLinkSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 
{
struct dyString *update = newDyString(updateSize);
char  *linkDb, *linkDisplayName, *url;
linkDb = sqlEscapeString(el->linkDb);
linkDisplayName = sqlEscapeString(el->linkDisplayName);
url = sqlEscapeString(el->url);

dyStringPrintf(update, "insert into %s values ( '%s','%s','%s')", 
	tableName,  linkDb,  linkDisplayName,  url);
sqlUpdate(conn, update->string);
freeDyString(&update);
freez(&linkDb);
freez(&linkDisplayName);
freez(&url);
}

struct humPhenLink *humPhenLinkCommaIn(char **pS, struct humPhenLink *ret)
/* Create a humPhenLink out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new humPhenLink */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->linkDb = sqlStringComma(&s);
ret->linkDisplayName = sqlStringComma(&s);
ret->url = sqlStringComma(&s);
*pS = s;
return ret;
}

void humPhenLinkFree(struct humPhenLink **pEl)
/* Free a single dynamically allocated humPhenLink such as created
 * with humPhenLinkLoad(). */
{
struct humPhenLink *el;

if ((el = *pEl) == NULL) return;
freeMem(el->linkDb);
freeMem(el->linkDisplayName);
freeMem(el->url);
freez(pEl);
}

void humPhenLinkFreeList(struct humPhenLink **pList)
/* Free a list of dynamically allocated humPhenLink's */
{
struct humPhenLink *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    humPhenLinkFree(&el);
    }
*pList = NULL;
}

void humPhenLinkOutput(struct humPhenLink *el, FILE *f, char sep, char lastSep) 
/* Print out humPhenLink.  Separate fields with sep. Follow last field with lastSep. */
{
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->linkDb);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->linkDisplayName);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->url);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void humPhenAliasStaticLoad(char **row, struct humPhenAlias *ret)
/* Load a row from humPhenAlias table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->dbId = row[0];
ret->name = row[1];
}

struct humPhenAlias *humPhenAliasLoad(char **row)
/* Load a humPhenAlias from row fetched with select * from humPhenAlias
 * from database.  Dispose of this with humPhenAliasFree(). */
{
struct humPhenAlias *ret;

AllocVar(ret);
ret->dbId = cloneString(row[0]);
ret->name = cloneString(row[1]);
return ret;
}

struct humPhenAlias *humPhenAliasLoadAll(char *fileName) 
/* Load all humPhenAlias from a whitespace-separated file.
 * Dispose of this with humPhenAliasFreeList(). */
{
struct humPhenAlias *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[2];

while (lineFileRow(lf, row))
    {
    el = humPhenAliasLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct humPhenAlias *humPhenAliasLoadAllByChar(char *fileName, char chopper) 
/* Load all humPhenAlias from a chopper separated file.
 * Dispose of this with humPhenAliasFreeList(). */
{
struct humPhenAlias *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[2];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = humPhenAliasLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct humPhenAlias *humPhenAliasLoadByQuery(struct sqlConnection *conn, char *query)
/* Load all humPhenAlias from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with humPhenAliasFreeList(). */
{
struct humPhenAlias *list = NULL, *el;
struct sqlResult *sr;
char **row;

sr = sqlGetResult(conn, query);
while ((row = sqlNextRow(sr)) != NULL)
    {
    el = humPhenAliasLoad(row);
    slAddHead(&list, el);
    }
slReverse(&list);
sqlFreeResult(&sr);
return list;
}

void humPhenAliasSaveToDb(struct sqlConnection *conn, struct humPhenAlias *el, char *tableName, int updateSize)
/* Save humPhenAlias as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use humPhenAliasSaveToDbEscaped() */
{
struct dyString *update = newDyString(updateSize);
dyStringPrintf(update, "insert into %s values ( '%s','%s')", 
	tableName,  el->dbId,  el->name);
sqlUpdate(conn, update->string);
freeDyString(&update);
}

void humPhenAliasSaveToDbEscaped(struct sqlConnection *conn, struct humPhenAlias *el, char *tableName, int updateSize)
/* Save humPhenAlias as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than humPhenAliasSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 
{
struct dyString *update = newDyString(updateSize);
char  *dbId, *name;
dbId = sqlEscapeString(el->dbId);
name = sqlEscapeString(el->name);

dyStringPrintf(update, "insert into %s values ( '%s','%s')", 
	tableName,  dbId,  name);
sqlUpdate(conn, update->string);
freeDyString(&update);
freez(&dbId);
freez(&name);
}

struct humPhenAlias *humPhenAliasCommaIn(char **pS, struct humPhenAlias *ret)
/* Create a humPhenAlias out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new humPhenAlias */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->dbId = sqlStringComma(&s);
ret->name = sqlStringComma(&s);
*pS = s;
return ret;
}

void humPhenAliasFree(struct humPhenAlias **pEl)
/* Free a single dynamically allocated humPhenAlias such as created
 * with humPhenAliasLoad(). */
{
struct humPhenAlias *el;

if ((el = *pEl) == NULL) return;
freeMem(el->dbId);
freeMem(el->name);
freez(pEl);
}

void humPhenAliasFreeList(struct humPhenAlias **pList)
/* Free a list of dynamically allocated humPhenAlias's */
{
struct humPhenAlias *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    humPhenAliasFree(&el);
    }
*pList = NULL;
}

void humPhenAliasOutput(struct humPhenAlias *el, FILE *f, char sep, char lastSep) 
/* Print out humPhenAlias.  Separate fields with sep. Follow last field with lastSep. */
{
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->dbId);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->name);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void humPhenEthnicStaticLoad(char **row, struct humPhenEthnic *ret)
/* Load a row from humPhenEthnic table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->dbId = row[0];
ret->ethnic = row[1];
}

struct humPhenEthnic *humPhenEthnicLoad(char **row)
/* Load a humPhenEthnic from row fetched with select * from humPhenEthnic
 * from database.  Dispose of this with humPhenEthnicFree(). */
{
struct humPhenEthnic *ret;

AllocVar(ret);
ret->dbId = cloneString(row[0]);
ret->ethnic = cloneString(row[1]);
return ret;
}

struct humPhenEthnic *humPhenEthnicLoadAll(char *fileName) 
/* Load all humPhenEthnic from a whitespace-separated file.
 * Dispose of this with humPhenEthnicFreeList(). */
{
struct humPhenEthnic *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[2];

while (lineFileRow(lf, row))
    {
    el = humPhenEthnicLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct humPhenEthnic *humPhenEthnicLoadAllByChar(char *fileName, char chopper) 
/* Load all humPhenEthnic from a chopper separated file.
 * Dispose of this with humPhenEthnicFreeList(). */
{
struct humPhenEthnic *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[2];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = humPhenEthnicLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct humPhenEthnic *humPhenEthnicLoadByQuery(struct sqlConnection *conn, char *query)
/* Load all humPhenEthnic from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with humPhenEthnicFreeList(). */
{
struct humPhenEthnic *list = NULL, *el;
struct sqlResult *sr;
char **row;

sr = sqlGetResult(conn, query);
while ((row = sqlNextRow(sr)) != NULL)
    {
    el = humPhenEthnicLoad(row);
    slAddHead(&list, el);
    }
slReverse(&list);
sqlFreeResult(&sr);
return list;
}

void humPhenEthnicSaveToDb(struct sqlConnection *conn, struct humPhenEthnic *el, char *tableName, int updateSize)
/* Save humPhenEthnic as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use humPhenEthnicSaveToDbEscaped() */
{
struct dyString *update = newDyString(updateSize);
dyStringPrintf(update, "insert into %s values ( '%s','%s')", 
	tableName,  el->dbId,  el->ethnic);
sqlUpdate(conn, update->string);
freeDyString(&update);
}

void humPhenEthnicSaveToDbEscaped(struct sqlConnection *conn, struct humPhenEthnic *el, char *tableName, int updateSize)
/* Save humPhenEthnic as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than humPhenEthnicSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 
{
struct dyString *update = newDyString(updateSize);
char  *dbId, *ethnic;
dbId = sqlEscapeString(el->dbId);
ethnic = sqlEscapeString(el->ethnic);

dyStringPrintf(update, "insert into %s values ( '%s','%s')", 
	tableName,  dbId,  ethnic);
sqlUpdate(conn, update->string);
freeDyString(&update);
freez(&dbId);
freez(&ethnic);
}

struct humPhenEthnic *humPhenEthnicCommaIn(char **pS, struct humPhenEthnic *ret)
/* Create a humPhenEthnic out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new humPhenEthnic */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->dbId = sqlStringComma(&s);
ret->ethnic = sqlStringComma(&s);
*pS = s;
return ret;
}

void humPhenEthnicFree(struct humPhenEthnic **pEl)
/* Free a single dynamically allocated humPhenEthnic such as created
 * with humPhenEthnicLoad(). */
{
struct humPhenEthnic *el;

if ((el = *pEl) == NULL) return;
freeMem(el->dbId);
freeMem(el->ethnic);
freez(pEl);
}

void humPhenEthnicFreeList(struct humPhenEthnic **pList)
/* Free a list of dynamically allocated humPhenEthnic's */
{
struct humPhenEthnic *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    humPhenEthnicFree(&el);
    }
*pList = NULL;
}

void humPhenEthnicOutput(struct humPhenEthnic *el, FILE *f, char sep, char lastSep) 
/* Print out humPhenEthnic.  Separate fields with sep. Follow last field with lastSep. */
{
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->dbId);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->ethnic);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

/* -------------------------------- End autoSql Generated Code -------------------------------- */

