flow ugly(string s)
    {
    print(s);
    }

class htmlStatus
// HTTP version and status code.
    {
    string version="HTTP/1.1";	// HTTP protocal version
    int status=200;		// HTTP status code. 200 means A-OK.
    }

class htmlCookie
// A cookie - stored by the browser usually.  We need to
// echo it back when we post forms.
    {
    string name;	// Cookie name.
    string value;	// Cookie value.
    string domain;	// The set of web domains the cookie applies to.
    string path;	// The cookie applies below this path I guess.
    string expires;	// Expiration date.
    bit secure;		// Is it a secure coookie?
    }

class htmlTag
// An HTML tag - includes attribute list but no text.
    {
    string name;			// Tag name.
    dir of string attributes;		// All attributes. May be nil
    int start;			// Start position within htmlPage.fullText
    int end;			// End position (one past closing '>')
    }

class htmlFormVar
// A variable within an html form. Associated with a button, input tag etc.
    {
    string name;	// Variable name.
    string type;	// Variable type.
    string value;	// Current value if any. May be nil.
    array of string values;  // Available values for some types, nil for others.
    string tagName;	     // Name of associated tag.
    array of htmlTag tags;   // Associated html tags.
    }

class htmlForm
// A form within an html page.
    {
    string name;	 // Name (nil if not defined)
    string action;	 // URL to call when they press submit
    string method="GET"; // Could also be POST.
    htmlTag startTag;	 // Tag that holds <FORM>
    htmlTag endTag;	 // Tag one past </FORM>
    array of htmlFormVar vars;	// Variables defined in form.
    }

class htmlPage
// A complete parsed-out html page.
    {
    string url;		// URL or file where we got the page.
    string text;	  // Full unparsed text including headers
    htmlStatus status;	// Version and status info
    dir of string header; // Header lines including cookies
    dir of htmlCookie cookies;  // Cookies
    int htmlStart;	  // Start of html code within fullText
    array of htmlTag tags;// All the tags in order
    array of htmlForm forms;  // Possibly empty array of forms.
    }

flow htmlStatusParse(string text, int pos) into (htmlStatus status, int newPos)
// Read in status line.
    {
    string line;
    (line, newPos) = text.nextLine(pos);
    if (!line) punt("Empty HTML file");
    array of string words = line.words();   // Chop line into words
    if (words.size < 2) punt("bad HTTP status line");  // Check for two words
    status = (words[0], words[1].asInt());  // Initialize status object
    if (!status.version.startsWith("HTTP/")) punt("No HTTP in status line");
    }

flow htmlCookieParse(string line) into (htmlCookie cookie)
    {
    array of string parts = line.split(';');
    for (part in parts)
	{
	part = part.trim();
	int equals = part.find('=');
	if (equals < 0) punt("missing equals in cookie $part");
	string field = part.start(equals);
	string val = part.rest(equals+1);
	if (!cookie) // first time through, alloc self and set name
	    {
	    cookie = ();
	    cookie.name = field;
	    cookie.value = val;
	    }
	else if (field == 'domain')
	    cookie.domain = val;
	else if (field == 'path')
	    cookie.path = val;
	else if (field == 'expires')
	    cookie.expires = val;
	else if (field == 'secure')
	    cookie.secure = 1;
	}
    }

flow htmlHeaderParse(string text, int pos) 
into (dir of string header, dir of htmlCookie cookies, int newPos)
// Read lines until get a blank one.  Put the lines into a hash.
// The lines are of the format key: value.  We strip the colon.
    {
    string line;
    header = ();
    cookies = ();
    newPos = pos;
    for (;;)
        {
	(line,newPos) = text.nextLine(newPos);
	if (!line) punt("End of file in HTTP header");
	(string key, int p) = line.nextWord(0);
	if (!key)
	    break;
	// Check for trailing colon and then trim it.
	if (!key.endsWith(':')) punt("Missing : in HTTP header line\n\t$line");
	key = key.start(key.size-1);
	string val = line.rest(p).trim();
	header[key] = val;
	if (key == "Set-Cookie")
	    {
	    htmlCookie cookie = htmlCookieParse(val);
	    cookies[cookie.name] = cookie;
	    }
	}
    }

flow htmlTagsParse(string text, int pos) into (array of htmlTag tags)
// Scan text starting at pos for HTML tags and return an array of them.
    {
    int p = pos;	 // Current position in text
    tags = ();		 // Allocate results array

    while (p < text.size)
	{
	char c = text[p];
	p++;
	if (c == '<')
	    {
	    if (text[p] == '!') // HTML comment
		{
		p++;
		if (text[p] == '-' && text[p+1] == '-')
		    p = text.findNext('-->', p);
		else
		    p = text.findNext('>', p);
		if (p < 0) 
		    {
		    warn("End of file in comment");
		    break;
		    }
		}
	    else  // It's a real tag, let's process it.
	        {
		// Make up tag and set start position to <
		htmlTag tag = ();
		tag.start = p-1;
		tag.attributes = ();
		string s = "uglyduck";

		// Grab first word into tagName.
		int end = p;
		for (;;)
		    {
		    c = text[end];
		    if (c == '>'  || isSpace(c))
			break;
		    end++;
		    if (end  >= text.size)
		        {
			warn("unclosed tag " + text.rest(tag.start));
			break;
			}
		    }
		tag.name = text.middle(p, end-p);
		p = end;

		// If we're at end of tag already fill in a few
		// fields and bail on rest of loop
		if (p >= text.size)
		    {
		    tag.end = text.size;
		    continue;
		    }
		else if (c == '>')
		    {
		    tag.end = end+1;
		    continue;
		    }

		/*-soon
		// Process name/value pairs until we get end tag.
		for (;;)
		    {
		    }
		soon-*/
		}
	    }
	}
   }

to htmlPageParse(string fileName) into (htmlPage page)
    {
    file f = fileOpen(fileName, "r");
    page = ();
    page.url = fileName;
    page.text = f.readAll();
    int pos = 0;
    (page.status, pos) = htmlStatusParse(page.text, pos);
    (page.header, page.cookies, pos) = htmlHeaderParse(page.text, pos);
    string contentType = page.header["Content-Type"];
    if (!contentType)
        {
	warn("No contentType, assuming test/html");
	contentType = 'text/html';
	page.header['Content-Type'] = contentType;
	}
    page.htmlStart = pos;
    if (contentType.startsWith('text/html'))
        {
	page.tags  = htmlTagsParse(page.text, pos);
	}
    }


to test(string fileName = "gb.html")
    {
    try {
	htmlPage page = htmlPageParse(fileName);
	print(page.status);
	print(page.header);
	print(page.cookies);
	}
    catch(m)
        {
	print("Error: $m");
	}
    }

test();

