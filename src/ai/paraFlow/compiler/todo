In para actions and foreach swap order of el and collection in tree.
Then put handling of implicit el type in case pptUntypedName
(which should be renames pptUntypedElement) in rTypeCheck switch
instead of in pptParaAdd/pptForeach etc. part of switch.  This
should cause it to be evaluated before the body, sidestepping
the 'no nil allowed in this operation' error.


  - Rework code generator so that a type is kept alongside the
    data on the expression stack.
  - Do a sort function (need function pointer?)
  - Read-only and private variables.
        Make it so that class.new() is only legal way to
	make something with private or read-only var.
  - Implement ++ and maybe --.
  - Implement case statement.
  - Create 'serial' function - that is gauranteed only to be 
    executed by one thread at a time.  Can be called from a para.
  - Exceptions.
  - Prevent memory leakage in expressions that don't get assigned to anything
    (including function calls).
  - More file i/o.
  - Adding named parameters.
  - Implement lists.
  - Implementing trees.


-----------
DONE
  - Eliminate need for type in constructs like
       (type element in collection)
  - Implement "para into" statement.  Actually did this as
    para (el in collection) action.
  - Doing parallel checking for para and flow statements.
  - blessPara - Makes sure that there are no writes
	outside of local variables and i/o pameters, either direct or indirect.
  - blessFlow - Make sure there are no reads or writes outside
        of local variables and input/output parameters.
  - Reconsider where reference counting is done.  In particular
    what if instead of bumping the refcount when it goes on the
    expression stack, have system where strings and objects are
    created with a ref-count of zero, and assignment bumps the
    ref-count, and objects are de-ref-counted when they are
    removed from the stack (which for local variables occurs
    when they go out of scope).
       I played around with this for a couple of hours.  It seemed
    to actually improve the code little if any, and since there were
    still a few bugs to fix with the reimplementation I backed out
    the change.
  - Changing it so that a pf_ is prepended to all global
    symbols created by paraFlow to avoid name conflicts
    with the C libraries.
  - Make it so don't need 'self' to reference class members and 
    methods inside a method of same class.
  - Make single quotes mean literal ascii character values.
  - make tuple.pfh work right (variables not right).
  - Test default initializations across modules.
  - Make classes declared in another module work.
  - make pfh file include closing paren in :
	to fibonacci ( int iterations ) into ( long f;
	to factorial ( int n ) into ( float f;
  - Make testProg/broken/oneIntoClass.pf work.
  - Working on multiple modules.
  - Getting raw keyboard input.
  - Rename f.print and f.scan to something else.  read/write?  
    readVar/writeVar? put/get?   
  - Allow nil as a value for initializing and objects.
  - Allowing print to go to file.
  - Adding scan (to go with print).
  - Making print not die on circular links.
  - Allowing static variables inside of a function.
  - Adding default parameters to class initialization.
  - Adding default parameters to function calls.  
  - Fix bug where this construct doesn't work:
	    class keyVal
	       {
	       int key;
	       string val;
	       }
	    keyVal kv = (1, "one");
	    kv.val.upper();
    but
    	    string s = "hello";
	    s.upper()
    does work.
  - Implement += for strings and arrays.
  - Make array of var work.
  - Make sure that assigning a typed variable from a var variable
    does the right thing.
  - Get the quote to markers to work.
  - Make foreach where the collection is a member variable work.
  - Decided against letting assignments return a value, since
    the foreach var in funcCall() removes most of the need.  
  - Make foreach result in funcCall work.
  - make L work in numerical constants,
  - Make it ok to have extra trailing comma in an initialization
    before a ).
  - Making virtual functions happen.
  - Yank out constant type optimization in pfType, particularly
    in coerceType routine.
  - Sort the _pf_base_info table before writing it.
  - Make it so that during runtime the typeId's of subparts
    of collected ID's are filled in.  Currently they are often
    zero, which results in memory leakage when freeing arrays
    of objects.  This might be best accomplished by some
    sort of transitive closure either when the compiler
    writes out the type table, or when the runtime reads it
    in.
  - Put command line arguments into an array of strings the
    user can access.  Maybe commandLine[] or args[]?
  - Make foreach work on dirs.
  - Implementing dir objects.  Consider another name.
  - Allow classes to be made without initialization.  Perhaps
    () will create an instance that's filled with zero.
  - Implementing the rest of inheritance.
  - Making it so can allocate an array separate from initializing it.
  - Making it convenient to add library functions and classes.
Put in some way to do file i/o.
get test.pf to work on stuff like:
	(int x, int y) = unitCircle(3)
Test against all easy and oneFile test cases.

Add use of elements of array/tree/dir.
Implement proper strings, and allow strings to be added together.
Consider allowing strings to be added to number with the result
   being a string.

Code generator:
    Get started.
   o - Make pptIndex work on arrays.
   o - Put in cleanup of objects.
   	x - Inc ref count when put var on stack.
	x - Dec ref count when leave scope.
	x - Dec ref count of old value when var reassigned.
   o - Make array and structure assignments (as opposed to
       initializations) from tuples work.
   o - Make pptDot work on classes.
   o - put out code for methods.

Type system:
    Integrate pfSingleTypes into type system.
    Write out subset of types that can be used
        during run time.

Runtime system:
   o - Implement _pf_xxx_array_from_tuple.
   o - Change pfStack type to _pf_stack and otherwise restrict
       run-time name space to things that start _pf_.
   o - Put in cleanup of objects.
   o - Figure out alignment system that C is using in structures
       at during initialization phase, and then store this in
       the base type table.

  - Somehow allow  both ((1,2),(3,4)) and (pt1, pt2)
    initializations in _pf_class_from_tuple.
    (Currently it does (pt1,pt2) which is safe in
    case where the underlying structure contains a self
    reference, as a linked-list node will.  It used
    to do ((1,2),(3,4)) which was nicer in some senses.
    In other senses really want to even do ((1,2),pt2).
    Currently these are all flattened by the time
    pf_class_from_tuple gets to them.

    Perhaps resolve by passing a string describing this
    to _pf_class_from_tuple.   It could be as so:
        ((1,2),(3,4))  ->  ((xx)(xx))
        (pt1,pt2)  ->  (xx)
	((1,2),pt2) -> ((xx)x)
	(pt1,(1,2)) -> (x(xx))
    I wonder if this raises deeper issues about printing 
    though.  Since reciprocal references are handy,
    need some way to break the print function out of
    loops.  Need some method of expressing that a
    structure has already been seen.  How about labeling
    each node in the induced parse tree :
        ((12)(34))  
	ABCD EFG
    that is each paren or number gets a label.  Then
    when you're pointing back to some data already seen
    you put in the label instead of the value.  A
    singly-linked list of 4 elements might look like so:
        (x(x(x(x0)))  1 2 3 4
	ABCDEFGHI
    And a circular list of 4 as so:
        (x(x(x(xy)))  1 2 3 A
	ABCDEFGHI
  - Get (xx(xx)(xxx)) type tuple heirarchy definitions to work
    with arrays as well as classes.


        


