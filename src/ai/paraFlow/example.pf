/* This contains some example code in the ParaFlow langauge.
 * ParaFlow is syntactically related to C with some elements
 * of Python and a few new elements.  Two of the most important
 * new elements are 'para' and 'flow' type functions which
 * express parallelism.
 */

to printHello
// Simple no parameter or return result declaration
    {
    print("Hello world")
    }

to printWordLots(string word, int count)
// Declaration with a couple of parameters, no return value.
    {
    for i in [1,count]
       print(" ")
    }


to factorial(int n) into (float result)
// Declaration with an integer parameter that returns floating point result
    {
    result = 1
    for i in [1,n]
	result *= i    
    }

to stats(float a, float b, float c) into (float sum, float average)
// Declaration with three float inputs and two float outputs.
    {
    sum = a + b + c
    average = sum/3
    }

to swap(a,b) into (c,d)
// Declaration with two unspecifed parameters that returns two unspecified
// results.  System should be smart enough to somehow generate code on
// demand for different types of parameters.
    {
    c = b
    d = a
    }

flow reverseRange(oldStart,oldEnd,seqSize) into (newStart,newEnd)
// Flow declarations can be implemented in hardware without latches.
// Effectively therefore all statements in the function execute in parallel.
// The rule is that there can only be one assignment to each variable
// (and no assignments to the input parameters).  Possibly this can
// exclude access to global variables too.  Functions can be called,
// but only if they are also flow functions.
    {
    newStart = seqSize - oldEnd
    newEnd = seqSize - oldStart
    }

para reverseAll(list range, int seqSize)
// Para declarations contain a collection of some sort as their first parameter.
// The code gets executed on each item in the collection simultaniously.
// These may read but not write to global variables.
    {
    (range.start, range.end) = reverseRange(range.start, range.end, seqSize)
    range.midPoint = (range.start + range.end)/2
    }

/* ParaFlow is object oriented, but not in your face about it.
 * It does not support multiple inheritance.  It does support
 * interfaces.  Built in types include: byte (8 bits), short (16 bits),
 * int (32 bits), long (64 bits), float (double-precision IEEE), 
 * string (arbitrarily long), files, array, list (internally a doubly-linked list)
 * and catalogs (red-black self-balancing trees internally).
 * Arrays, lists, and catalogs all implement the collection interface.
 * Anything that implements this interface can be used in para functions,
 * and for statements. */

object color
// Simple objects are much like C structures.  There is no
// data hiding.  If you want to hide data you access the object
// through an interface, or anonymously.
   byte r,g,b

object usaAddress
   {
   string street	// May include more than one line and apartment number
   string city,state
   float zipCode	// The extended zip code is stored to the right of decimal
   }

object point
/* A point in 2-D space. */
   double x,y

object circle
/* A circle. */
    {
    point center
    double radius

    to area into (result)
        result = 3.14 * radius * radius

    to diameter into (result)
    // Instance variables can be used either with or without self
    // keyword.  Good style in larger methods to use self.
        result = 2 * 3.14 * self.radius
    }
 
object hash implements collection
// Here we implement a hash table, which can be used as a collection.
   {
   object element
   // This is an element in our hash list
   // Note that objects can have objects defined inside of themselves.
       {
       string name
       object value	// A generic object for a value.
       }
       
   list buckets[1024]	// Just a fixed size array of lists.  This will contain elements.

   to func(string name) into (int result)
   // We use a simple but effective hash function, since 5 is coprime to 1024
       {
       result = 0
       for c in name
	   {
           result *= 5;
	   result += c;
	   }
       result %= buckets.size
       }

   to add(string name, object val)
   // Create new element based on name and val, and add to hash.
       {
       el = element.create
       el.name = name
       el.value = val
       buckets[func(name)].add(el)
       }

  to find(string name) into (object val)
  // Find element
      {
      for el in buckets[func(name)]
	  {
          if (el.name == name)
	      {
	      val = el.value
	      break
	      }
	  }
      }

   to mustFind(string name) into (object val) throws errNotFound
   // Find element or throw exception
       {
       val = find(name)
       if (!val)
           throw errNotFound
       }
  
   object hashIterator implements iterator
   // The iterator object for a hash has to maintain a little 
   // internal state.
       {
       hash h			// A reference to our hash
       int bucketIx		// Which list we are currently on
       iterator listIterator    // Iterator for the list

       to create(hash h)
       // We need a more complex initialization than all zeroes,
       // so we have to have a create method
	   {
	   self.h=h
           self.bucketIx=0
	   self.listIterator = buckets[bucketIx]
	   }

       to advance into (object)
       // The advance method is all that's required to be
       // an iterator.  It just returns the next object,
       // or nil when nothing is left.
	   {
	   loop
	       {
	       object = self.listIterator.advance
	       if (object)
	           break
	       self.bucketIx += 1
	       if (self.bucketIx >= self.h.buckets.size)
	           break
	       }
           }
	}
           
    to iterate into (iterator)
    // The iterate method is all that's required to be a collection.
    // This just returns an object with an iterator interface.
        {
	iterator = hashIterator.create(self)
	}
    }  // End of hash object

object countingHash extends hash
// Here we extend the hash by keeping track of how many elements
// are in it.
    {
    int count;

    to add(string name, object val)
        {
	self.count += 1;
	parent.add(name, val);
	}
    }
