/* This contains some example code in the ParaFlow langauge.
 * ParaFlow is syntactically related to C with some elements
 * of Python and a few new elements.  Two of the most important
 * new elements are 'para' and 'flow' type functions which
 * express parallelism.
 */

to printHello()
// Simple no parameter or return result declaration
    {
    print("Hello world");
    }

to printWordLots(string word, int count)
// Declaration with a couple of parameters, no return value.
    {
    for (int i=0; i<count; i += 1)
       prin(word + " ");	// prin does not print a line break.
    print("");
    }


to factorial(int n) into (float result)
// Declaration with an integer parameter that returns floating point result
    {
    result = 1;
    for (int i=2; i<=n; i += 1)
	result *= i;    
    }

to stats3(float a, float b, float c) into (float sum, float average)
// Declaration with three float inputs and two float outputs.
    {
    sum = a + b + c;
    average = sum/3;
    }

to swap(var a,var b) into (var c,var d)
// Declaration with two unspecifed parameters that returns two unspecified
// results.  System does type checking at run time when vars are used.
// NB: currently var only partially implemented - mostly for print statement. 
    {
    c = b;
    d = a;
    }

flow reverseRange(int oldStart,int oldEnd,int seqSize) into (int newStart,int newEnd)
// Flow declarations can be implemented in hardware without latches.
// Effectively therefore all statements in the function execute in parallel.
// The rule is that there can only be one assignment to each variable
// (and no assignments to the input parameters).  Possibly this can
// exclude access to global variables too.  Functions can be called,
// but only if they are also flow functions.  No loops.
// NB: currently flows are not checked for all this, just are synonyms for 'to'
    {
    newStart = seqSize - oldEnd;
    newEnd = seqSize - oldStart;
    }

para reverseAll(rangeClass range, int seqSize)
// Para functions are parallelizable.  They can be invoked on all elements
// of a collection simultaniously.  The element is passed in as the first
// parameter.  Para functions can read from anywhere, but can only write
// to local variables, their output, and the first input parameter.
// NB: currently flows are not checked for all this, just are synonyms for 'to'
    {
    (range.start, range.end) = reverseRange(range.start, range.end, seqSize);
    range.midPoint = (range.start + range.end)/2;
    }

/* ParaFlow is object oriented, but not in your face about it.
 * It does not support multiple inheritance.  It does support
 * interfaces.  Built in types include: byte (8 bits), short (16 bits),
 * int (32 bits), long (64 bits), float (double-precision IEEE), 
 * string (arbitrarily long), files, array, list (internally a doubly-linked list),
 * dir (internally a hash table), and tree (internally a self-balancing red-black tree).
 * Arrays, lists, and catalogs all implement the collection interface.
 * Anything that implements this interface can be used in para functions,
 * and for statements. */

class color
// Simple classes are much like C structures.  There is no
// data hiding.  If you want to hide data you access the object
// through an interface, or anonymously.
   {
   byte r,g,b;
   }

class usaAddress
   {
   string street;	// May include more than one line and apartment number
   string city,state;
   float zipCode;	// The extended zip code is stored to the right of decimal
   }

class point
/* A point in 2-D space. */
   {
   double x,y;
   }

class circle
/* A circle. */
    {
    point center;
    double radius;

    to diameter() into (double result)
	{
        result = 2 * 3.14 * self.radius;  // Instance variables are accessed via "self"
	}

    to area() into (double result)
	{
        result = 3.14 * self.radius * self.radius;
	}

    }
 
class hash implements collection
// Here we implement a hash table, which can be used as a collection.
// (NB currently interfaces are not implemented, and only built-in
// collections are available.)
   {
   class element
   // This is an element in our hash list
   // Note that objects can have objects defined inside of themselves.
       {
       string name;
       var value;	// Variable type
       }
       
   // Just a fixed size array of lists.  This will contain elements.
   array[1024] of list of element buckets;
   // NB list isn't working at the moment either.

   to func(string name) into (int result)
   // We use a simple but effective hash function, since 5 is coprime to 1024
       {
       result = 0
       foreach c in name
	   {
           result *= 5;
	   result += c;
	   }
       result %= buckets.size;
       }

   to add(string name, class val)
   // Create new element based on name and val, and add to hash.
       {
       el = element.create;
       el.name = name;
       el.value = val;
       buckets[func(name)].add(el);
       }

  to find(string name) into (class val)
  // Find element
      {
      foreach el in buckets[func(name)]
	  {
          if (el.name == name)
	      {
	      val = el.value;
	      break;
	      }
	  }
      }

   to mustFind(string name) into (class val) throws errNotFound
   // Find element or throw exception
   // (NB currently exceptions and throws are not implemented)
       {
       val = find(name);
       if (!val)
           throw errNotFound(name);
       }
  
   class hashIterator implements iterator
   // The iterator object for a hash has to maintain a little 
   // internal state.
       {
       hash h			// A reference to our hash
       int bucketIx		// Which list we are currently on
       iterator listIterator    // Iterator for the list

       to create(hash h)
       // We need a more complex initialization than all zeroes,
       // so we have to have a create method
       // (NB create vs. new, vs just having a factory function of
       // your own choosing not decided yet.)
	   {
	   self.h=h
           self.bucketIx=0
	   self.listIterator = buckets[bucketIx]
	   }

       to advance() into (var object)
       // The advance method is all that's required to be
       // an iterator.  It just returns the next object,
       // or nil when nothing is left.
	   {
	   loop
	       {
	       object = self.listIterator.advance();
	       if (object)
	           break
	       self.bucketIx += 1;
	       if (self.bucketIx >= self.h.buckets.size)
	           break;
	       }
           }
	}
           
    to iterate into (iterator)
    // The iterate method is all that's required to be a collection.
    // This just returns an object with an iterator interface.
        {
	iterator = hashIterator.create(self);
	}
    }  // End of hash object

class countingHash extends hash
// Here we extend the hash by keeping track of how many elements
// are in it.
    {
    int count;

    to add(string name, class val)
        {
	self.count += 1;
	parent.add(name, val);
	}
    }


// Instead of the problematic C/Java switch statement there is a case
// statement that is as so:

string message;
case (errCode)
    {
    0: ;	// leave message nil
    1: message = "File not found";
    2: message = "Write protected";
    3,4: message = "Privacy violation";
    18: {message = "Hull breech"; alarm("evacuation")}
    default: message = "Error code #" + errCode;
    }
if (message)
    punt(message);

Only a single statement is allowed after each label.
A comma-separated list of labels can share the same
statement.  Multiple statements enclosed in braces are
considered a single statment.

A simple case would be:

case
