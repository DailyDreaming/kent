Index: para/para.c
===================================================================
RCS file: /projects/compbio/cvsroot/kent/src/parasol/para/para.c,v
retrieving revision 1.5
diff -r1.5 para.c
18c18
<   "Normal usage is to do a 'para make' followed by 'para push' until\n"
---
>   "Normal usage is to do a 'para create' followed by 'para push' until\n"
21c21
<   "   para command batch [command-specific arguments]\n"
---
>   "   para command [command-specific arguments]\n"
23c23,24
<   "para make batch jobList\n"
---
>   "\n"
>   "para create jobList\n"
26,29c27,30
<   "para push batch\n"
<   "   This pushes forward the batch of jobs by submitting jobs to codine\n"
<   "   It will try and keep the codine queue a size that is efficient for\n"
<   "   codine, and retry failed jobs\n"
---
>   "para push \n"
>   "   This pushes forward the batch of jobs by submitting jobs to parasol\n"
>   "   It will limit parasol queue size to something not too big and\n"
>   "   retry failed jobs\n"
34,42c35,46
<   "      -maxPush=N  Maximum number of jobs to queue - default 100000\n"
<   "      -warnTime=N Number of minutes job can run before hang warning - default 4320 (3 days)\n"
<   "      -killTime=N Number of minutes job can run before push kills it - default 20160 (2 weeks)\n"
<   "para shove batch\n"
<   "   Push jobs until can't push any more.  Options as with push and also:\n"
<   "      -sleepTime=N  Number of seconds to sleep between pushes\n"
<   "para try batch\n"
<   "      This is like para push, but only submits up to 10 jobs\n"
<   "para check batch\n"
---
>   "      -maxPush=N  Maximum number of jobs to queue - default 10000\n"
>   "      -warnTime=N Number of minutes job runs before hang warning - default 4320 (3 days)\n"
>   "      -killTime=N Number of minutes job runs before push kills it - default 20160 (2 weeks)\n"
>   "para try \n"
>   "   This is like para push, but only submits up to 10 jobs\n"
>   "para shove\n"
>   "   Push jobs in this database until all are done or one fails after N retries\n"
>   "para make jobList\n"
>   "   Create database and run all jobs in it if possible.  If one job\n"
>   "   failes repeatedly this will fail.  Suitable for inclusion in makefiles\n"
>   "   Same as a 'create' followed by a 'shove'.\n"
>   "para check \n"
44c48
<   "para stop batch\n"
---
>   "para stop \n"
46c50
<   "para finished batch\n"
---
>   "para finished \n"
48c52
<   "para hung batch\n"
---
>   "para hung \n"
50,54c54,58
<   "para crashed batch\n"
<   "   List jobs that crashed or failed output checks\n"
<   "para failed batch\n"
<   "   List jobs that crashed or hung\n"
<   "para problems batch\n"
---
>   "para crashed \n"
>   "   List jobs that crashed or failed output checks the last time they were run.\n"
>   "para failed \n"
>   "   List jobs that crashed after repeated restarts.\n"
>   "para problems \n"
56c60
<   "para running batch\n"
---
>   "para running \n"
58c62
<   "para time batch\n"
---
>   "para time \n"
68c72
< int maxPush = 100000;
---
> int maxPush = 10000;
71c75
< int sleepTime = 20*60;
---
> int sleepTime = 5*60;
336,337c340,341
< void paraMake(char *batch, char *jobList)
< /* Make a batch database from a job list. */
---
> void paraCreate(char *batch, char *jobList)
> /* Create a batch database from a job list. */
345a350
> makeDir("err");
408a414
>     sub->inQueue = TRUE;
459a466
>     ++queueSize;
493a501,518
> void freeResults(struct hash **pHash)
> /* Free up results hash and elements in it. */
> {
> struct hash *hash = *pHash;
> struct hashEl *list, *el;
> struct jobResult *jr;
> if ((hash = *pHash) != NULL)
>     {
>     list = hashElListHash(hash);
>     for (el = list; el != NULL; el = el->next)
> 	{
> 	jr = el->val;
> 	jobResultFree(&jr);
> 	}
>     hashElFreeList(&list);
>     hashFree(pHash);
>     }
> }
588,590c613,614
< int paraPush(char *batch)
< /* Push a batch of jobs forward - submit jobs.  Return number of jobs
<  * pushed. */
---
> struct jobDb *paraCycle(char *batch)
> /* Cycle forward through batch.  Return database. */
597a622
> struct hash *resultsHash;
599d623
< makeDir("err");
601c625
< markRunJobStatus(db);
---
> resultsHash = markRunJobStatus(db);
630d653
< jobDbFree(&db);
632,633c655,658
<    printf("\n");
< printf("Pushed Jobs: %d\n", pushCount);
---
>     {
>     printf("\n");
>     printf("Pushed Jobs: %d\n", pushCount);
>     }
636c661,669
< return pushCount;
---
> freeResults(&resultsHash);
> return db;
> }
> 
> void paraPush(char *batch)
> /* Push forward batch one time. */
> {
> struct jobDb *db = paraCycle(batch);
> jobDbFree(&db);
640c673,674
< /* Keep pushing jobs until finished. */
---
> /* Push batch of jobs and keep pushing until it's finished, polling
>  * parasol every 5 minutes. */
642c676,683
< while (paraPush(batch) > 0)
---
> struct jobDb *db;
> struct job *job;
> struct submission *sub;
> int maxSleep = 5*60;
> int curSleep = 60;
> time_t start = time(NULL), now;
> 
> for (;;)
644,645c685,710
<     printf("Sleeping until next push - hit <control>C to quit shoving\n");
<     sleep(sleepTime);
---
>     boolean anyUnfinished = FALSE;
>     db = paraCycle(batch);
>     for (job = db->jobList; job != NULL; job = job->next)
>         {
> 	if ((sub = job->submissionList) == NULL)
> 	    anyUnfinished = TRUE;
> 	else
> 	    {
> 	    enum jaState state = figureState(job);
> 	    if (job->submissionCount >= retries)
> 	        {
> 		if (state != jaUnsubmitted && state != jaQueued && state != jaRunning)
> 		    errAbort("Batch failed after %d tries on %s", retries, job->command);
> 		}
> 	    if (state != jaFinished)
> 	        anyUnfinished = TRUE;
> 	    }
> 	}
>     jobDbFree(&db);
>     if (!anyUnfinished)
>         break;
>     sleep(curSleep);
>     if (curSleep < maxSleep)
>         curSleep += 60;
>     now = time(NULL);
>     printf("Checking job status %d minutes after launch\n",  round((now-start)/60.0));
646a712,719
> printf("Successful batch!\n");
> }
> 
> void paraMake(char *batch, char *spec)
> /* Do a create and then a shove. */
> {
> paraCreate(batch, spec);
> paraShove(batch);
885a959
> markRunJobStatus(db);
892,893c966,969
< 	   killSubmission(sub);
< 	sub->crashed = TRUE;
---
> 	    {
> 	    killSubmission(sub);
> 	    sub->crashed = TRUE;
> 	    }
1058c1134
< if (argc < 3)
---
> if (argc < 2)
1067c1143
< batch = argv[2];
---
> batch = "batch";
1070c1146
< if (sameString(command, "make"))
---
> if (sameString(command, "create"))
1072c1148
<     if (argc != 4)
---
>     if (argc != 3)
1074c1150
<     paraMake(batch, argv[3]);
---
>     paraCreate(batch, argv[2]);
1087a1164,1169
> else if (sameString(command, "make"))
>     {
>     if (argc != 3)
>         usage();
>     paraMake(batch, argv[2]);
>     }
1090c1172
<     maxPush = 20;
---
>     maxPush = 10;
Index: paraHub/paraHub.c
===================================================================
RCS file: /projects/compbio/cvsroot/kent/src/parasol/paraHub/paraHub.c,v
retrieving revision 1.17
diff -r1.17 paraHub.c
1c1,65
< /* paraHub - parasol hub server. */
---
> /* paraHub - Parasol hub server.  This is the heart of the parasol system.
>  * The hub daemon spawns a heartbeat daemon and a number of spoke deamons
>  * on startup,  and then falls into a loop processing messages it recieves
>  * on it's TCP/IP socket.  The hub daemon does not do anything time consuming
>  * in this loop.   The main thing the hub daemon does is put jobs on the
>  * job list,  move machines from the busy list to the free list,  and call
>  * the 'runner' routine.
>  *
>  * The runner routine looks to see if there is a free machine, a free spoke,
>  * and a job to run.  If so it will send a message to the spoke telling
>  * it to run the job on the machine,  and then move the job from the 'pending'
>  * to the 'running' list,  the spoke from the freeSpoke to the busySpoke list, 
>  * and the machine from the freeMachine to the busyMachine list.   This
>  * indirection of starting jobs via a separate spoke process avoids the
>  * hub daemon itself having to wait to find out if a machine is really
>  * there.
>  *
>  * When a spoke is done assigning a job, the spoke sense a 'recycleSpoke'
>  * message to the hub, which puts the spoke back on the freeSpoke list.
>  * Likewise when a job is done the machine running the jobs sends a 
>  * 'job done' message to the hub, which puts the machine back on the
>  * free list,  writes the job exit code to a file, and removes the job
>  * from the system.
>  *
>  * Sometimes a spoke will find that a machine is down.  In this case it
>  * sends a 'node down' message to the hub as well as the 'spoke free'
>  * message.   The hub will then move the machine to the deadMachines list,
>  * and put the job back on the top of the pending list.
>  *
>  * The heartbeat daemon simply sits in a loop sending heartbeat messages to
>  * the hub every so often (every 30 seconds currently), and sleeping
>  * the rest of the time.   When the hub gets a heartbeat message it
>  * does a few things:
>  *     o - It calls runner to try and start some more jobs.  (Runner
>  *         is also called at the end of processing a spokeFree, 
>  *         jobDone, addJob or addMachine message.  Typically because
>  *         of this runner won't find anything new to run, but this
>  *         is put here mostly just in case of unforseen issues.)
>  *    o -  It calls graveDigger, a routine which sees if a machine
>  *         on the dead list has been checked recently.  If not it
>  *         dispatches a spoke to see if it's come back to life.
>  *    o -  It calls hangman, a routine which sees if jobs the system
>  *         thinks have been running for a long time are still 
>  *         running on the machine they have been assigned to.
>  *         If the machine has gone down it is moved to the dead list
>  *         and the job is reassigned. 
>  *
>  * This whole system depends on the hub daemon being able to finish
>  * processing messages fast enough to keep the connection queue on
>  * it's socket from overflowing.  Each job involves 3 messages to the
>  * main socket:
>  *     addJob - from a client to add the job to the system
>  *     recycleSpoke - from the spoke after it's dispatched the job
>  *     jobDone - from the compute node when the job is finished
>  * On some of the earlier Linux kernals we had trouble with the
>  * connection queue overflowing when dispatching lots of short
>  * jobs.  This seemed to be from the jobDone messages coming
>  * in faster than Linux could make connections rather than the
>  * hub daemon being slow.  On the kilokluster with a more modern
>  * kernal this has not been a problem - even with very 0.1 second
>  * jobs on 1000 CPUs.  Should overflow occur the heartbeat processing
>  * should gradually rescue the system in any case, but the throughput
>  * will be greatly reduced. */
>  
> 
462a527,528
>     if (rq->f == NULL)
>         warn("hub: couldn't open results file %s", rq->name);
466a533,537
>     char *machName;
>     if (job->machine != NULL)
>         machName = job->machine->name;
>     else
>         machName = "ghost";
468c539
<         status, job->machine->name, job->id, job->exe, 
---
>         status, machName, job->id, job->exe, 
689d759
< runner(1);
732c802,803
< 	job->machine->lastChecked = now;
---
> 	if (job->machine != NULL)
> 	    job->machine->lastChecked = now;
734a806
> 	runner(1);
1002a1075
> 
1039c1112
<     if (!netMustReadAll(connectionHandle, sig, sigLen) || !sameString(sig, paraSig))
---
>     if (netReadAll(connectionHandle, sig, sigLen) < sigLen || !sameString(sig, paraSig))
Index: paraHub/spoke.c
===================================================================
RCS file: /projects/compbio/cvsroot/kent/src/parasol/paraHub/spoke.c,v
retrieving revision 1.9
diff -r1.9 spoke.c
117c117
<     if (!netMustReadAll(conn, sig, sigLen))
---
>     if (netReadAll(conn, sig, sigLen) != sigLen)
Index: paraNode/paraNode.c
===================================================================
RCS file: /projects/compbio/cvsroot/kent/src/parasol/paraNode/paraNode.c,v
retrieving revision 1.10
diff -r1.10 paraNode.c
353c353
<     if (netMustReadAll(connectionHandle, signature, sigLen))
---
>     if (netReadAll(connectionHandle, signature, sigLen) == sigLen)
Index: parasol/parasol.c
===================================================================
RCS file: /projects/compbio/cvsroot/kent/src/parasol/parasol/parasol.c,v
retrieving revision 1.12
diff -r1.12 parasol.c
334c334
< 	usage;
---
> 	usage();
350c350
< 	    usage;
---
> 	    usage();
