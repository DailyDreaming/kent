Index: diffs
===================================================================
RCS file: /projects/compbio3/cvsroot/kent/src/parasol/diffs,v
retrieving revision 1.3
diff -r1.3 diffs
1,847d0
< Index: diffs
< ===================================================================
< RCS file: /projects/compbio3/cvsroot/kent/src/parasol/diffs,v
< retrieving revision 1.2
< diff -r1.2 diffs
< 1,552d0
< < Index: diffs
< < ===================================================================
< < RCS file: /projects/compbio/cvsroot/kent/src/parasol/diffs,v
< < retrieving revision 1.1.1.1
< < diff -r1.1.1.1 diffs
< < 1,387d0
< < < Index: para/para.c
< < < ===================================================================
< < < RCS file: /projects/compbio/cvsroot/kent/src/parasol/para/para.c,v
< < < retrieving revision 1.5
< < < diff -r1.5 para.c
< < < 18c18
< < < <   "Normal usage is to do a 'para make' followed by 'para push' until\n"
< < < ---
< < < >   "Normal usage is to do a 'para create' followed by 'para push' until\n"
< < < 21c21
< < < <   "   para command batch [command-specific arguments]\n"
< < < ---
< < < >   "   para command [command-specific arguments]\n"
< < < 23c23,24
< < < <   "para make batch jobList\n"
< < < ---
< < < >   "\n"
< < < >   "para create jobList\n"
< < < 26,29c27,30
< < < <   "para push batch\n"
< < < <   "   This pushes forward the batch of jobs by submitting jobs to codine\n"
< < < <   "   It will try and keep the codine queue a size that is efficient for\n"
< < < <   "   codine, and retry failed jobs\n"
< < < ---
< < < >   "para push \n"
< < < >   "   This pushes forward the batch of jobs by submitting jobs to parasol\n"
< < < >   "   It will limit parasol queue size to something not too big and\n"
< < < >   "   retry failed jobs\n"
< < < 34,42c35,46
< < < <   "      -maxPush=N  Maximum number of jobs to queue - default 100000\n"
< < < <   "      -warnTime=N Number of minutes job can run before hang warning - default 4320 (3 days)\n"
< < < <   "      -killTime=N Number of minutes job can run before push kills it - default 20160 (2 weeks)\n"
< < < <   "para shove batch\n"
< < < <   "   Push jobs until can't push any more.  Options as with push and also:\n"
< < < <   "      -sleepTime=N  Number of seconds to sleep between pushes\n"
< < < <   "para try batch\n"
< < < <   "      This is like para push, but only submits up to 10 jobs\n"
< < < <   "para check batch\n"
< < < ---
< < < >   "      -maxPush=N  Maximum number of jobs to queue - default 10000\n"
< < < >   "      -warnTime=N Number of minutes job runs before hang warning - default 4320 (3 days)\n"
< < < >   "      -killTime=N Number of minutes job runs before push kills it - default 20160 (2 weeks)\n"
< < < >   "para try \n"
< < < >   "   This is like para push, but only submits up to 10 jobs\n"
< < < >   "para shove\n"
< < < >   "   Push jobs in this database until all are done or one fails after N retries\n"
< < < >   "para make jobList\n"
< < < >   "   Create database and run all jobs in it if possible.  If one job\n"
< < < >   "   failes repeatedly this will fail.  Suitable for inclusion in makefiles\n"
< < < >   "   Same as a 'create' followed by a 'shove'.\n"
< < < >   "para check \n"
< < < 44c48
< < < <   "para stop batch\n"
< < < ---
< < < >   "para stop \n"
< < < 46c50
< < < <   "para finished batch\n"
< < < ---
< < < >   "para finished \n"
< < < 48c52
< < < <   "para hung batch\n"
< < < ---
< < < >   "para hung \n"
< < < 50,54c54,58
< < < <   "para crashed batch\n"
< < < <   "   List jobs that crashed or failed output checks\n"
< < < <   "para failed batch\n"
< < < <   "   List jobs that crashed or hung\n"
< < < <   "para problems batch\n"
< < < ---
< < < >   "para crashed \n"
< < < >   "   List jobs that crashed or failed output checks the last time they were run.\n"
< < < >   "para failed \n"
< < < >   "   List jobs that crashed after repeated restarts.\n"
< < < >   "para problems \n"
< < < 56c60
< < < <   "para running batch\n"
< < < ---
< < < >   "para running \n"
< < < 58c62
< < < <   "para time batch\n"
< < < ---
< < < >   "para time \n"
< < < 68c72
< < < < int maxPush = 100000;
< < < ---
< < < > int maxPush = 10000;
< < < 71c75
< < < < int sleepTime = 20*60;
< < < ---
< < < > int sleepTime = 5*60;
< < < 336,337c340,341
< < < < void paraMake(char *batch, char *jobList)
< < < < /* Make a batch database from a job list. */
< < < ---
< < < > void paraCreate(char *batch, char *jobList)
< < < > /* Create a batch database from a job list. */
< < < 345a350
< < < > makeDir("err");
< < < 408a414
< < < >     sub->inQueue = TRUE;
< < < 459a466
< < < >     ++queueSize;
< < < 493a501,518
< < < > void freeResults(struct hash **pHash)
< < < > /* Free up results hash and elements in it. */
< < < > {
< < < > struct hash *hash = *pHash;
< < < > struct hashEl *list, *el;
< < < > struct jobResult *jr;
< < < > if ((hash = *pHash) != NULL)
< < < >     {
< < < >     list = hashElListHash(hash);
< < < >     for (el = list; el != NULL; el = el->next)
< < < > 	{
< < < > 	jr = el->val;
< < < > 	jobResultFree(&jr);
< < < > 	}
< < < >     hashElFreeList(&list);
< < < >     hashFree(pHash);
< < < >     }
< < < > }
< < < 588,590c613,614
< < < < int paraPush(char *batch)
< < < < /* Push a batch of jobs forward - submit jobs.  Return number of jobs
< < < <  * pushed. */
< < < ---
< < < > struct jobDb *paraCycle(char *batch)
< < < > /* Cycle forward through batch.  Return database. */
< < < 597a622
< < < > struct hash *resultsHash;
< < < 599d623
< < < < makeDir("err");
< < < 601c625
< < < < markRunJobStatus(db);
< < < ---
< < < > resultsHash = markRunJobStatus(db);
< < < 630d653
< < < < jobDbFree(&db);
< < < 632,633c655,658
< < < <    printf("\n");
< < < < printf("Pushed Jobs: %d\n", pushCount);
< < < ---
< < < >     {
< < < >     printf("\n");
< < < >     printf("Pushed Jobs: %d\n", pushCount);
< < < >     }
< < < 636c661,669
< < < < return pushCount;
< < < ---
< < < > freeResults(&resultsHash);
< < < > return db;
< < < > }
< < < > 
< < < > void paraPush(char *batch)
< < < > /* Push forward batch one time. */
< < < > {
< < < > struct jobDb *db = paraCycle(batch);
< < < > jobDbFree(&db);
< < < 640c673,674
< < < < /* Keep pushing jobs until finished. */
< < < ---
< < < > /* Push batch of jobs and keep pushing until it's finished, polling
< < < >  * parasol every 5 minutes. */
< < < 642c676,683
< < < < while (paraPush(batch) > 0)
< < < ---
< < < > struct jobDb *db;
< < < > struct job *job;
< < < > struct submission *sub;
< < < > int maxSleep = 5*60;
< < < > int curSleep = 60;
< < < > time_t start = time(NULL), now;
< < < > 
< < < > for (;;)
< < < 644,645c685,710
< < < <     printf("Sleeping until next push - hit <control>C to quit shoving\n");
< < < <     sleep(sleepTime);
< < < ---
< < < >     boolean anyUnfinished = FALSE;
< < < >     db = paraCycle(batch);
< < < >     for (job = db->jobList; job != NULL; job = job->next)
< < < >         {
< < < > 	if ((sub = job->submissionList) == NULL)
< < < > 	    anyUnfinished = TRUE;
< < < > 	else
< < < > 	    {
< < < > 	    enum jaState state = figureState(job);
< < < > 	    if (job->submissionCount >= retries)
< < < > 	        {
< < < > 		if (state != jaUnsubmitted && state != jaQueued && state != jaRunning)
< < < > 		    errAbort("Batch failed after %d tries on %s", retries, job->command);
< < < > 		}
< < < > 	    if (state != jaFinished)
< < < > 	        anyUnfinished = TRUE;
< < < > 	    }
< < < > 	}
< < < >     jobDbFree(&db);
< < < >     if (!anyUnfinished)
< < < >         break;
< < < >     sleep(curSleep);
< < < >     if (curSleep < maxSleep)
< < < >         curSleep += 60;
< < < >     now = time(NULL);
< < < >     printf("Checking job status %d minutes after launch\n",  round((now-start)/60.0));
< < < 646a712,719
< < < > printf("Successful batch!\n");
< < < > }
< < < > 
< < < > void paraMake(char *batch, char *spec)
< < < > /* Do a create and then a shove. */
< < < > {
< < < > paraCreate(batch, spec);
< < < > paraShove(batch);
< < < 885a959
< < < > markRunJobStatus(db);
< < < 892,893c966,969
< < < < 	   killSubmission(sub);
< < < < 	sub->crashed = TRUE;
< < < ---
< < < > 	    {
< < < > 	    killSubmission(sub);
< < < > 	    sub->crashed = TRUE;
< < < > 	    }
< < < 1058c1134
< < < < if (argc < 3)
< < < ---
< < < > if (argc < 2)
< < < 1067c1143
< < < < batch = argv[2];
< < < ---
< < < > batch = "batch";
< < < 1070c1146
< < < < if (sameString(command, "make"))
< < < ---
< < < > if (sameString(command, "create"))
< < < 1072c1148
< < < <     if (argc != 4)
< < < ---
< < < >     if (argc != 3)
< < < 1074c1150
< < < <     paraMake(batch, argv[3]);
< < < ---
< < < >     paraCreate(batch, argv[2]);
< < < 1087a1164,1169
< < < > else if (sameString(command, "make"))
< < < >     {
< < < >     if (argc != 3)
< < < >         usage();
< < < >     paraMake(batch, argv[2]);
< < < >     }
< < < 1090c1172
< < < <     maxPush = 20;
< < < ---
< < < >     maxPush = 10;
< < < Index: paraHub/paraHub.c
< < < ===================================================================
< < < RCS file: /projects/compbio/cvsroot/kent/src/parasol/paraHub/paraHub.c,v
< < < retrieving revision 1.17
< < < diff -r1.17 paraHub.c
< < < 1c1,65
< < < < /* paraHub - parasol hub server. */
< < < ---
< < < > /* paraHub - Parasol hub server.  This is the heart of the parasol system.
< < < >  * The hub daemon spawns a heartbeat daemon and a number of spoke deamons
< < < >  * on startup,  and then falls into a loop processing messages it recieves
< < < >  * on it's TCP/IP socket.  The hub daemon does not do anything time consuming
< < < >  * in this loop.   The main thing the hub daemon does is put jobs on the
< < < >  * job list,  move machines from the busy list to the free list,  and call
< < < >  * the 'runner' routine.
< < < >  *
< < < >  * The runner routine looks to see if there is a free machine, a free spoke,
< < < >  * and a job to run.  If so it will send a message to the spoke telling
< < < >  * it to run the job on the machine,  and then move the job from the 'pending'
< < < >  * to the 'running' list,  the spoke from the freeSpoke to the busySpoke list, 
< < < >  * and the machine from the freeMachine to the busyMachine list.   This
< < < >  * indirection of starting jobs via a separate spoke process avoids the
< < < >  * hub daemon itself having to wait to find out if a machine is really
< < < >  * there.
< < < >  *
< < < >  * When a spoke is done assigning a job, the spoke sense a 'recycleSpoke'
< < < >  * message to the hub, which puts the spoke back on the freeSpoke list.
< < < >  * Likewise when a job is done the machine running the jobs sends a 
< < < >  * 'job done' message to the hub, which puts the machine back on the
< < < >  * free list,  writes the job exit code to a file, and removes the job
< < < >  * from the system.
< < < >  *
< < < >  * Sometimes a spoke will find that a machine is down.  In this case it
< < < >  * sends a 'node down' message to the hub as well as the 'spoke free'
< < < >  * message.   The hub will then move the machine to the deadMachines list,
< < < >  * and put the job back on the top of the pending list.
< < < >  *
< < < >  * The heartbeat daemon simply sits in a loop sending heartbeat messages to
< < < >  * the hub every so often (every 30 seconds currently), and sleeping
< < < >  * the rest of the time.   When the hub gets a heartbeat message it
< < < >  * does a few things:
< < < >  *     o - It calls runner to try and start some more jobs.  (Runner
< < < >  *         is also called at the end of processing a spokeFree, 
< < < >  *         jobDone, addJob or addMachine message.  Typically because
< < < >  *         of this runner won't find anything new to run, but this
< < < >  *         is put here mostly just in case of unforseen issues.)
< < < >  *    o -  It calls graveDigger, a routine which sees if a machine
< < < >  *         on the dead list has been checked recently.  If not it
< < < >  *         dispatches a spoke to see if it's come back to life.
< < < >  *    o -  It calls hangman, a routine which sees if jobs the system
< < < >  *         thinks have been running for a long time are still 
< < < >  *         running on the machine they have been assigned to.
< < < >  *         If the machine has gone down it is moved to the dead list
< < < >  *         and the job is reassigned. 
< < < >  *
< < < >  * This whole system depends on the hub daemon being able to finish
< < < >  * processing messages fast enough to keep the connection queue on
< < < >  * it's socket from overflowing.  Each job involves 3 messages to the
< < < >  * main socket:
< < < >  *     addJob - from a client to add the job to the system
< < < >  *     recycleSpoke - from the spoke after it's dispatched the job
< < < >  *     jobDone - from the compute node when the job is finished
< < < >  * On some of the earlier Linux kernals we had trouble with the
< < < >  * connection queue overflowing when dispatching lots of short
< < < >  * jobs.  This seemed to be from the jobDone messages coming
< < < >  * in faster than Linux could make connections rather than the
< < < >  * hub daemon being slow.  On the kilokluster with a more modern
< < < >  * kernal this has not been a problem - even with very 0.1 second
< < < >  * jobs on 1000 CPUs.  Should overflow occur the heartbeat processing
< < < >  * should gradually rescue the system in any case, but the throughput
< < < >  * will be greatly reduced. */
< < < >  
< < < > 
< < < 462a527,528
< < < >     if (rq->f == NULL)
< < < >         warn("hub: couldn't open results file %s", rq->name);
< < < 466a533,537
< < < >     char *machName;
< < < >     if (job->machine != NULL)
< < < >         machName = job->machine->name;
< < < >     else
< < < >         machName = "ghost";
< < < 468c539
< < < <         status, job->machine->name, job->id, job->exe, 
< < < ---
< < < >         status, machName, job->id, job->exe, 
< < < 689d759
< < < < runner(1);
< < < 732c802,803
< < < < 	job->machine->lastChecked = now;
< < < ---
< < < > 	if (job->machine != NULL)
< < < > 	    job->machine->lastChecked = now;
< < < 734a806
< < < > 	runner(1);
< < < 1002a1075
< < < > 
< < < 1039c1112
< < < <     if (!netMustReadAll(connectionHandle, sig, sigLen) || !sameString(sig, paraSig))
< < < ---
< < < >     if (netReadAll(connectionHandle, sig, sigLen) < sigLen || !sameString(sig, paraSig))
< < < Index: paraHub/spoke.c
< < < ===================================================================
< < < RCS file: /projects/compbio/cvsroot/kent/src/parasol/paraHub/spoke.c,v
< < < retrieving revision 1.9
< < < diff -r1.9 spoke.c
< < < 117c117
< < < <     if (!netMustReadAll(conn, sig, sigLen))
< < < ---
< < < >     if (netReadAll(conn, sig, sigLen) != sigLen)
< < < Index: paraNode/paraNode.c
< < < ===================================================================
< < < RCS file: /projects/compbio/cvsroot/kent/src/parasol/paraNode/paraNode.c,v
< < < retrieving revision 1.10
< < < diff -r1.10 paraNode.c
< < < 353c353
< < < <     if (netMustReadAll(connectionHandle, signature, sigLen))
< < < ---
< < < >     if (netReadAll(connectionHandle, signature, sigLen) == sigLen)
< < < Index: parasol/parasol.c
< < < ===================================================================
< < < RCS file: /projects/compbio/cvsroot/kent/src/parasol/parasol/parasol.c,v
< < < retrieving revision 1.12
< < < diff -r1.12 parasol.c
< < < 334c334
< < < < 	usage;
< < < ---
< < < > 	usage();
< < < 350c350
< < < < 	    usage;
< < < ---
< < < > 	    usage();
< < Index: lib/paraLib.c
< < ===================================================================
< < RCS file: /projects/compbio/cvsroot/kent/src/parasol/lib/paraLib.c,v
< < retrieving revision 1.5
< < diff -r1.5 paraLib.c
< < 8,9c8,9
< < < char paraSig[16] = "0d2f070562685f29";  /* Mild security measure. */
< < < int paraSigSize = ArraySize(paraSig);
< < ---
< < > char paraSig[17] = "0d2f070562685f29";  /* Mild security measure. */
< < > int paraSigSize = 16;
< < Index: paraHub/heartbeat.c
< < ===================================================================
< < RCS file: /projects/compbio/cvsroot/kent/src/parasol/paraHub/heartbeat.c,v
< < retrieving revision 1.4
< < diff -r1.4 heartbeat.c
< < 19c19
< < <     sleep(30);
< < ---
< < >     sleep(MINUTE/2);
< < Index: paraHub/makefile
< < ===================================================================
< < RCS file: /projects/compbio/cvsroot/kent/src/parasol/paraHub/makefile,v
< < retrieving revision 1.6
< < diff -r1.6 makefile
< < 8c8
< < < #	strip $(HOME)/bin/$(MACHTYPE)/paraHub
< < ---
< < > 	strip $(HOME)/bin/$(MACHTYPE)/paraHub
< < Index: paraHub/paraHub.c
< < ===================================================================
< < RCS file: /projects/compbio/cvsroot/kent/src/parasol/paraHub/paraHub.c,v
< < retrieving revision 1.19
< < diff -r1.19 paraHub.c
< < 448c448
< < < int i, period = jobCheckPeriod*60;
< < ---
< < > int i, period = jobCheckPeriod*MINUTE;
< < 476c476
< < < checkPeriodically(deadMachines, 60 * machineCheckPeriod, "resurrect", 
< < ---
< < > checkPeriodically(deadMachines, MINUTE * machineCheckPeriod, "resurrect", 
< < 570c570
< < <     if (now - rq->lastUsed > 5*60)
< < ---
< < >     if (now - rq->lastUsed > 5*MINUTE)
< < Index: paraHub/paraHub.h
< < ===================================================================
< < RCS file: /projects/compbio/cvsroot/kent/src/parasol/paraHub/paraHub.h,v
< < retrieving revision 1.9
< < diff -r1.9 paraHub.h
< < 94a95,96
< < > #define MINUTE 60
< < > 
< < Index: paraHub/spoke.c
< < ===================================================================
< < RCS file: /projects/compbio/cvsroot/kent/src/parasol/paraHub/spoke.c,v
< < retrieving revision 1.10
< < diff -r1.10 spoke.c
< < 66c66
< < <     if (sameString(runCmd, command))
< < ---
< < >     if (sameString(runCmd, command) || sameString("check", command))
< < Index: paraNode/paraNode.c
< < ===================================================================
< < RCS file: /projects/compbio/cvsroot/kent/src/parasol/paraNode/paraNode.c,v
< < retrieving revision 1.11
< < diff -r1.11 paraNode.c
< < 101c101
< < <     int newStdin, newStdout, newStderr;
< < ---
< < >     int newStdin, newStdout, newStderr, execErr;
< < 123c123
< < <     if (execvp(exe, params) < 0)
< < ---
< < >     if ((execErr = execvp(exe, params)) < 0)
< < 128c128
< < <     exit(0);
< < ---
< < >     exit(execErr);
< < 174c174
< < < if (line != NULL)
< < ---
< < > if (jobIdString != NULL && line != NULL && line[0] != 0)
< < 325a326
< < > dyStringFree(&dy);
< < 353c354
< < <     if (netReadAll(connectionHandle, signature, sigLen) == sigLen)
< < ---
< < >     if (connectionHandle >= 0)
< < 355c356
< < < 	if (sameString(paraSig, signature))
< < ---
< < > 	if (netReadAll(connectionHandle, signature, sigLen) == sigLen)
< < 357,374c358,386
< < < 	    line = buf = netGetLongString(connectionHandle);
< < < 	    logIt("node  %s: %s\n", hostName, line);
< < < 	    command = nextWord(&line);
< < < 	    if (sameString("quit", command))
< < < 		break;
< < < 	    else if (sameString("run", command))
< < < 		doRun(line);
< < < 	    else if (sameString("jobDone", command))
< < < 	        jobDone(line);
< < < 	    else if (sameString("status", command))
< < < 		doStatus();
< < < 	    else if (sameString("kill", command))
< < < 		doKill(line);
< < < 	    else if (sameString("check", command))
< < < 	        doCheck(line);
< < < 	    else if (sameString("resurrect", command))
< < < 	        doResurrect(line);
< < < 	    freez(&buf);
< < ---
< < > 	    if (sameString(paraSig, signature))
< < > 		{
< < > 		line = buf = netGetLongString(connectionHandle);
< < > 		if (line != NULL)
< < > 		    {
< < > 		    logIt("node  %s: %s\n", hostName, line);
< < > 		    command = nextWord(&line);
< < > 		    if (sameString("quit", command))
< < > 			break;
< < > 		    else if (sameString("run", command))
< < > 			doRun(line);
< < > 		    else if (sameString("jobDone", command))
< < > 			jobDone(line);
< < > 		    else if (sameString("status", command))
< < > 			doStatus();
< < > 		    else if (sameString("kill", command))
< < > 			doKill(line);
< < > 		    else if (sameString("check", command))
< < > 			doCheck(line);
< < > 		    else if (sameString("resurrect", command))
< < > 			doResurrect(line);
< < > 		    freez(&buf);
< < > 		    }
< < > 		}
< < > 	    }
< < > 	if (connectionHandle != 0)
< < > 	    {
< < > 	    close(connectionHandle);
< < > 	    connectionHandle = 0;
< < 376,380d387
< < < 	}
< < <     if (connectionHandle != 0)
< < < 	{
< < < 	close(connectionHandle);
< < < 	connectionHandle = 0;
< < Index: paraNodeStatus/makefile
< < ===================================================================
< < RCS file: /projects/compbio/cvsroot/kent/src/parasol/paraNodeStatus/makefile,v
< < retrieving revision 1.2
< < diff -r1.2 makefile
< < 12a13,16
< < > 
< < > paraStat: paraStat.o
< < > 	gcc -o $(HOME)/bin/$(MACHTYPE)/paraStat paraStat.o ../lib/$(MACHTYPE)/paralib.a ../../lib/$(MACHTYPE)/jkweb.a
< < > 	strip $(HOME)/bin/$(MACHTYPE)/paraStat
< Index: para/jobDb.as
< ===================================================================
< RCS file: /projects/compbio3/cvsroot/kent/src/parasol/para/jobDb.as,v
< retrieving revision 1.3
< diff -r1.3 jobDb.as
< 15c15
< <     ubyte queueError;	"In error stat in queue"
< ---
< >     ubyte queueError;	"In error state in queue"
< Index: para/jobDb.c
< ===================================================================
< RCS file: /projects/compbio3/cvsroot/kent/src/parasol/para/jobDb.c,v
< retrieving revision 1.3
< diff -r1.3 jobDb.c
< 8,9d7
< < #include "sqlNum.h"
< < #include "sqlList.h"
< 10a9
< > #include "sqlList.h"
< Index: para/jobDb.h
< ===================================================================
< RCS file: /projects/compbio3/cvsroot/kent/src/parasol/para/jobDb.h,v
< retrieving revision 1.3
< diff -r1.3 jobDb.h
< 22c22
< <     unsigned char queueError;	/* In error stat in queue */
< ---
< >     unsigned char queueError;	/* In error state in queue */
< Index: para/para.c
< ===================================================================
< RCS file: /projects/compbio3/cvsroot/kent/src/parasol/para/para.c,v
< retrieving revision 1.15
< diff -r1.15 para.c
< 48c48
< <   "para check \n"
< ---
< >   "para check\n"
< 50c50
< <   "para stop \n"
< ---
< >   "para stop\n"
< 52c52,55
< <   "para finished \n"
< ---
< >   "para chill\n"
< >   "   Tells system to not launch more jobs in this batch, but\n"
< >   "   does not stop jobs that are already running.\n"
< >   "para finished\n"
< 54c57
< <   "para hung \n"
< ---
< >   "para hung\n"
< 56c59
< <   "para crashed \n"
< ---
< >   "para crashed\n"
< 58c61
< <   "para failed \n"
< ---
< >   "para failed\n"
< 60c63
< <   "para problems \n"
< ---
< >   "para problems\n"
< 62c65
< <   "para running \n"
< ---
< >   "para running\n"
< 64c67
< <   "para time \n"
< ---
< >   "para time\n"
< 431,432c434,436
< < char *submitJobToHub(char *jobMessage)
< < /* Submit job to hub.  Return jobId, or NULL on failure. */
< ---
< > char *hubSingleLineQuery(char *query)
< > /* Send message to hub and get single line response.
< >  * This should be freeMem'd when done. */
< 435c439
< < char *jobIdString;
< ---
< > char *result;
< 439c443
< < if (!sendWithSig(hubFd, jobMessage))
< ---
< > if (!sendWithSig(hubFd, query))
< 444c448
< < jobIdString = netRecieveLongString(hubFd);
< ---
< > result = netRecieveLongString(hubFd);
< 446c450
< < return jobIdString;
< ---
< > return result;
< 457c461
< < jobId = submitJobToHub(cmd->string);
< ---
< > jobId = hubSingleLineQuery(cmd->string);
< 640,646c644
< < 		long subTime;
< < 		subTime = sub->submitTime;
< < 		duration = now - subTime;
< < 		if (duration > 60)	/* Give it up to 60 seconds to show up. */
< < 		    sub->trackingError = 3;
< < 		else
< < 		    sub->inQueue = TRUE;
< ---
< > 		sub->trackingError = 3;
< 1028a1027,1089
< > void sendChillMessage()
< > /* Tell hub to chill out on job */
< > {
< > struct dyString *dy = newDyString(1024);
< > char curDir[512];
< > char *result;
< > if (getcwd(curDir, sizeof(curDir)) == NULL)
< >     errAbort("Couldn't get current directory");
< > dyStringPrintf(dy, "chill %s %s/para.results", cuserid(NULL), curDir);
< > result = hubSingleLineQuery(dy->string);
< > dyStringFree(&dy);
< > if (result == NULL || !sameString(result, "ok"))
< >     errAbort("Couldn't chill %s\n", curDir);
< > freez(&result);
< > }
< > 
< > 
< > int cleanTrackingErrors(struct jobDb *db)
< > /* Remove submissions with tracking errors. 
< >  * Returns count of these submissions */
< > {
< > int count = 0;
< > struct job *job;
< > struct submission *sub;
< > for (job = db->jobList; job != NULL; job = job->next)
< >     {
< >     sub = job->submissionList;
< >     if (sub != NULL)
< >         {
< > 	if (sub->trackingError)
< > 	    {
< > 	    job->submissionCount -= 1;
< > 	    job->submissionList = sub->next;
< > 	    ++count;
< > 	    }
< > 	}
< >     }
< > return count;
< > }
< > 
< > void removeChilledSubmissions(char *batch)
< > /* Remove submissions from job database if we
< >  * asked them to chill out. */
< > {
< > struct jobDb *db = readBatch(batch);
< > int chillCount;
< > 
< > markQueuedJobs(db);
< > markRunJobStatus(db);
< > chillCount = cleanTrackingErrors(db);
< > printf("Chilled %d jobs\n", chillCount);
< > atomicWriteBatch(db, batch);
< > }
< > 
< > void paraChill(char *batch)
< > /*  Tells system to not launch more jobs in this batch, but
< >  *  does not stop jobs that are already running.\n */
< > {
< > sendChillMessage();
< > printf("Told hub to chill out %s\n", batch);
< > removeChilledSubmissions(batch);
< > }
< > 
< 1046,1047d1106
< < 
< < 
< 1080,1091d1138
< < void killSubmission(struct submission *sub)
< < /* Kill a submission. */
< < {
< < struct dyString *cmd = newDyString(256);
< < int hubFd = netConnect("localhost", paraPort);
< < dyStringPrintf(cmd, "%s %s", "removeJob", sub->id);
< < mustSendWithSig(hubFd, cmd->string);
< < close(hubFd);
< < freeDyString(&cmd);
< < }
< < 
< < 
< 1325a1373,1376
< >     }
< > else if (sameString(command, "chill"))
< >     {
< >     paraChill(batch);
< Index: paraHub/paraHub.c
< ===================================================================
< RCS file: /projects/compbio3/cvsroot/kent/src/parasol/paraHub/paraHub.c,v
< retrieving revision 1.28
< diff -r1.28 paraHub.c
< 127a128,130
< > struct hash *stringHash;	/* Unique strings throughout system go here
< >                                  * including directory names and results file
< > 				 * names. */
< 442c445
< < job->dir = cloneString(dir);
< ---
< > job->dir = hashStoreName(stringHash, dir);
< 445c448
< < job->results = cloneString(results);
< ---
< > job->results = hashStoreName(stringHash, results);
< 458d460
< <     freeMem(job->dir);
< 462d463
< <     freeMem(job->results);
< 918a920,948
< > 
< > void chillBatch(char *line, int connectionHandle)
< > /* Stop launching jobs from a batch, but don't disturb
< >  * running jobs. */
< > {
< > char *userName = nextWord(&line);
< > char *batch = nextWord(&line);
< > char *res = "err";
< > if (batch != NULL)
< >     {
< >     struct user *user = hashFindVal(userHash, userName);
< >     batch = hashStoreName(stringHash, batch);
< >     if (user != NULL)
< > 	{
< > 	struct dlNode *el, *next;
< > 	for (el = user->jobQueue->head; !dlEnd(el); el = next)
< > 	    {
< > 	    struct job *job = el->val;
< > 	    next = el->next;
< > 	    if (job->results == batch)
< > 		recycleJob(job);	/* This free's el too! */
< > 	    }
< > 	res = "ok";
< > 	}
< >     }
< > netSendLongString(connectionHandle, res);
< > }
< > 
< > 
< 1251a1282
< > stringHash = newHash(0);
< 1314a1346,1347
< > 	else if (sameWord(command, "chill"))
< > 	     chillBatch(line, connectionHandle);
< Index: paraNode/paraNode.c
< ===================================================================
< RCS file: /projects/compbio3/cvsroot/kent/src/parasol/paraNode/paraNode.c,v
< retrieving revision 1.25
< diff -r1.25 paraNode.c
< 214a215,228
< >     /* Update environment. */
< >         {
< > 	struct hash *hash = environToHash(environ);
< > 	hashUpdate(hash, "JOB_ID", jobIdString);
< > 	hashUpdate(hash, "USER", user);
< > 	hashUpdate(hash, "HOME", homeDir);
< > 	hashUpdate(hash, "HOST", hostName);
< > 	hashUpdate(hash, "PARASOL", "1");
< > 	updatePath(hash, userPath, homeDir, sysPath);
< > 	environ = hashToEnviron(hash);
< > 	freeHashAndVals(&hash);
< > 	}
< >     logIt("exevp %s\n", exe);
< > 
< 229,240d242
< <     /* Update environment. */
< <         {
< < 	struct hash *hash = environToHash(environ);
< < 	hashUpdate(hash, "JOB_ID", jobIdString);
< < 	hashUpdate(hash, "USER", user);
< < 	hashUpdate(hash, "HOME", homeDir);
< < 	hashUpdate(hash, "HOST", hostName);
< < 	hashUpdate(hash, "PARASOL", "1");
< < 	updatePath(hash, userPath, homeDir, sysPath);
< < 	environ = hashToEnviron(hash);
< < 	freeHashAndVals(&hash);
< < 	}
< 244,245c246,247
< < 	perror("");
< < 	warn("Error execlp'ing %s %s", exe, params);
< ---
< > 	perror("execvp");
< > 	warn("Error execvp'ing %s %s", exe, params);
Index: para/para.c
===================================================================
RCS file: /projects/compbio3/cvsroot/kent/src/parasol/para/para.c,v
retrieving revision 1.17
diff -r1.17 para.c
75c75
< int maxQueue = 200000;
---
> int maxQueue = 1000000;
1145c1145
< int chillCount;
---
> int killCount = 0;
1149c1149
< chillCount = cleanTrackingErrors(db);
---
> cleanTrackingErrors(db);
1160a1161
> 	    killCount += 1;
1164a1166
> printf("%d running jobs stopped\n", killCount);
Index: paraNodeStatus/paraNodeStatus.c
===================================================================
RCS file: /projects/compbio3/cvsroot/kent/src/parasol/paraNodeStatus/paraNodeStatus.c,v
retrieving revision 1.2
diff -r1.2 paraNodeStatus.c
26a27
> int totalCpu = 0, totalBusy = 0;
37a39
> 	    char *row[3];
39a42,46
> 	    chopLine(status, row);
> 	    totalBusy += atoi(row[0]);
> 	    if (!sameString(row[1], "of"))
> 	        errAbort("paraNode status message format changed");
> 	    totalCpu += atoi(row[2]);
51a59
> printf("%d of %d CPUs busy total\n", totalBusy, totalCpu);
